<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"youfindme.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="冰河的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="冰河">
<meta property="og:url" content="https://youfindme.top/index.html">
<meta property="og:site_name" content="冰河">
<meta property="og:description" content="冰河的个人网站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冰河">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://youfindme.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冰河</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冰河</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">一起从零实现React SSR服务端渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-21 17:25:00" itemprop="dateCreated datePublished" datetime="2023-12-21T17:25:00+08:00">2023-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Next.js 14 发布了，很多地方都在讨论，虽然之前也有用过 Next.js，也看过一些关于 SSR 的文章，了解了一些 SSR 的原理，但是一直没有动手实现过。这次正好趁着这个机会，从零开始手动实现一个 React SSR 服务端渲染的项目，来加深一下对 SSR 的理解。</p>
<h2 id="一、-什么是SSR"><a href="#一、-什么是SSR" class="headerlink" title="一、 什么是SSR"></a>一、 什么是SSR</h2><p>SSR，即Server Side Render，服务端渲染。和服务端渲染相对的，就是CSR，Client Side Render，客户端渲染。</p>
<p>从字面意思上就有看出，这两种渲染方式的差别就在于页面渲染的时机：</p>
<ul>
<li>服务端渲染是页面在服务端的时候就渲染完成了</li>
<li>而客户端渲染是页面在客户端（浏览器或者WebView之类的）进行渲染，服务端只会返回空页面（下面例子中会讲到）</li>
</ul>
<h2 id="二、-为什么需要SSR"><a href="#二、-为什么需要SSR" class="headerlink" title="二、 为什么需要SSR"></a>二、 为什么需要SSR</h2><p>在讨论为什么需要SSR之前，我们先来看看常见的CSR，比如下面这个很简单的React渲染的页面：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/page_overview.png" alt="page_overview.png"></p>
<p>页面包含一个count计数，点击“Increment”、“Decrement”和“Reset”按钮，分别可以增加计数，减小计数以及重设计数。</p>
<p>现在我们打开DevTool，看看访问这个地址的时候服务端返回的内容：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_html_content.png" alt="csr_html_content.png"></p>
<p>从DevTool可以看到，服务端一共返回了两个文件，一个HTML一个JS。</p>
<p><strong>我们发现HTML里没有任何页面上的元素，是空的</strong>，只有一个root节点和一个main.js脚本。而所有的这些count计数以及下面这些按钮，都是在HTML页面以及main.js下载完成后，浏览器通过执行main.js来进行渲染生成的，这也就是所谓的客户端渲染。</p>
<p>通过这个我们可以发现，CSR的应用有两个比较明显的问题：</p>
<h3 id="1-CSR应用十分不利于SEO"><a href="#1-CSR应用十分不利于SEO" class="headerlink" title="1. CSR应用十分不利于SEO"></a>1. CSR应用十分不利于SEO</h3><p>SEO，也就是Search Engine Optimization，搜索引擎优化。CSR应用从服务端返回的HTML是一个空的页面，页面内容元素完全依赖JS代码来生成，导致搜索引擎爬虫在抓取和解析网页时，无法获取到完整的网页内容，从而不利于搜索引擎优化搜索结果和搜索排名。</p>
<blockquote>
<p>题外话：现在的一些搜索引擎（比如Google）已经可以解析CSR应用里的JS，所以CSR目前对SEO的影响可能没有以前那么大了，但是如果SEO对你来说很重要，那么最好还是做一些SSR服务端渲染</p>
</blockquote>
<h3 id="2-首屏加载时间可能较长"><a href="#2-首屏加载时间可能较长" class="headerlink" title="2. 首屏加载时间可能较长"></a>2. 首屏加载时间可能较长</h3><p>由于CSR应用页面里所有的内容，都是通过JS动态生成的，那么在访问页面的时候，除了下载HTML外，还需要额外下载JS脚本才可以展示出页面。</p>
<p>衡量首屏加载性能的指标有很多，我们这里用常用的<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint?utm_source=devtools">FCP（First Contentful Paint）</a>，即“首次内容渲染”时间来看下这个页面的表现。由于我们这个页面太过简单，而且是在本地<code>127.0.0.1</code>启动的服务，所以直接感受可能不明显，我们可以在DevTool里设置网络状态，改成“低速3G”来模拟：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_network_panel.png" alt="csr_network_panel.png"></p>
<p>而FCP除了可以用<code>performance</code> API获取到之外，也可以直接在Chrome DevTool的“性能”面板，通过点击面板里的“重新加载”按钮录制得到：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_perf_panel.png" alt="csr_perf_panel.png"></p>
<p>从上面的网络瀑布和性能面板可以看到，在“低速3G”的网络状态下，页面在获取到2.01s获取到HTML后，并没有渲染任何内容，而是在又等了4.76s等到JS下载完成之后，才渲染出内容，页面的FCP总计是6822.2ms。</p>
<p>也就是说，在2.01s的时候，HTML已经下载好的情况下，用户还是无法看到内容，额外等待了4.76s等待JS的下载，首屏加载时间较长。</p>
<p>下面我们就来尝试把上面这个项目改成支持服务端渲染，来改善这两个CSR的弊端。</p>
<h2 id="三、-准备好一个项目"><a href="#三、-准备好一个项目" class="headerlink" title="三、 准备好一个项目"></a>三、 准备好一个项目</h2><p>首先我们先准备好上面这个项目的代码，这是项目的GitHub地址，大家可自取：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></p>
<p>项目的目录结构长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── Button</span><br><span class="line">│   │       ├── index.module.css</span><br><span class="line">│   │       └── index.tsx</span><br><span class="line">│   ├── Home.module.css</span><br><span class="line">│   ├── Home.tsx</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── index.tsx</span><br><span class="line">├── webpack</span><br><span class="line">│   └── client.config.js</span><br><span class="line">├── .babelrc</span><br><span class="line">├── .eslintignore</span><br><span class="line">├── .eslintrc.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .prettierignore</span><br><span class="line">├── .prettierrc.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── types.d.ts</span><br></pre></td></tr></table></figure>

<p>关键的几个文件内容如下：</p>
<ol>
<li><code>src/components/Button/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IButtonProps &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span>;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Button: React.FC&lt;IButtonProps&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  text,</span></span></span><br><span class="line"><span class="params"><span class="function">  className,</span></span></span><br><span class="line"><span class="params"><span class="function">  onClick,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">className</span>=<span class="string">&#123;classNames(styles.btn,</span> <span class="attr">className</span>)&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;text&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>src/Home.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;@/components/Button&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Home.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Home: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.btnWrapper&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Increment&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Decrement&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Reset&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(0)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>src/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>webpack/client.config.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ForkTsCheckerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;fork-ts-checker-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist/client&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>, path.resolve(rootDir, <span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">      <span class="attr">scriptLoading</span>: <span class="string">&#x27;defer&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;&#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">performance</span>: &#123;</span><br><span class="line">    <span class="attr">hints</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">maxEntrypointSize</span>: <span class="number">512000</span>,</span><br><span class="line">    <span class="attr">maxAssetSize</span>: <span class="number">512000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>package.json</code></li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之前，其他一些都是代码规范化相关的配置，比如eslint、prettier之类的，不是这次重点讨论的范围，感兴趣的可以看我之前这篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/7314365567376162853">《前端代码规范化配置最佳实践 - 掘金》</a>。</p>
<p>通过在本地执行<code>npm run dev</code>或者<code>npm run build</code>，就可以编译项目，这里我没有使用webpack dev server，而是起了一个Nginx服务，简单改了一下Nginx配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">3006</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   /your-project-location/react-<span class="literal">no</span>-ssr-demo/dist/client;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样直接在浏览器访问<code>127.0.0.1:3006</code>或者<code>localhost:3006</code>就可以了。</p>
<h2 id="四、-使用服务端渲染"><a href="#四、-使用服务端渲染" class="headerlink" title="四、 使用服务端渲染"></a>四、 使用服务端渲染</h2><p>现在让我们开始给项目添加服务端渲染，既然要服务端渲染，就必须在服务端使用React的<a target="_blank" rel="noopener" href="https://react.docschina.org/reference/react-dom/server/renderToString">renderToString</a>来渲染好HTML再返回给客户端，既然要求在服务端跑JS代码，那么服务端就必须要引入Node了，也就是说做服务端渲染，必须要有一个Node做中间层（Next.js的<a target="_blank" rel="noopener" href="https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation">SSG</a>不算是严格意义上的服务端渲染，不在讨论范围内）。</p>
<h3 id="1-添加Node服务"><a href="#1-添加Node服务" class="headerlink" title="1. 添加Node服务"></a>1. 添加Node服务</h3><p>现在让我们先加一个基础的Node服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br><span class="line">npm install --save-dev @types/express</span><br></pre></td></tr></table></figure>

<p>添加一个<code>src/server.tsx</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;React SSR&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我们换了一个<code>3007</code>端口，为了和刚刚的CSR项目的<code>3006</code>端口区分开来（另外使用了Node服务之后，也就不需要Nginx了）。</p>
<p>从上面的代码可以看到，<code>src/server.tsx</code>中，先创建了一个express服务，然后监听了<code>3007</code>端口，在访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>的时候，服务端调用ReactDOMServer的<code>renderToString</code>方法，将我们的<code>Home</code>组件渲染为了HTML字符串，并且拼接到了一个HTML模板中，返回给了客户端。</p>
<h3 id="2-添加src-server-tsx的编译配置"><a href="#2-添加src-server-tsx的编译配置" class="headerlink" title="2. 添加src/server.tsx的编译配置"></a>2. 添加<code>src/server.tsx</code>的编译配置</h3><p>由于<code>src/server.tsx</code>使用了TS和JSX的语法，那么这个文件也需要使用webpack和babel进行编译，让我们添加一下这个server文件的编译配置，<code>webpack/server.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/server.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;server.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在<code>package.json</code>中添加一下编译服务端的scripts命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run dev:server</code>以及<code>npm start</code>之后，打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_no_js.gif" alt="ssr_no_js.gif"></p>
<p>果然，这次服务端返回的HTML不再是空的了，页面上的元素直接就可以在HTML中看到。</p>
<p>但是这里奇怪的是，页面的样式没有了，点击这些按钮也不再生效了，同时从网络请求里看到，服务端也只返回了一个HTML，没有JS，这是为什么呢？</p>
<h2 id="五、-同构-amp-hydrate"><a href="#五、-同构-amp-hydrate" class="headerlink" title="五、 同构 &amp; hydrate"></a>五、 同构 &amp; hydrate</h2><p>其实，这是因为我们上面实现的SSR还不是一个完整的React SSR项目。<code>renderToString</code>虽然可以在服务端把组件渲染为HTML，但是却无法实现事件监听器的挂载或者绑定（毕竟事件绑定是要绑定到浏览器上真实的DOM上，而不是HTML字符串上），所以在<code>renderToString</code>的时候会把事件处理器给过滤掉。</p>
<h3 id="1-同构"><a href="#1-同构" class="headerlink" title="1. 同构"></a>1. 同构</h3><p>那么为了实现完整的SSR，就需要引入“同构渲染”的概念了。这个词相信大家之前都或多或少听过，其实很简单，同构渲染就是同一份代码，既在服务端运行（SSR），又在客户端运行（CSR）。</p>
<p>最开始我们提到的那个CSR代码，只是在客户端运行，后来加上的服务端渲染的能力，只是在服务端运行（客户端只是接收了一个HTML，并没有运行什么JS代码）。现在需要将两者结合起来，接下来让我们开始改造一下：</p>
<p>首先，<code>src/server.tsx</code>中，我们不再直接返回一个模板HTML，而是在上面CSR项目编译出来的HTML中直接加上服务端渲染的内容，同时在服务端提供静态资源访问服务：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientDistDir = path.resolve(__dirname, <span class="string">&#x27;../dist/client&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlPath = path.resolve(clientDistDir, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 读取 dist/client/index.html 文件</span></span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(htmlPath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 将渲染后的 React HTML 插入到 div#root 中</span></span><br><span class="line">  <span class="keyword">const</span> finalHtml = html.replace(</span><br><span class="line">    <span class="string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">`&lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;`</span></span><br><span class="line">  );</span><br><span class="line">  res.send(finalHtml);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供静态资源访问服务</span></span><br><span class="line">app.use(express.static(clientDistDir));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接在命令行执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm run dev:server</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_render.gif" alt="ssr_render.gif"></p>
<p>看起来好像OK了，既有服务端渲染（返回的HTML不为空，直接就有页面上的元素），又有服务端渲染（事件绑定成功，有页面交互）。但是如果这个时候你查看一下控制台的话，会发现会有一个Waring：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_render_warn.png" alt="ssr_render_warn.png"></p>
<p>说是调用<code>ReactDOM.render()</code>去渲染（水合，或者说注水）一个服务端渲染的页面的行为会在React 18停止支持。</p>
<h3 id="2-hydrate"><a href="#2-hydrate" class="headerlink" title="2. hydrate"></a>2. hydrate</h3><p>其实这个从<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/server/renderToString#reference">React官网</a>也可以看到，在服务端使用<code>renderToString</code>外进行服务端渲染后，还需要在客户端使用<code>hydrate</code>（或者<code>hydrateRoot</code>，后者是React 18中的写法），来完成事件绑定和页面的交互性逻辑。</p>
<p>来改下代码，在<code>src/index.tsx</code>中，改为如下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.hydrate(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>同时为了方便调试，安装一下两个依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save nodemon</span><br><span class="line">npm install --save-dev npm-run-all</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;npm-run-all --parallel dev:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:client&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npm-run-all build:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:client&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>nodemon</code>用于监听<code>dist/server.js</code>的变化，一旦修改了<code>src/server.tsx</code> webpack会重新编译，生成新的<code>dist/server.js</code>，这个时候nodemon会重新运行新的<code>dist/server.js</code>。</p>
<p><code>npm-run-all</code>则用于同时运行多个npm命令。</p>
<p>这个时候再运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>，发现已经没有Waring了：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_hydrate_no_warn.png" alt="ssr_hydrate_no_warn.png"></p>
<h3 id="3-hydrate和render的区别"><a href="#3-hydrate和render的区别" class="headerlink" title="3. hydrate和render的区别"></a>3. hydrate和render的区别</h3><p><code>render()</code>和<code>hydrate()</code>在大部分情况下的行为是相似的，这两个都会将React元素渲染到指定的DOM节点中，但是在处理服务端渲染返回的HTML是有一些区别。</p>
<p>服务端渲染的时候，服务端会渲染React元素并且生成一个HTML字符串返回给客户端（也就是浏览器），之后客户端会用这个HTML来生成DOM。在同构渲染的时候，客户端还会重新执行一遍JS代码，重新生成一个React组件树和相应的DOM节点。而<code>render()</code>和<code>hydrate()</code>的区别就在这里。</p>
<p><code>render()</code>会直接创建一个新的React组件数和相应的DOM节点，而<code>hydrate()</code>则是在生成的时候，会判断这个节点是否已经在服务端渲染好，<strong>会尽可能地保留现有的DOM，只更新必要的部分</strong>。</p>
<p>这也就是React官网所说的：</p>
<blockquote>
<p>Call hydrate in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.</p>
<p>React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it.</p>
</blockquote>
<p>在React 17及以下版本中调用<code>hydrate</code>，可以将React“附加”到在服务器环境中已经由React渲染的现有HTML上。</p>
<p>React将会附加到<code>domNode</code>内部现有的HTML，并接管有关的DOM的管理。</p>
<h2 id="六、-再来看下CSR的两个痛点"><a href="#六、-再来看下CSR的两个痛点" class="headerlink" title="六、 再来看下CSR的两个痛点"></a>六、 再来看下CSR的两个痛点</h2><p>到这里就算是完成了一个最基本的React服务端渲染，现在我们回头来看一下，是否解决了上面CSR项目的两个痛点。</p>
<h3 id="1-SEO"><a href="#1-SEO" class="headerlink" title="1. SEO"></a>1. SEO</h3><p>首先是之前SEO不友好的问题。</p>
<p>在做了SSR渲染后，从服务端返回的HTML里就已经包含了页面上的元素，搜索引擎爬虫在抓取和解析网页时，可以获取到完整的网页内容，显然SSR渲染可以解决这个问题（当前想要更好的SEO效果，还有其他可以优化的地方，不过这些就和CSR/SSR无关了）。</p>
<h3 id="2-FCP"><a href="#2-FCP" class="headerlink" title="2. FCP"></a>2. FCP</h3><p>其次，我们来看一下首屏的加载时间，还是通过设置DevTool里设置网络状态，改成“低速3G”来看一下FCP：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_network_panel.png" alt="ssr_network_panel.png"></p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_perf_panel.png" alt="ssr_perf_panel.png"></p>
<p>从上面可以看到，虽然网络面板内的HTML和JS整体的加载时间和之前几乎一样（都是6.8s左右），但是从性能面板里可以看到，页面的FCP是2043.2ms，比之前的6822.2ms少了将近70%。</p>
<p>从时间轴的截图上也可以发现，页面在HTML下载成功之后（2.02s），就立刻可以看到页面内容，虽然页面的交互还是需要等到6.8s JS下载完成，但是从用户体验上来讲，缩短页面的白屏时间，用户可以更快的看到页面内容，对于用户体验是一个很大的提升。</p>
<p>也就是说，SSR确实解决了CSR的两个痛点。</p>
<h2 id="七、-服务端渲染一些主要注意的事情"><a href="#七、-服务端渲染一些主要注意的事情" class="headerlink" title="七、 服务端渲染一些主要注意的事情"></a>七、 服务端渲染一些主要注意的事情</h2><p>下面是一些做服务端渲染时需要注意的点：</p>
<h3 id="1-React的生命周期和一些Hooks"><a href="#1-React的生命周期和一些Hooks" class="headerlink" title="1. React的生命周期和一些Hooks"></a>1. React的生命周期和一些Hooks</h3><p>React的一些生命周期函数，比如类组件的<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以及函数组件的<code>useEffect</code>和<code>useLayoutEffect</code>，都不会在服务端渲染的时候执行。</p>
<h3 id="2-浏览器专属的API"><a href="#2-浏览器专属的API" class="headerlink" title="2. 浏览器专属的API"></a>2. 浏览器专属的API</h3><p>浏览器专属的API，比如<code>window</code>，<code>document</code>，<code>localStorage</code>等，都不能在服务器端运行，需要判断只有在当前环境是客户端才可以执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="3-事件处理函数"><a href="#3-事件处理函数" class="headerlink" title="3. 事件处理函数"></a>3. 事件处理函数</h3><p>如上面提到的那样，服务端渲染的时候，不会执行事件处理函数，也不会触发任何事件，需要在客户端处理。</p>
<h3 id="4-服务端渲染和客户端渲染时的差异"><a href="#4-服务端渲染和客户端渲染时的差异" class="headerlink" title="4. 服务端渲染和客户端渲染时的差异"></a>4. 服务端渲染和客户端渲染时的差异</h3><p>在进行同构渲染的时候，<strong>请务必保证</strong>客户端渲染出来的内容和服务端渲染的内容完全相同。如果客户端和服务端渲染出来的内容不一致，React会尝试对不一致的地方进行修复，而这些修复是<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/hydrate#caveats">非常耗时的</a>。如果差异过大甚至会重新渲染整个应用（类似于<code>ReactDOM.render</code>）。</p>
<p>所以应尽量避免客户端渲染出来的内容和服务端渲染出来的内容不一致。</p>
<h2 id="八、-小结"><a href="#八、-小结" class="headerlink" title="八、 小结"></a>八、 小结</h2><p>通过上面的内容，我们从零手动完成了一个React服务端渲染的Demo项目，这只是一个最基础的项目，还有更多的比如React路由服务端渲染、服务端渲染时的数据脱水和注水等等，都需要添加更加复杂的配置，有时间了再单独写一篇聊一下。</p>
<p>这里附上文章里提到的两个Demo项目地址：</p>
<ul>
<li>CSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></li>
<li>SSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-ssr-demo">react-ssr-demo</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://react.dev/">https://react.dev</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文) - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0">http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/325952676">什么是前端的同构渲染？</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc">https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/15/DockerNginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/15/DockerNginx/" class="post-title-link" itemprop="url">使用 Docker 安装 Nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-15 19:37:06" itemprop="dateCreated datePublished" datetime="2023-12-15T19:37:06+08:00">2023-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx bash</span><br><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/docker/nginx/conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx:/etc/nginx/nginx.conf /opt/docker/nginx/conf/nginx.conf</span><br><span class="line">docker cp nginx:/etc/nginx/conf.d/ /opt/docker/nginx/conf/conf.d</span><br><span class="line">docker cp nginx:/var/<span class="built_in">log</span>/nginx/ /opt/docker/nginx/logs</span><br><span class="line">docker cp nginx:/usr/share/nginx/html/ /opt/docker/nginx/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 80:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个是有问题的，这样设置里之后，访问 `http://localhost:80` 依然可以访问到 nginx 的默认页面</span></span><br><span class="line"><span class="comment"># 因为这个命名使用了 `--net host` 选项，这个选项会让容器使用宿主机的网络，所以 Docker 中的 Nginx 依然会监听宿主机的 80 端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是在云服务器上使用 Docker 安装 Nginx，那么下面的命令会导致，使用 8080 端口也可能访问呢不到 Nginx 的默认页面，因为一般情况下云服务器默认的防火墙会关闭 8080 端口。</span></span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">--net host \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7176299143659257893">完整详细使用Docker安装Nginx教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/15932500.html">docker+nginx 安装部署修改资源目录配置文件和容器端口信息</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44248903/article/details/134803724">2023 docker nginx安装教程(含portainer教程)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49194578/article/details/117341481">Docker 安装 nginx 并且配置反向代理遇到的坑</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/" class="post-title-link" itemprop="url">Sentry治理之Issue分组（Issue Grouping）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-11 13:05:23" itemprop="dateCreated datePublished" datetime="2023-12-11T13:05:23+08:00">2023-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Sentry大家应该都不陌生，即便没有使用过，也应该听过Sentry的大名。</p>
<p>作为一个实时事件日志监控平台，Sentry可以记录和聚合我们应用中的报错、打点等，不管是Sentry自动捕获的错误，还是我们主动上报的错误，都可以在Sentry提供的可视化平台看到，方便开发者及时发现、分析和排查应用中存在的问题。</p>
<p>但是在使用Sentry的过程中，我们发现了一些使用起来不那么方便的地方，这个就是我们今天要一起讨论的问题——Sentry Issue的分组（Issue Grouping）。</p>
<h2 id="二、先看看什么是Sentry-Issue"><a href="#二、先看看什么是Sentry-Issue" class="headerlink" title="二、先看看什么是Sentry Issue"></a>二、先看看什么是Sentry Issue</h2><p>在Sentry中，每一条日志上报都是一个事件（Event）,在Sentry的Discover面板中，我们可以看到所有上报的Event，比如我这个项目：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/discover.png" alt="Discover面板"></p>
<p>Event分为两种类型，Transaction和Error。</p>
<p>Transaction事件主要用于性能监控。它记录了一个请求或任务从开始到结束的完整生命周期，包括各种详细的性能数据，如请求的开始时间、结束时间、总耗时、各个阶段的耗时等。</p>
<p>Error事件主要用于错误跟踪。它记录了应用运行过程中发生的错误或异常，包括错误的类型、位置、堆栈跟踪等信息。</p>
<p>而<strong>Issue就是Error类型的Event的聚合</strong>，Sentry会把一些相似的Error进行聚合，合并成一个Issue，这样我们就可以看到某个特定Error发生的频率和趋势，而不仅仅是只能看到单个Error Event。</p>
<p>Sentry的Issue可以在Issues面板中看到，如下图所示：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issues.png" alt="Issue面板"></p>
<p>从这个面板可以看到某个Issue（即某个类型的Error），上报了几次，有多少用户遇到了这个Error，以及这个Error数量变化的趋势，帮助我们快速确认问题的严重程度和影响范围。</p>
<h2 id="三、我们遇到啥问题了？"><a href="#三、我们遇到啥问题了？" class="headerlink" title="三、我们遇到啥问题了？"></a>三、我们遇到啥问题了？</h2><p>从上面的描述可以看到，Sentry把Error进行聚合，合并成一个个Issue，帮助我们查看某个类型Error的一些信息，看起来是挺好的。</p>
<p>但是在我们的项目里，Sentry好像并不是这么做的，比如下图：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/repeat_issues.png" alt="重复的Issue"></p>
<p>说好的自动聚合分组呢？</p>
<p>同样的一个Error（或者是极其相似的Error）,并没有被聚合为同一个Issue，而是分到了不同的几个Issue里，并且这些Issue的名字几乎一摸一样，每个Issue还各自展示一个Event次数。</p>
<p>而且这个问题不止出现在某一种类型的Error上，几乎所有的Error上报都或多或少地存在这种问题，导致不能很好地分析某种Error的影响或者变化趋势。</p>
<p>而且有时候即便我们手动Ignore某个Issue，未来还是会不断地有新的这个Issue出现，或者我们像下面这样手动Merge两个Issue，也还是会源源不断地产生新的、没有被Merge进手动Merge的分组内的Issue。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<h2 id="四、研究下Sentry是怎么对Error分组的"><a href="#四、研究下Sentry是怎么对Error分组的" class="headerlink" title="四、研究下Sentry是怎么对Error分组的"></a>四、研究下Sentry是怎么对Error分组的</h2><p>在解决我们遇到的问题之前，还是要先了解下Sentry是怎么对Error进行分组的，知道原理才能着手解决。</p>
<p>看了下官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>，这才揭开了Sentry分组的面纱。</p>
<h3 id="1-Sentry-Issue的Fingerprint和分组"><a href="#1-Sentry-Issue的Fingerprint和分组" class="headerlink" title="1. Sentry Issue的Fingerprint和分组"></a>1. Sentry Issue的Fingerprint和分组</h3><p>在Sentry中，有一个“指纹”的概念，Fingerprint，Fingerprint是标识Event的一种方式，每个Event（包括Error和Transaction）都有一个Fingerprint。</p>
<p>Sentry会根据某种规则，来给每一个Event生成Fingerprint，具有相同Fingerprint的Event会被Sentry分为一组，这就是Sentry分组的基本原则。</p>
<h4 id="1-1-如何在Sentry上查看一个Event的Fingerprint呢？"><a href="#1-1-如何在Sentry上查看一个Event的Fingerprint呢？" class="headerlink" title="1.1 如何在Sentry上查看一个Event的Fingerprint呢？"></a>1.1 如何在Sentry上查看一个Event的Fingerprint呢？</h4><p>从Discover或者Issues列表中，随便点击一个进入Error详情（Transaction不行，下面会讲原因），点击查看这个Error对应原始JSON数据：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_detail_json.png" alt="查看原始JSON"></p>
<p>在原始JSON中搜索fingerprint字段，可以看到如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;fingerprint&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个<code>&#123;&#123; default &#125;&#125;</code>，这说明使用的是Sentry默认规则生成的Fingerprint。如果是其他的规则，则会展示为其他的值。</p>
<h4 id="1-2-Event默认的Fingerprint生成规则"><a href="#1-2-Event默认的Fingerprint生成规则" class="headerlink" title="1.2 Event默认的Fingerprint生成规则"></a>1.2 Event默认的Fingerprint生成规则</h4><p>不同类型的Event，有不同的Fingerprint生成规则：</p>
<ul>
<li>Error类型：Error类型会基于这个Error的调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>，从这三个方面来生成Fingerprint</li>
<li>Transaction类型：通过这个类型的Spans来生成，可以查看原始JSON数据中的<code>spans</code>字段</li>
</ul>
<p>我们这次只讨论Error类型的Event Fingerprint生成规则。</p>
<p>首先，Sentry每个版本生成Fingerprint的默认规则可能会有一些差异，每次Sentry默认的Fingerprint生成规则变化了之后，Sentry都会发布一个新版本，所以Fingerprint生成规则变化了之后，不会影响已有的Event。</p>
<p>每次新建一个Project，都会自动使用目前最新版本的Fingerprint生成规则，如果想要现有的Project升级到最新的Fingerprint生成规则，需要在设置里手动修改，具体位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Upgrade Grouping</strong>.如下图：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/upgrade_grouping.png" alt="升级分组"></p>
<p>所有版本的Fingerprint生成规则都是最先考虑<code>Stack Trace</code>，然后是<code>Exception</code>, 最后是<code>message</code>。</p>
<h5 id="a-按照Stack-Trace分组"><a href="#a-按照Stack-Trace分组" class="headerlink" title="a. 按照Stack Trace分组"></a>a. 按照Stack Trace分组</h5><p>对于一个上报的Error Event，如果他的原始数据中有调用堆栈信息，就会完全根据调用堆栈来进行分组（即不考虑其他的），主要会使用下列信息：</p>
<ul>
<li>模块名module</li>
<li>文件名（去除哈希值等之后的名字）filename</li>
<li>上下文，行号列号等信息</li>
</ul>
<p>这里的堆栈信息只包括和当前Project有关的堆栈，和当前项目无关的堆栈信息不会用于分组。</p>
<p>堆栈信息可以在原始的JSON数据中的<code>exception.values</code>的<code>stacktrace</code>字段中看到，如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;exception&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;xxx err&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;stacktrace&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;frames&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;rrr&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;uuu&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///ddd/eee/fff.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">20</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">57</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>stacktrace</code>字段中有个<code>frames</code>，是一个数据，记录的是当前Error发生时的调用堆栈帧列表，数组中的每一项就是一个调用帧（frame），每一帧中都有如下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Sentry就是根据这些调用栈的帧列表，来生成Fingerprint。即相同调用堆栈的错误，被认为是同一种类Error，会被归为同一组。</p>
<p>用这个方法来分组，一般来说效果都挺不错，但是如果出现下面这些情况，就会导致这个分组方法或者说分组规则，效果不那么好：</p>
<ol>
<li><p>代码经过混淆或者压缩（比如TS/JS代码经过Babel编译）<br>由于混淆或者压缩之后，代码的变量名、函数名、代码结构等都会发生变化，即便对于同一个Error，不同版本的代码（比如两个release版本之间，或者两次不同的构建之间）的调用堆栈信息也会发生变化，导致Sentry认为这些是不同的Error，从而没有进行聚合分组。<br>如果代码有混淆或者压缩，就需要上传Source Maps到Sentry，让Sentry通过原始的堆栈信息生成Fingerprint，来避免分组混乱。</p>
</li>
<li><p>代码通过装饰器等引入了新的堆栈层级，也会导致调用堆栈发生变化。比如</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> decoratorFn = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Before function execution&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;After function execution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @decoratorFn</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，<code>myFunction</code>被<code>decoratorFn</code>装饰。当调用<code>myFunction</code>时，实际上是在调用<code>decoratorFn</code>返回的函数。因此，如果在这个过程中发生错误并生成堆栈信息，堆栈信息中将会包含<code>decoratorFn</code>返回的函数的调用，这就是通过引入新的堆栈层级来修改堆栈信息。</p>
<p>可以通过自定义的<code>beforeSend</code>来自定义删除或者修改这些堆栈信息（下面会讲到）。</p>
<h5 id="b-按照Exception分组"><a href="#b-按照Exception分组" class="headerlink" title="b.按照Exception分组"></a>b.按照Exception分组</h5><p>如果上报的Error Event的数据中没有堆栈调用信息，但是有完整的<code>Exception</code>信息（这里的完整指的是<code>Exception</code>的type和value同时存在），就会按照<code>Exception</code>的type和value进行分组，但是这种分组可靠性比较低，因为错误的信息可能会改变。</p>
<p>这里的<code>Exception</code>指的就是各种Error，JS里的<code>Exception</code>就是各种类型的<code>Error</code>，比如<code>ReferenceError</code>、<code>TypeError</code>、<code>RangeError</code>、<code>SyntaxError</code>等。</p>
<ul>
<li><code>Exception</code>的type就是Error的name，如果有自定义的name就是自定义的name，比如<code>DownloadFileError</code>，没有自定义的话默认就是各个类型名</li>
<li>Exception的value指的就是err.message</li>
</ul>
<p>比如访问一个未定义的变量，JS会抛出一个<code>ReferenceError</code>，type就是“ReferenceError”，value可能是“x is not defined”。</p>
<p>如果是下面的自定义name的Error：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;This is a mock err msg&#x27;</span>);</span><br><span class="line">err.name = <span class="string">&#x27;MyMockError&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个Error的type就是“MyMockError”，value就是“This is a mock err msg”。</p>
<p>这里的type和value也可以直接在Sentry上任意一个Error原始的JSON数据中看到，JSON中的<code>metadata</code>字段，记录了这个Error的type和value：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;display_title_with_tree_label&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;MyMockError: This is a mock err msg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;MyMockError&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;This is a mock err msg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>问：</strong></em><br>什么情况下会出现存在Exception但是不包含堆栈信息？</p>
<p><em><strong>ChatGPT:</strong></em><br>在大多数情况下，当JavaScript抛出一个异常时，这个异常都会包含一个堆栈跟踪。堆栈跟踪记录了错误发生时的函数调用序列，这对于理解和调试错误是非常有用的。<br>然而，在某些情况下，异常可能不包含堆栈跟踪。例如：</p>
<ol>
<li><p>如果你手动创建并抛出一个错误，但没有提供堆栈跟踪，那么这个错误就不会有堆栈跟踪。例如，throw new Error()会创建一个包含堆栈跟踪的错误，但throw { message: ‘error’ }则不会。</p>
</li>
<li><p>在某些JavaScript环境中，例如某些旧版本的浏览器或某些JavaScript引擎，可能不支持堆栈跟踪，或者支持的方式与标准不同。</p>
</li>
<li><p>如果错误发生在异步代码中，并且这个错误没有被正确地捕获和处理，那么可能只有错误信息，没有堆栈跟踪。</p>
</li>
<li><p>如果你的代码中有捕获错误并处理的逻辑，可能会修改或移除堆栈跟踪。</p>
</li>
</ol>
</blockquote>
<h5 id="c-兜底的分组"><a href="#c-兜底的分组" class="headerlink" title="c. 兜底的分组"></a>c. 兜底的分组</h5><p>如果上面两种情况都没办法对Event进行分组，那么就会使用兜底的分组，即直接使用上报的时候收到的Event消息来分组。</p>
<h4 id="1-3-分析一下"><a href="#1-3-分析一下" class="headerlink" title="1.3 分析一下"></a>1.3 分析一下</h4><p>到这里我们可以先分析一下，为什么我们的项目会出现上面说的问题了。</p>
<p>首先，我们的项目没有修改过任何和Event Fingerprint有关的设置，使用的是默认分组规则，即使用调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>来进行分组。而绝大部分都是使用调用堆栈进行分组。</p>
<p>我们的JS项目由于某种原因，在编译后没有把Source Maps上传到Sentry，导致代码的变量名、函数名、代码结构等在不同版本或者不同的构建记录后，都会发生变化，所以即便某个Issue被Ignore或者被手动Merge，到下一个版本，由于同一个Error的调用栈变化了，生成了完全不同的Fingerprint，导致没有被分为一组。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/mixed_call_stack.png" alt="混淆压缩后的代码的调用栈"></p>
<blockquote>
<p><strong>💡注意：</strong><br>代码混淆之后并不是会让Sentry没办法对Error生成Fingerprint以及分组，即使代码被混淆和压缩，只要所有用户都使用的是同一份混淆和压缩后的代码，那么同一个地方的Error应该会生成相同的堆栈跟踪，Sentry应该能够正确地将这些错误分到同一组。</p>
<p>真正的问题在于多个版本或者多个构建之间，每次压缩混淆后的代码都不一样，从而导致不同版本直接Error分组混乱。</p>
</blockquote>
<p>看来使用默认的Fingerprint生成规则不行了，至少在我们项目上传Source Maps之前不行。需要看下怎么自定义分组。</p>
<h4 id="1-4-自定义分组"><a href="#1-4-自定义分组" class="headerlink" title="1.4 自定义分组"></a>1.4 自定义分组</h4><p>首先，只有Error类型的Event支持自定义分组，Transaction类型的暂时无法自定义。这也是为什么上面说Transaction类型的Event，无法在原始JSON数据中看到fingerprint字段的原因，因为Transaction Event无法自定义，所以也就不会展示在JSON数据里。</p>
<p>对于Error类型的Event，从简单到复杂有以下4种方式来自定义分组：</p>
<ol>
<li><p>在Sentry Admin对应的项目Issues列表中，手动Merge<br>手动合并（你认为是）相同的Issues，最简单，不需要修改任何设置和配置项。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Fingerprint Rules<br>设置Fingerprint Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Stack Trace Rules<br>设置Stack Trace Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在使用Sentry SDK的本地项目里，使用SDK Fingerprinting<br>在本地项目中，使用SDK上报之前，设置Event的Fingerprint。</p>
</li>
</ol>
<p>下面我们一个个来看。</p>
<h3 id="2-手动合并Issue"><a href="#2-手动合并Issue" class="headerlink" title="2. 手动合并Issue"></a>2. 手动合并Issue</h3><p>在Sentry项目的Issues列表中，手动选择2或者更多个Issue，然后点击Merge，即可合并为一个分组。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<p>需要注意的是，Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则，新产生的Issue还是会按照之前的规则来分组，然后根据放到我们手动Merge的Issue集合中。</p>
<p>这也解释了为什么我们项目中，每次手动Merge之后，还是会产生新的没有被进入Merge后的分组，因为“Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则”。</p>
<h3 id="3-Stack-Trace-Rules"><a href="#3-Stack-Trace-Rules" class="headerlink" title="3. Stack Trace Rules"></a>3. Stack Trace Rules</h3><p>虽然按照Sentry官网的文档的说法，Stack Trace Rules要比Fingerprint Rules复杂一些，我们还是先来讲下Stack Trace Rules。</p>
<p>在比较旧的Sentry版本中，Stack Trace Rules也叫作Grouping Enhancements或者Custom Grouping Enhancements。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Stack Trace Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Custom Grouping Enhancements</strong>。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/stack_trace_rules.png" alt="Stack Trace Rules"></p>
<p>修改Stack Trace Rules会影响<strong>输入到Stack Trace分组算法中的数据</strong>。我们可以通过规则来改变哪些stack trace frames被视为”in-app”，这会影响Sentry如何将Issue分组。例如，我们可以将某些通常被视为”not in-app”的frames标记为”in-app”，这样它们就会被包含在分组算法中。</p>
<p>在自定义的Stack Trace Rules中，每一行都是一条规则。每条规则有匹配项（matcher）、表达式（expression），以及跟在后面的操作（action）组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matcher-name:expression other-matcher:expression ... action1 action2 ...</span><br></pre></td></tr></table></figure>

<p>一条规则里可以有多个匹配表达式，后面也可以有多个action。这些action会在前面所有匹配表达式匹配的时候执行。</p>
<p>所有的规则会从上到下，对调用堆栈信息里的所有帧（Frames）执行。</p>
<p>如果要表达否定，那么就在matcher前加上一个感叹号<code>!</code>，某一行以<code>#</code>开头则表达这一行是注释。</p>
<p>下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mark all functions in the std namespace to be outside the app</span><br><span class="line">family:native stack.function:std::*       -app</span><br><span class="line"></span><br><span class="line"># mark all code in node modules not to be in app</span><br><span class="line">stack.abs_path:**/node_modules/**         -app</span><br><span class="line"></span><br><span class="line"># remove all generated javascript code from all grouping</span><br><span class="line">stack.abs_path:**/generated/**.js         -group</span><br></pre></td></tr></table></figure>

<p>由于Stack Trace Rules不是我们这次讨论的重点，这里就不太说太多了，更多详细的关于Matchers和Actions的信息，详见官方文档：<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#matchers">Matchers</a>，<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#actions">Actions</a>。</p>
<h3 id="4-Fingerprint-Rules"><a href="#4-Fingerprint-Rules" class="headerlink" title="4. Fingerprint Rules"></a>4. Fingerprint Rules</h3><p>在比较旧的Sentry版本中，也叫作Server Side Fingerprinting（叫这个名字是为了和SDK Fingerprinting对应）。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Fingerprint Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Server Side Fingerprinting</strong>。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/fingerprint_rules.png" alt="Fingerprint Rules"></p>
<p>Fingerprint Rules的配置方式和Stack Trace Rules类似，只有语法上不同。但是和Stack Trace Rules不同的是，Fingerprint Rules允许我们直接指定一个Issue的Fingerprint，它会完全覆盖默认的分组规则。</p>
<p>可以理解为，<strong>Stack Trace Rules更关注如何改变分组算法的输入数据</strong>（比如翻转一些标志位，或者对调用栈做一些裁剪），而<strong>Fingerprint Rules则直接指定了分组的结果</strong>。</p>
<p>首先，Fingerprint Rules同样是每一行是一条规则。每一条规则的Matcher和Stack Trace Rules的语法规则也是一样的，并且都可以设置<code>!</code>来表示取反，以及设置<code>#</code>来注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># You can use comments to explain the rules.  Rules themselves follow the</span><br><span class="line"># following syntax:</span><br><span class="line">matcher:expression -&gt; list of values</span><br><span class="line"># The list of values can be hardcoded or substituted values.</span><br></pre></td></tr></table></figure>

<p>Fingerprint Rules也是把一个Event从上到下进行匹配，每条规则都是对调用堆栈信息里的所有帧（Frames）执行，并且会把匹配到的第一条规则作为Event的Fingerprint。</p>
<p>不同的是，Stack Trace Rules的Matcher右侧是对Stack Trace Frames数据进行的一些操作，Fingerprint Rules的Matcher右侧直接就是需要指定的Fingerprint的值，可以是一些写死的<strong>常量</strong>，也可以是一些<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">内置的变量（Variables）</a>。</p>
<p>下面的例子就是把Error类型的Event根据type和value进行分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把 DatabaseUnavailable 和 ConnectionError 这两种类型的 Error，都标记为 system-down</span><br><span class="line">error.type:DatabaseUnavailable -&gt; system-down</span><br><span class="line">error.type:ConnectionError -&gt; system-down</span><br><span class="line"></span><br><span class="line"># 把 Error message 中，包含“connection error: ”的，都标记为 connection-error，同时把当时 Error 的 transaction 字段也拼接到 Fingerprint 中</span><br><span class="line">error.value:&quot;connection error: *&quot; -&gt; connection-error, &#123;&#123; transaction &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-Matchers"><a href="#4-1-Matchers" class="headerlink" title="4.1 Matchers"></a>4.1 Matchers</h4><p>对于Matchers，Sentry允许使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Glob_(programming)">glob patterns</a>语法。Sentry包含了以下的这些Matcher：</p>
<ul>
<li>error.type<br>匹配Error的type（name），对应的是JSON中的<code>metadata.type</code>，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.type:ZeroDivisionError -&gt; zero-division</span><br><span class="line">error.type:ConnectionError -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>error.value<br>匹配Error的value（message），对应的是JSON中的<code>metadata.value</code>，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.value:&quot;connection error (code: *)&quot; -&gt; connection-error</span><br><span class="line">error.value:&quot;could not connect (*)&quot; -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>message<br>匹配日志消息，对应的是JSON中的<code>message</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message:&quot;system encountered a fatal problem: *&quot; -&gt; fatal-log</span><br></pre></td></tr></table></figure>

<ul>
<li>logger<br>匹配当前的logger的名称，对应的是JSON中的<code>logger</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.mypackage.*&quot; -&gt; mypackage-logger</span><br></pre></td></tr></table></figure>

<ul>
<li>level<br>匹配当前Event的日志级别，对应的是JSON中的<code>level</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.FooLogger&quot; level:&quot;error&quot; -&gt; mylogger-error</span><br></pre></td></tr></table></figure>

<ul>
<li>tags.tag_name<br>匹配某个tag，某个标签名，允许使用通配符。<br>这里的tag_name，对应的是JSON中的<code>tags</code>字段中，每一项的名字。tags是一个数字，代表多个标签，每一项是一个标签，每个标签也是一个数字，数组有两个元素，第一个元素是标签名，即tag_name，第二个是标签值。例如下面这样：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iPhone10,2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device.family&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS 16.1.2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os.name&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;environment&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;release&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev-v3.24&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">      <span class="string">&quot;3.24.1023&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags.release:&quot;dev-v3.x&quot; -&gt; dev-v3-error</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.abs_path<br>匹配调用栈帧的绝对路径，对应的是每一帧中的<code>abs_path</code>字段，允许使用通配符，且大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.abs_path:&quot;**/my-utils/*.js&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.module<br>匹配调用栈帧的模块名，对应的是每一帧中的<code>module</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.module:&quot;*/my-utils/*&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.function<br>匹配调用栈帧的方法名，对应的是每一帧中的<code>function</code>字段，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;my_assertion_failed&quot; -&gt; my-assertion-failed</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.package<br>匹配当前帧所在的<code>package</code>，允许使用通配符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.package:&quot;**/libcurl.dylib&quot; -&gt; libcurl</span><br><span class="line">stack.package:&quot;**/libcurl.so&quot; -&gt; libcurl</span><br></pre></td></tr></table></figure>

<ul>
<li>family<br>通常用来缩小匹配范围，且通常和其他Matcher一起使用，目前包含以下值：<ul>
<li>javascript，任何来自于JavaScript的Event</li>
<li>native，任何来自于Native的Event</li>
<li>other，其他任何Event</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family:native !stack.module:&quot;myproject::*&quot; -&gt; not-from-my-project</span><br></pre></td></tr></table></figure>

<ul>
<li>app<br>匹配当前帧是否是在app内，通常和其他Matcher一起使用，包含yes和no两个值，对应的是每一帧中的in_app字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:yes stack.function:&quot;assert&quot; -&gt; assert</span><br></pre></td></tr></table></figure>

<p>更多关于Matchers的信息，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#matchers">Matchers</a>。</p>
<h4 id="4-2-Variables"><a href="#4-2-Variables" class="headerlink" title="4.2 Variables"></a>4.2 Variables</h4><p>在一条Fingerprint Rule的右侧，就是Variables，这里其实不只可以是变量，也可以是一些写死的常量。</p>
<p>对于变量来说，它们和Matchers的名字一样，并且会自动把变量对应的原始的值填入，用于生成Fingerprint。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;evaluate_script&quot; -&gt; script-evaluation, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这条规则会匹配调用栈中方法名为<code>evaluate_script</code>的Error，并且会把常量<code>script-evaluation</code>和当前Error的type（name）作为一部分，一起生成Fingerprint。</p>
<p>例如，<code>[&quot;script-evaluation&quot;, &quot;ReferenceError&quot;]</code></p>
<p>或者，<code>[&quot;script-evaluation&quot;, &quot;TypeError&quot;]</code></p>
<p>其他的变量和Matchers的名字一样，都是使用<code>&#123;&#123; &#125;&#125;</code>包裹起来的，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">Variables</a>。</p>
<h4 id="4-3-自定义标题"><a href="#4-3-自定义标题" class="headerlink" title="4.3 自定义标题"></a>4.3 自定义标题</h4><p>在设置Fingerprint Rules时，我们往往是想要按照自己的规则对Event进行分组，但是Event通常都是使用type和value来作为标题展示在Sentry中的，如果只改了Fingerprint Rules，那么原始的Event标题可能不那么友好，或者具有一定的误导性。</p>
<p>这个时候，我们可以在添加Fingerprint Rules的时候，额外添加title字段，即可设置这个分组的标题。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:my.package.* level:error -&gt; error-logger, &#123;&#123; logger &#125;&#125; title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>自定义标题前：</strong></p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_before_rename.png" alt="自定义标题前"></p>
<p><strong>自定义标题后：</strong></p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_after_rename.png" alt="自定义标题后"></p>
<p>在设置了自定义标题后，就可以在Error的原始JSON数据中看到title发生了变化：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/title_changed_in_json.png" alt="自定义标题后的JSON"></p>
<blockquote>
<p><strong>🔔 注意：</strong></p>
<p>只有比较新的版本（比如Sentry 23.x）才支持设置自定义的title在旧版本的Sentry中（比如Sentry 20.x），上面的写法会让Sentry把后面的<code>title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</code>认为是Fingerprint的一部分。</p>
<p>具体是哪个版本开始支持的我没在网上查到，如果你私有部署的Sentry版本发现不支持，可以尝试升级一下版本。</p>
</blockquote>
<h4 id="4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules"><a href="#4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules" class="headerlink" title="4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?"></a>4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?</h4><p>在添加了自定义的Fingerprint Rules之后，我们如何确定某个Event有没有命中呢？</p>
<p>其实我们直接查看对于的JSON数据即可，如果匹配上的话，会看到下图这样：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/finger_print_in_json.png" alt="匹配上的JSON"></p>
<p>我们可以在_fingerprint_info中看到当前Event的各种信息</p>
<ul>
<li><code>client_fingerprint</code>，对应的是这个Event的SDK Fingerprint（下面会讲到，当前Event没有设置SDK Fingerprint，所以为default）</li>
<li><code>matched_rule</code>，对应的是Fingerprint Rules，比如这里显示当前Event命中的Matchers是哪个，以及当前Matchers设置的Fingerprint，还有我们自定义的title</li>
</ul>
<p>同时下面的<code>fingerprint</code>字段，也展示了当前Event最终的Fingerprint。</p>
<p>如果是旧版Sentry的话，这里就没有<code>_fingerprint_info</code>这个字段了，同时会把我们设置的title认为是Fingerprint的一部分，会是下面这样：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/old_version_custom_title_in_json.png" alt="旧版Sentry的JSON"></p>
<h3 id="5-SDK-Fingerprint"><a href="#5-SDK-Fingerprint" class="headerlink" title="5. SDK Fingerprint"></a>5. SDK Fingerprint</h3><p>如果上面说的Fingerprint Rules，不能满足我们的需要，那么我们可以使用SDK Fingerprint来更灵活地生成Fingerprint。</p>
<blockquote>
<p>从上面的Fingerprint Rules文档可以看到，Fingerprint Rules只有少部分Matchers支持设置通配符，所以可能没那么灵活。</p>
</blockquote>
<p>如果从上面的官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>中看，会发现文档里没有单独SDK Fingerprint的文档。</p>
<p>这是因为SDK Fingerprint是针对不同的Sentry SDK的，不同的项目会使用不同的Sentry SDK。每个SDK中设置Fingerprint的方式都不一样，甚至可能部分SDK不支持设置Fingerprint。所以要针对不同的平台，查看各自平台的SDK文档，这里以JavaScript Sentry SDK为例<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/javascript/usage/sdk-fingerprinting/">SDK Fingerprinting for Browser JavaScript</a>。</p>
<p><em>更多平台请看这里：<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/">Platforms</a></em></p>
<p>官网文档提供了比较友好的三个例子：</p>
<h4 id="5-1-基础示例"><a href="#5-1-基础示例" class="headerlink" title="5.1 基础示例"></a>5.1 基础示例</h4><p>单独处理某个上报Event的Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">method, path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(method, path, options).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    Sentry.withScope(<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// group errors together based on their request and response</span></span><br><span class="line">      scope.setFingerprint([method, path, <span class="built_in">String</span>(err.statusCode)]);</span><br><span class="line">      Sentry.captureException(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用变量替换，把一些Fingerprint Rules支持的变量填入，作为我们设置的Fingerprint的一部分，比如<code>&#123;&#123; default &#125;&#125;</code>，<code>&#123;&#123; stack.abs_path &#125;&#125;</code>，<code>&#123;&#123; error.type &#125;&#125;</code>等，详见上面提到的Fingerprint Rules变量。</p>
<h4 id="5-2-更细粒度地控制分组"><a href="#5-2-更细粒度地控制分组" class="headerlink" title="5.2 更细粒度地控制分组"></a>5.2 更细粒度地控制分组</h4><p>在原有的Fingerprint后拼接上自定义的一些字段，可以达到比默认的规则更细粒度的控制。</p>
<p>比如下面例子，进一步拆分Sentry创建的默认分组（由<code>&#123;&#123; default &#125;&#125;</code>表示），同时考虑错误对象的一些属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRPCError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message, functionName, errorCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The name of the RPC function that was called (e.g. &quot;getAllBlogArticles&quot;)</span></span><br><span class="line">    <span class="built_in">this</span>.functionName = functionName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For example a HTTP status code returned by the server.</span></span><br><span class="line">    <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MyRPCError) &#123;</span><br><span class="line">      event.fingerprint = [</span><br><span class="line">        <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span>,</span><br><span class="line">        <span class="built_in">String</span>(exception.functionName),</span><br><span class="line">        <span class="built_in">String</span>(exception.errorCode),</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-3-完全重写Fingerprint"><a href="#5-3-完全重写Fingerprint" class="headerlink" title="5.3 完全重写Fingerprint"></a>5.3 完全重写Fingerprint</h4><p>还可以直接整个重写Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnectionError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DatabaseConnectionError) &#123;</span><br><span class="line">      event.fingerprint = [<span class="string">&quot;database-connection-error&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-和Fingerprint-Rules怎么划分职责？"><a href="#5-4-和Fingerprint-Rules怎么划分职责？" class="headerlink" title="5.4 和Fingerprint Rules怎么划分职责？"></a>5.4 和Fingerprint Rules怎么划分职责？</h4><p>Fingerprint Rules和SDK Fingerprint都可以实现相同的功能，那么我们在设置自定义Fingerprint的时候，要怎么取舍，或者说什么时候用Fingerprint Rules，什么时候用SDK Fingerprint？</p>
<p><strong>Fingerprint Rules：</strong></p>
<ul>
<li>优势：<ul>
<li>可以随时修改规则，不需要进行代码的变更</li>
<li>可以同时在线上所有版本生效</li>
</ul>
</li>
<li>劣势：<ul>
<li>没有SDK Fingerprint灵活，有些处理不了，比如error.type不支持通配符匹配</li>
</ul>
</li>
</ul>
<p><strong>SDK Fingerprint：</strong></p>
<ul>
<li>优势：<ul>
<li>灵活，可以用JS很方便地处理或者自定义Fingerprint</li>
</ul>
</li>
<li>劣势：<ul>
<li>需要修改代码</li>
<li>分组规则和代码版本耦合，如果应用需要用户手动升级的话，那么旧版本应用内的Sentry上报没办法处理</li>
</ul>
</li>
</ul>
<p>从上面的优劣对比来看，可以看到<strong>Fingerprint Rules和SDK Fingerprint是优劣互补的，一方的优势恰好是另一方的劣势</strong>。</p>
<p>对比下来，我们在项目中使用的时候，建议<strong>如果可以使用Fingerprint Rules实现的，都用Fingerprint Rules，只有在Fingerprint Rules无法满足的情况下，再用考虑使用SDK Fingerprint</strong>。</p>
<h3 id="6-Filter"><a href="#6-Filter" class="headerlink" title="6. Filter"></a>6. Filter</h3><p>上面说了这么多关于Issue分组的，那么对于一些我完全不想要的上报，有没有办法完全不分组，直接过滤掉呢？</p>
<p>也是有的，可以在Sentry平台上，直接设置一些Filter过滤器来过滤，而不需要我们手动在使用SDK的地方修改。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Inbound Filters</strong>。</p>
<p>过滤器分为内置的一些过滤器，和自定义的过滤器。</p>
<h4 id="6-1-内置过滤器"><a href="#6-1-内置过滤器" class="headerlink" title="6.1 内置过滤器"></a>6.1 内置过滤器</h4><p>Sentry平台内置了一些可以直接启用的过滤器，这些过滤器包括：</p>
<ul>
<li>浏览器拓展插件的error</li>
<li>来自于localhost的event</li>
<li>已知的旧版浏览器错误，比如IE的</li>
<li>已知的网络爬虫错误</li>
<li>React hydrate的报错（和React服务端渲染有关的错误）</li>
<li>……</li>
</ul>
<p>这些过滤器可能和不同版本的Sentry有关，比较旧的版本中，可能会缺少一些过滤器。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/built_in_filters.png" alt="内置过滤器"></p>
<h4 id="6-2-自定义过滤器"><a href="#6-2-自定义过滤器" class="headerlink" title="6.2 自定义过滤器"></a>6.2 自定义过滤器</h4><p>可以创建自定义过滤器，目前支持以下三种，以下三种在匹配时，都是大小写不敏感的。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/custom_filters.png" alt="自定义过滤器"></p>
<h5 id="a-特定IP地址"><a href="#a-特定IP地址" class="headerlink" title="a. 特定IP地址"></a>a. 特定IP地址</h5><p>可以设置IP地址，过滤特定IP的错误上报，比如<code>127.0.0.1</code>。</p>
<h5 id="b-特定发布版本"><a href="#b-特定发布版本" class="headerlink" title="b. 特定发布版本"></a>b. 特定发布版本</h5><ul>
<li>发布版本，指的是在Sentry.init的时候，传入的release字段。</li>
<li>可以使用通配符，比如production-v3.24.*</li>
<li>如果某个Event不包含release字段，那么这个Event不会被过滤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">release</span>: <span class="string">`<span class="subst">$&#123;env&#125;</span>-<span class="subst">$&#123;version&#125;</span>`</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不确定自己项目上报后最终的<code>release</code>字段是什么，可以直接查看任意一个Error Event的原始JSON数据中的<code>release</code>字段（前提是init时传入了这个字段或者Event数据中有这个字段）</p>
<h5 id="c-Error-Message"><a href="#c-Error-Message" class="headerlink" title="c. Error Message"></a>c. Error Message</h5><ul>
<li>可以设置多个匹配项，每行一个。只要任意一个匹配项匹配成功，那么就会过滤这一条上报</li>
<li>对于Error类型的Event，会根据设置的匹配项，对格式为<code>&#123;exception.type&#125;: &#123;exception.value&#125;</code>的整个错误描述进行匹配。<br>但是不建议直接匹配整个描述，比如把冒号也加在里面，一般都是通过通配符来进行匹配。比如<code>*ConnectionError*</code></li>
<li>Transaction类型的Event，不会被过滤</li>
</ul>
<p>在设置完之后，可以检查下Issue的原始JSON数据，设置的过滤器会根据JSON里的<code>title</code>字段进行匹配，可以检查下是否有问题。</p>
<p>在设置好过滤器之后，我们就可以看到有多少Event被过滤掉了：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/filterd_issues.png" alt="过滤掉的Event"></p>
<h2 id="五、治理"><a href="#五、治理" class="headerlink" title="五、治理"></a>五、治理</h2><p>到这里我们已经搞明白Sentry对Issue分组的原理了，也知道了怎么自定义分组。那我们是使用Stack Trace Rules还是Fingerprint Rules来处理呢？</p>
<p>使用Stack Trace Rules本质上还是根据调用栈来进行分组，但是这就需要我们必须上传Source Maps。</p>
<p>在上传了Source Maps的情况下，可以通过设置调用栈Stack Trace Rules来<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#cut-stack-traces">裁切调用栈</a>，或者限制Sentry在生成调用栈Fingerprint的时候需要考虑的<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#stack-trace-frame-limits">top帧数量</a>。</p>
<p>考虑到目前我们的项目因为某种原因，还不能上传Source Maps，同时代码每个版本变化可能会导致同样的问题的调用堆栈信息不同。基于我们的需求来看，完全自定义的Fingerprint Rules更符合我们的情况。</p>
<p>所以我们的项目会做如下处理：</p>
<ul>
<li>在Sentry平台上设置Fingerprint Rules，处理绝大部分可以处理的Error</li>
<li>少部分Fingerprint Rules无法处理的Error（比如error.type不支持通配符），通过SDK Fingerprint，在代码中Sentry.init的时候，增加<code>beforeSend</code>进行处理</li>
<li>一些不需要关注的Error，设置Inbound Filters直接过滤</li>
</ul>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>一番调研下来，通过Fingerprint Rules，Stack Trace Rules，SDK Fingerprint，以及Inbound Filters，我们把项目的Issue进行了自定义分组，更方便我们排查问题，分析处理。</p>
<p>Sentry是一个简单易上手的监控平台，但是Sentry上也有许多十分复杂的配置项，这篇文章只是Sentry文档的一小部分，有哪里不正确的，还请多多指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/" class="post-title-link" itemprop="url">字符编码简史：从二进制到UTF-8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-11T00:00:00+08:00">2023-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>所谓<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码（Character encoding）</a>，就是把字符集中的字符，以某种指定的格式或规则，映射到另外一个集合中某一个值（相当于是把字符从一种形式转换成另一种形式），以便字符在计算机中存储或通过网络传递。</p>
<p>从计算机诞生到现在，对于字符的编码经历了多个阶段的变化，让我们一起来了解下字符编码的发展简史。</p>
</blockquote>
<h2 id="一、为什么聊这个"><a href="#一、为什么聊这个" class="headerlink" title="一、为什么聊这个"></a>一、为什么聊这个</h2><p>为什么会想要聊这个呢？这还得从开发中遇到的一个bug说起。</p>
<p>在一次开发中，由于要对一些字符串中的字符做一些高亮和截断，但是最开始只考虑了英文字符，单个字符的长度都是1，但是后续由于部分中文、emoji的加入，导致长度判断出了问题，出现了一些乱码。我们发现emoji的长度大多数为2甚至更长，比如“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span>.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这激起了我的一些好奇心，于是乎从头开始，完整了解了一下字符编码的发展简史。</p>
<h2 id="二、从二进制到各国编码"><a href="#二、从二进制到各国编码" class="headerlink" title="二、从二进制到各国编码"></a>二、从二进制到各国编码</h2><h3 id="1-二进制"><a href="#1-二进制" class="headerlink" title="1. 二进制"></a>1. 二进制</h3><p>我们都知道，由于电子管只有<code>开</code>和<code>关</code>这两种状态，所以计算机采用的是二进制来存储数据，也就是说所有的数据，最终都是以二进制的形式被计算机存储起来的。例如，a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示。</p>
<p>采用二进制可以更方便计算机进行运算，但是对于使用计算机的人类来说，就不那么方便了。为了方便人可以看懂计算机的二进制数据，需要<strong>设计一套规则来说明用哪些二进制数字表示哪个符号</strong>，这就是<strong>编码</strong>。</p>
<h3 id="2-ASCII"><a href="#2-ASCII" class="headerlink" title="2. ASCII"></a>2. ASCII</h3><p>为了防止不同的计算机使用不同的编码规则造成混乱，美国有关的标准化组织就推出了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII">ASCII编码（American Standard Code for Information Interchange，美国信息交换标准代码）</a>。</p>
<p>具体来说，ASCII编码一共规定了128个字符的编码，包括大小写英文字母、数字、常用符号，以及32个无法打印出来的控制符号。128个字符分别用数字<code>0 ~ 127</code>（十进制）来表示，对应的二进制为<code>0000 0000 ~ 0111 1111</code>。比如<code>a</code>对应是<code>97</code>（十进制），相应的二进制为<code>0110 0001</code>。</p>
<p>这样的话，任意英文都可以在计算机中用二进制表示了，比如“Hello world”这句话，在计算机中的表示就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100</span><br></pre></td></tr></table></figure>

<p>按理说128个字符，用7位二进制表示就够了（<em>2^7=128</em>），为什么要用8位二进制来表示呢。因为计算机里数据的计量单位是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节（byte）</a>，一个字节是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">8比特（bit）</a>，也就是8位，所以使用8位二进制（一个字节）来表示这128个字符，最前面的一位统一规定为0。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td><em>NUL</em></td>
<td><em>SOH</em></td>
<td><em>STX</em></td>
<td><em>ETX</em></td>
<td><em>EOT</em></td>
<td><em>ENQ</em></td>
<td><em>ACK</em></td>
<td><em>BEL</em></td>
<td><em>BS</em></td>
<td><em>HT</em></td>
<td><em>LF</em></td>
<td><em>VT</em></td>
<td><em>FF</em></td>
<td><em>CR</em></td>
<td><em>SO</em></td>
<td><em>SI</em></td>
</tr>
<tr>
<td>1x</td>
<td><em>DLE</em></td>
<td><em>DC1</em></td>
<td><em>DC2</em></td>
<td><em>DC3</em></td>
<td><em>DC4</em></td>
<td><em>NAK</em></td>
<td><em>SYN</em></td>
<td><em>ETB</em></td>
<td><em>CAN</em></td>
<td><em>EM</em></td>
<td><em>SUB</em></td>
<td><em>ESC</em></td>
<td><em>FS</em></td>
<td><em>GS</em></td>
<td><em>RS</em></td>
<td><em>US</em></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td><em>DEL</em></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>是空格。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>表示不同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII#%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">控制字符</a>。</p>
<h3 id="3-编码的“战国时期”"><a href="#3-编码的“战国时期”" class="headerlink" title="3. 编码的“战国时期”"></a>3. 编码的“战国时期”</h3><p>ASCII码是美国人发明的，对于只用英文的美国人来说，ASCII码其实就够用了，但是在计算机传到欧洲时情况就有变化了。虽然很多欧洲国家的语言中也是包含26个英文字母，但是很多国家还会包含一些带有声调或者其他附加符号的字母或者其他字母，如<code>À</code>、<code>Ö</code>等。对于这些字母，ASCII码无法表示。</p>
<h4 id="3-1-Latin-1"><a href="#3-1-Latin-1" class="headerlink" title="3.1 Latin-1"></a>3.1 Latin-1</h4><p>在这种背景下，欧洲推出了自己的一种编码，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1编码（又叫做ISO/IEC 8859-1）</a>。这个编码以ASCII为基础，使用了ASCII码中没有用到的第一位，在空置的<code>0xA0 ~ 0xFF</code>（即十进制的<code>160 ~ 255</code>，二进制的<code>1010 0000 ~ 1111 1111</code>）的范围内，加入96个字母及符号，以供使用附加符号的拉丁字母语言使用。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td><em>NBSP</em></td>
<td>¡</td>
<td>¢</td>
<td>£</td>
<td>¤</td>
<td>¥</td>
<td>¦</td>
<td>§</td>
<td>¨</td>
<td>©</td>
<td>ª</td>
<td>«</td>
<td>¬</td>
<td><em>SHY</em></td>
<td>®</td>
<td>¯</td>
</tr>
<tr>
<td>Bx</td>
<td>°</td>
<td>±</td>
<td>²</td>
<td>³</td>
<td>´</td>
<td>µ</td>
<td>¶</td>
<td>·</td>
<td>¸</td>
<td>¹</td>
<td>º</td>
<td>»</td>
<td>¼</td>
<td>½</td>
<td>¾</td>
<td>¿</td>
</tr>
<tr>
<td>Cx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">À</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">Á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">Â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">Ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">Ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">Å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">Æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">Ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">È</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">É</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">Ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">Ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">Ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">Í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">Î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">Ï</a></td>
</tr>
<tr>
<td>Dx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">Ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">Ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">Ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">Ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">Ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">Õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">Ö</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%97">×</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">Ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">Ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">Ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">Û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">Ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">Ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">Þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9F">ß</a></td>
</tr>
<tr>
<td>Ex</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">à</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">è</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">é</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">ï</a></td>
</tr>
<tr>
<td>Fx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">ö</a></td>
<td>÷</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C5%B8">ÿ</a></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>（32）是空格、<code>0xA0</code>（160）是不换行空格、<code>0xAD</code>是选择性连接号。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>、<code>0x80 ~ 0x9F</code>在此字符集中没有定义（控制字符是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C0%E4%B8%8EC1%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">ISO/IEC 6429</a>定义）。</p>
<h4 id="3-2-其他欧洲字符集"><a href="#3-2-其他欧洲字符集" class="headerlink" title="3.2 其他欧洲字符集"></a>3.2 其他欧洲字符集</h4><p>可是只有Latin-1还是不够，上面这个字符集只能用来表示<strong>西欧</strong>的字符，对于中欧、北欧，以及包括俄文在内的斯拉夫语族的字符都不包含在内，于是乎各个地区的国家，又陆续以同样的方式，使用ASCII编码中没有使用到的第一位进行拓展，产生了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-2">Latin-2</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-3">Latin-3</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-4">Latin-4</a>等等欧洲地区的其他Latin编码，这些编码后来统一定义在了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859">ISO/IEC 8859标准</a>里，并且分别命名为ISO/IEC 8859-1、ISO/IEC 8859-2等。</p>
<p>这些编码虽然很好地支持了不同的国家的语言，但是在不同国家之间的兼容性上，可以说是几乎没有。由于它们都是基于ASCII进行拓展，占用了ASCII未使用到的第一位，所以对于<code>0x7F</code>（十进制<code>0111 1111</code>）之后的字符，同样的二进制数，在不同国家地区代表了不同的字符。某个国家的文件在另一个国家打开，一般情况下看到的都是乱码。</p>
<h4 id="3-3-亚洲地区的编码"><a href="#3-3-亚洲地区的编码" class="headerlink" title="3.3 亚洲地区的编码"></a>3.3 亚洲地区的编码</h4><p>同时随着计算机在亚洲的流行，像中文、日文、韩文这种动则几千上万字符的语言，都基于ASCII增加或者自创了自己的编码，比如中文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GB_2312">GB2312</a>编码，日文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Shift_JIS">Shift_JIS</a>等。</p>
<p>由于越来越多的编码出现，电脑上一份文件要想展示正确的内容，<strong>需要电脑包含所有这些不同的字符集，并且采用正确的方式打开</strong>，否则看到的将会是乱码。这也就是乱码产生的本质，即使用了错误的编码方式/字符集来展示某个文件。</p>
<p>为了解决这个问题，Unicode编码出现了。</p>
<h2 id="三、Unicode：万国码"><a href="#三、Unicode：万国码" class="headerlink" title="三、Unicode：万国码"></a>三、Unicode：万国码</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode">Unicode，又叫做万国码</a>，其官方机构Unicode联盟整理、编码了世界上大部分的文字系统，使得电脑能以通用划一的字符集来处理和显示文字。目前最新的版本为2022年9月公布的15.0.0，已经收录超过14万个字符。</p>
<h3 id="1-码位"><a href="#1-码位" class="headerlink" title="1. 码位"></a>1. 码位</h3><p>Unicode编码从0开始，为每一个字符分配一个唯一的编号，这个编号就叫做<strong>码位（code point，也叫码点）</strong>，以“计算机”的“机”字举例，“机”的码位为<code>26426</code>（十进制），即Unicode字符集中第26426个字符，就是“机”。</p>
<p>但是在表示一个Unicode的字符时，通常会用<code>U+</code>然后紧接着一组十六进制的数字来表示这一个字符。也就是说，“机”在Unicode中的表示方式是<code>U+673A</code>，码位是<code>673A</code>。</p>
<p>Unicode为了和已有的编码方式相互兼容，其首256个字符保留给ISO/IEC 8859-1所定义的字符（Latin-1编码），使既有的西欧语系文字（包括英文）的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。</p>
<h3 id="2-平面"><a href="#2-平面" class="headerlink" title="2. 平面"></a>2. 平面</h3><p>对于不同国家数十万的字符，Unicode联盟显然不可能一下子就给出全部字符的码位定义，更何况现在的有些字符，在那个时候还没有出现。Unicode联盟把所有字符，分为了17组进行编排，每组称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">平面（Plane）</a>，而每平面拥有65536（即216）个代码位。</p>
<p>也就是说目前一共有17个平面，共计2^16 * 17（1114112）个码位，最多可以表示一百多万个字符。</p>
<table>
<thead>
<tr>
<th><strong>平面</strong></th>
<th><strong>始末字符值</strong></th>
<th><strong>名称</strong></th>
<th><strong>简称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">0号平面</a></td>
<td><code>U+0000 ~ U+FFFF</code></td>
<td><strong>基本多文种平面</strong></td>
<td><strong>BMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%80%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">1号平面</a></td>
<td><code>U+10000 ~ U+1FFFF</code></td>
<td><strong>多文种补充平面</strong></td>
<td><strong>SMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%BA%8C%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">2号平面</a></td>
<td><code>U+20000 ~ U+2FFFF</code></td>
<td><strong>表意文字补充平面</strong></td>
<td><strong>SIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">3号平面</a></td>
<td><code>U+30000 ~ U+3FFFF</code></td>
<td><strong>表意文字第三平面</strong></td>
<td><strong>TIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%9B%9B%E8%87%B3%E5%8D%81%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">4-13号平面</a></td>
<td><code>U+40000 ~ U+DFFFF</code></td>
<td>（尚未使用）</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">14号平面</a></td>
<td><code>U+E0000 ~ U+EFFFF</code></td>
<td><strong>特别用途补充平面</strong></td>
<td><strong>SSP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">15号平面</a></td>
<td><code>U+F0000 ~ U+FFFFF</code></td>
<td>保留作为<strong>私人使用区（A区）</strong></td>
<td><strong>PUA-A</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">16号平面</a></td>
<td><code>U+100000 ~ U+10FFFF</code></td>
<td>保留作为<strong>私人使用区（B区）</strong></td>
<td><strong>PUA-B</strong></td>
</tr>
</tbody></table>
<p>其中我们常用的一些字符，都定义在了第一个平面里，即<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">基本多文种平面（Basic Multilingual Plane, BMP）</a>，或称<strong>基本平面</strong>或<strong>0号平面（Plane 0）</strong>。比如大部分的汉字，都是定义在<code>U+4E00 ~ U+9FFF</code>代表的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>内（我们上面所说的“机”，<code>U+673A</code>，也在里面）。</p>
<p>而除了基本平台其他的十六个平面，都叫做辅助平面，用来放一些不常用的字符（如扑克牌花色），或者已经被废弃的古文字（如甲骨文）等。还有一些用作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%81%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%8C%BA">私人使用区</a>，主要是指没有在Unicode标准中指定，而是由合作用户之间的私人协议决定其用途的编码区。</p>
<p>现在看起来只需要使用Unicode编码，就可以囊括所有的语言符号，再也不会有乱码的问题了，真美好。</p>
<h3 id="3-好像还有些事情要做"><a href="#3-好像还有些事情要做" class="headerlink" title="3. 好像还有些事情要做"></a>3. 好像还有些事情要做</h3><p>可是事情真的像预期的那边美好吗？</p>
<p>Unicode定义了字符的编码方式，但是没有定义这些编码的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a>。就是说Unicode编码虽然给每一个字符一个唯一的编码，解决了字符集不统一的情况，但是没有定义在计算机底层，要怎么存储或者传输每一个Unicode字符。</p>
<p>例如ASCII定义了用一个字节（8位二进制）来存储每个字符，GB2312是用两个字节来存储每个汉字，Unicode的每一个字符应该用多大的空间来存储呢？这就涉及到Unicode编码的实现方式了，或者称为Unicode转换格式。</p>
<h2 id="四、UTF"><a href="#四、UTF" class="headerlink" title="四、UTF"></a>四、UTF</h2><p>Unicode编码的实现方式称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><strong>Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong></a>。由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式也有所不同，下面我们说几个经常听到的转换格式。</p>
<h3 id="0-码元"><a href="#0-码元" class="headerlink" title="0. 码元"></a>0. 码元</h3><p>在开始之前，先引入一个概念，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81#%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E4%BB%A3%E7%A0%81%E9%A1%B5%EF%BC%8C%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%98%A0%E5%B0%84">码元（Code Unit）</a>，是指一种编码转换格式中具有最短的二进制组合的单元，即字符占用的最少二进制位。比如上面说的ASCII编码，每个字符都是占用8位二进制，所以ASCII编码的码元是8。</p>
<h3 id="1-UTF-32"><a href="#1-UTF-32" class="headerlink" title="1. UTF-32"></a>1. UTF-32</h3><p>首先，最简单的就是，用一个能包含所有Unicode编码的空间，来存储每一个字符。Unicode目前一共有17个平面，共计216 * 17个码位。</p>
<p><strong><code>2^16 * 17 = 2^20 + 2^16</code></strong></p>
<p><strong><code>2^20 &lt; 2^20 + 2^16 &lt; 2^21</code></strong></p>
<p>只需要使用大于21位的二进制来存储就可以了，例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-32">UTF-32</a>编码，这个编码用32位（4个字节）的二进制来存储Unicode编码的字符，不算固定为<code>0</code>的首位数字，总计能表示 231个字符，够用了。</p>
<p>由于UTF-32可以表示的字符比Unicode所有字符还多，可以做到UTF-32的编码与字符的Unicode码位的数值完全一致。由于UTF-32种每个字符都是用用32位（4个字节）来表示，所以<strong>UTF-32的码元就是32</strong>。</p>
<p>还是以上面的“机”为例，它的码位是<code>U+673A</code>（即十六进制<code>0x673A</code>），那么它在UTF-32中的编码值为<code>0x0000673A</code>（因为总共有32位，4个字节，所以要在前面补上两个字节的0，凑够4字节）</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-32编码：</strong></td>
<td><code>0x0000 673A</code></td>
</tr>
<tr>
<td><strong>UTF-32编码的二进制形式：</strong></td>
<td><code>00000000 00000000 01100111 00111010</code></td>
</tr>
</tbody></table>
<p>看起来UTF-32挺好的，可以通过Unicode码位直接知道对应的UTF-32编码，查找编码是一个常数时间的操作。但是它有个巨大的缺陷，就是占用空间太大。</p>
<p>在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，一般只需要1-2个字节就可以表示，比如上面的“机”（<code>01100111 00111010</code>），只需要两个字节就可以表示，但是UTF-32中却占了4个字节。</p>
<p>对于纯英文的文本来说，这种情况更甚，比如字母<code>a</code>的码位为<code>0110 0001</code>，只需要一个字节，但是在UTF-32同样要用4个字节来表示，<code>00000000 00000000 00000000 01100001</code>。</p>
<p>这也就造成UTF-32所需空间接近UTF-16的两倍和UTF-8的四倍，空间浪费较多。所以UTF-32编码，目前基本没有人使用，甚至<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/#character-encodings">在HTML5标准中明确规定在HTML中禁止使用UTF-32编码</a>。</p>
<h3 id="2-UTF-16"><a href="#2-UTF-16" class="headerlink" title="2. UTF-16"></a>2. UTF-16</h3><h4 id="2-1-变长编码"><a href="#2-1-变长编码" class="headerlink" title="2.1 变长编码"></a>2.1 变长编码</h4><p>既然在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，那么有没有一种更节省空间的实现方式？有，那就是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>。（当然这个是从现在这个时间点来看的，UTF-16设计出来的目的并不是为了解决UTF-32的问题，还涉及到一个UCS-2的编码实现方式，下面会讲到）</p>
<p>UTF-16是一个<strong>变长的编码转换格式</strong>，也就是说相比UTF-32这种固定长度（4字节）的来说，它的编码长度取决于字符在Unicode中的码位，可能是2个字节，有可能是4个字节。</p>
<p>根据上面的Unicode平面对应的码位，可以看到基本平面内的字符<code>U+0000 ~ U+FFFF</code>，长度最长只有2个字节。所以对于基本平面的字符，在UTF-16中用2个字节来表示。对于其他辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，则用4个字节来表示。由于UTF-16中字符最少要占用2个字节（16位），所以UTF-16的码元是16，即UTF-16中字符要么用1个码元来表示，要么用2个码元来表示。</p>
<p>以上面“计算机”中的“机”为例，“机”的码位是<code>U+673A</code>，位于基本平面内，用两个字节表示，这个时候它的UTF-16编码和它在Unicode中的码位是一样的，即<code>0x673A</code>，换成二进制就是<code>01100111 00111010</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码的二进制形式：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>这样在绝大多数情况下，用2个字节就可以存储或者表示字符，极少数情况下用到的辅助平面字符，才会用到4个字节的表示方式。</p>
<p>但是这样也会带来一个问题，计算机在读取字符的二进制时，比如读取了2个字节，要怎么知道这2个字节表示的是一个字符，还是说要再加上后面2个字节连起来组成一个字符呢？</p>
<h4 id="2-2-前导代理和后尾代理"><a href="#2-2-前导代理和后尾代理" class="headerlink" title="2.2 前导代理和后尾代理"></a>2.2 前导代理和后尾代理</h4><p>我们知道，需要用4个字节来表示的字符，都是位于16个辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，16辅助平面内的字符总用有220个：</p>
<p><strong><code>2^16 * 16 = 2^20</code></strong></p>
<p>这些辅助平面内的字符，相对于辅助平面内的第一个字符<code>U+10000</code>，偏移量分别是 0 ~ 2^20 - 1</p>
<p><strong><code>0x10000 - 0x10000 = 0</code></strong></p>
<p><strong><code>0x10FFFF - 0x10000 = 2^20 - 1</code></strong></p>
<p>只需要记录下每个辅助平面内字符<strong>相对于第一个辅助平面字符的偏移量</strong>，就可以知道每个字符在Unicode中的码位。</p>
<p>而220个数字只需要用20位长度的二进制就可以表示，20位长度的二进制拆分到4个字节里，每2个字节存储10位长度的二进制。</p>
<p>以<code>𐐷</code>这个字符为例，这个字符的码位是<code>U+10437</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code></td>
</tr>
</tbody></table>
<p>也就是说<code>𐐷</code>这个字符占4个字节，前2个字节是<code>00000000 00000001</code>，后2个字节是<code>00000000 00110111</code>。</p>
<p>但是到这里依然没有解决上面的问题，计算机在读取到前2个字节<code>00000000 00000001</code>时，不知道这表示的是<code>SOH</code>这个控制字符，还是说要和后面2个字节连起来，共同组成一个字符<code>𐐷</code>。因此，需要在<strong>基本平面</strong>中保留不对应任何Unicode字符的两个区域，用于标识UTF-16的4字节字符的前10位和后10位。这两个区域就是</p>
<table>
<thead>
<tr>
<th><code>0xD800 ~ 0xDBFF</code></th>
<th>容纳前10位的区域，区域大小为 210</th>
</tr>
</thead>
<tbody><tr>
<td><code>0xDC00 ~ 0xDFFF</code></td>
<td>容纳后10位的区域，区域大小为 210</td>
</tr>
</tbody></table>
<p>而只需要把上面的前10位<code>00000000 00000001</code>和后10位<code>00000000 00110111</code>，分别加上这两个区域的起始值，就是这个字符在UTF-16中真正的表示：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code>, <code>0x0001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code>, <code>0x0037</code></td>
</tr>
<tr>
<td>**前10位 + **<code>0xD800</code><strong>：</strong></td>
<td><code>0xD800</code> + <code>0x0001</code> = <code>0xD801</code>, <code>11011000 00000001</code></td>
</tr>
<tr>
<td>**后10位 + **<code>0xDC00</code><strong>：</strong></td>
<td><code>0xDC00</code> + <code>0x0037</code> = <code>0xDC37</code>, <code>11011100 00110111</code></td>
</tr>
<tr>
<td><strong>UTF-16 中真正的表示：</strong></td>
<td><code>0xD801``0xDC37</code>，<code>11011000 00000001``11011100 00110111</code></td>
</tr>
</tbody></table>
<p>所以<code>𐐷</code>这个字符，在UTF-16中的真正表示为<code>0xD801</code> <code>0xDC37</code>，以二进制形式就是<code>11011000 00000001</code> <code>11011100 00110111</code>，前后各2个字节分别叫做这个字符的<strong>前导代理</strong>（lead surrogates）和<strong>后尾代理</strong>（trail surrogates），这个字符就是由这样一个<strong>代理对</strong>（Surrogate Pair）来表示。</p>
<h4 id="2-3-计算机读取"><a href="#2-3-计算机读取" class="headerlink" title="2.3 计算机读取"></a>2.3 计算机读取</h4><p>计算机在读取时，每读取2个字节，如果这两个字节范围处于<code>0xD800 ~ 0xDBFF</code>这个区域，那么就知道这2个字节，要和后面的2个字节连起来，共同组成一个字符。</p>
<p>以上面为例，在读取到<code>11011000 00000001</code>时，发现这个数字位于<code>0xD800 ~ 0xDBFF</code>，那么就知道<code>11011000 00000001</code>表示这个字符的前导代理而不是一个真正字符，需要再读取后2个字节里的后尾代理，具体步骤为：</p>
<ol>
<li>读取：<code>11011000 00000001</code> <code>11011100 00110111</code>，即<code>0xD801</code> <code>0xDC37</code></li>
<li>分别减去<code>0xD800</code>和<code>0xDC00</code>：<code>0x0001</code> <code>0x0037</code>，即<code>0000000001</code> <code>0000110111</code></li>
<li>组合起来就是<code>0000 0000 0100 0011 0111</code>，即<code>0x00437</code></li>
<li>也就是说字符相对于<code>0x10000</code>的偏移量是<code>0x00437</code>，或者换种说法，这个字符是辅助平面字符里的第<code>0x00437</code>个辅助平面字符</li>
<li>所以真正的码位是<code>0x10000 + 0x00437 = 0x10437</code>，即<code>U+10437</code>，所表示字符为<code>𐐷</code></li>
</ol>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>到这里UTF-16基本是说完了，看起来很复杂，但总结下来就三点：</p>
<ol>
<li>对于基本平面内的字符，用2个字节表示；对于其他辅助平面内的字符，用4个字节表示</li>
<li>对于辅助平面内的字符，拆成两半<ol>
<li>一半映射在<code>0xD800 ~ 0xDBFF</code>内</li>
<li>一半映射在<code>0xDC00 ~ 0xDFFF</code>内</li>
</ol>
</li>
<li>读取2个字节，如果发现这2个字节的码位处于<code>0xD800 ~ 0xDBFF</code>，那么就当做4字节字符处理，再读取后面的2个字节共同组成字符。否则就直接作为2字节字符</li>
</ol>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>既然UTF-16可以通过对字符做区分，不同字符使用不同长度的字节来表示，那应该有更加节省空间的变长编码转换格式才对。而<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</a>就是这样一个变长的编码转换格式。</p>
<h4 id="3-1-编码规则"><a href="#3-1-编码规则" class="headerlink" title="3.1 编码规则"></a>3.1 编码规则</h4><p>UTF-8从名字就可以知道，这是一种最小长度为8位二进制（即1个字节）的编码转换格式。使用 1 ~ 4 个字节来表示字符（1、2、3、4个字节都有可能），具体的规则如下：</p>
<table>
<thead>
<tr>
<th><strong>码位范围</strong></th>
<th><strong>字节数</strong></th>
<th><strong>Byte 1</strong></th>
<th><strong>Byte 2</strong></th>
<th><strong>Byte 3</strong></th>
<th><strong>Byte 4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000 ~ U+007F</code></td>
<td>1</td>
<td><code>0xxxxxxx</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0080 ~ U+07FF</code></td>
<td>2</td>
<td><code>110xxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0800 ~ U+FFFF</code></td>
<td>3</td>
<td><code>1110xxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
</tr>
<tr>
<td><code>U+10000 ~ U+10 FFFF</code></td>
<td>4</td>
<td><code>11110xxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
</tr>
</tbody></table>
<p>对于一个字符，首先确定其在Unicode中的码位，根据上面表格第一列，确定这个码位所属的范围所需要用到的字节。</p>
<ol>
<li>如果是单字节字符，那么这个字节首位为<code>0</code>，用剩下的7位来表示这个字符。可以看到，对于ASCII中的字符，在ASCII和UTF-8中的编码规则是一致的，也就是说UTF-8兼容ASCII编码</li>
<li>如果是多字节字符，假设是<code>n</code>字节字符，就在第一个字节开头用<code>n</code>个<code>1</code>来填充，第<code>n + 1</code>位用<code>0</code>填充，且后面的字节的前两个字符，都用<code>10</code>来填充。剩下的没有被填充的位，就是用来填充这个字符Unicode码位的二进制，从右向左填充，未填充满的用<code>0</code>补齐</li>
</ol>
<p>由于UTF-8中字符最少占据1个字节（8位），所以<strong>UTF-8的码元是8</strong>，即UTF-8中字符用 1 ~ 4 个码元来表示。<br>还是以上面的“计算机”的“机”为例：</p>
<ol>
<li>“机”的码位为<code>U+673A</code></li>
<li>根据上面的表格，处于<code>U+0800 ~ U+FFFF</code>这个范围内，所以要用3个字节来表示</li>
<li>也就是说格式为<code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>，<code>x</code>为这个字符码位二进制填充位</li>
<li><code>U+673A</code>的二进制为<code>110011100111010</code>，从右向左依次填充，得到：</li>
</ol>
<p><code>11100110</code> <code>10011100</code> <code>10111010</code><br>即字符“机”在UTF-8中的编码为<code>11100110 10011100 10111010</code>，用16进制表示为<code>0xE69CBA</code>。</p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码：</strong></td>
<td><code>0xE69CBA</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码的二进制形式：</strong></td>
<td><code>11100110 10011100 10111010</code></td>
</tr>
</tbody></table>
<h4 id="3-2-真的最节省空间吗？"><a href="#3-2-真的最节省空间吗？" class="headerlink" title="3.2 真的最节省空间吗？"></a>3.2 真的最节省空间吗？</h4><p>UTF-8最小字节单位为 1 个字节，相比起UTF-16和UTF-32最小字节单位是 2 字节和 4 字节来说，确实是可以节省下不少空间。但是这个节省空间是相对的。</p>
<p>对于以拉丁字母作为主要语言的英语、西欧语言等来说，绝大多数情况下只需要 1 个字节或者 2 个字节就可以表示字符。对于这些语言来说，最节省空间的确实是UTF-8。但是对于很多亚洲国家来说，比如中日韩，却不是这样。</p>
<p>从上面的内容可以知道，对于中日韩这些文字来说，在UTF-16中，绝大多数文字都只需要 2 个字节就可以表示，但是在UTF-8中，却需要 3 个字节来表示，占用空间比UTF-16多出了 50%，这样看来，对于中日韩文字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">CJK</a>文字来说，最节省空间的反而是UTF-16编码了。</p>
<p>也就是说，哪种编码转换格式最节省空间是由字符内容决定的，UTF-8只有在英语等拉丁语言的情况下才是最节省空间的，但是对于亚洲地区来说，最合适的编码方式是UTF-16。</p>
<h3 id="4-Big-Endian-和-Little-Endian"><a href="#4-Big-Endian-和-Little-Endian" class="headerlink" title="4. Big Endian 和 Little Endian"></a>4. Big Endian 和 Little Endian</h3><p>其实除了上面说的内容，对于多字节的编码转换格式来说，还有一个 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%A4%A7%E7%AB%AF%E5%BA%8F">Big Endian（大端序，简称BE）</a>和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%B0%8F%E7%AB%AF%E5%BA%8F">Little Endian（小端序，简称LE）</a>的概念。因为这些多字节的编码中字符占用多个字节，在将字符二进制拆分成多个字节后，多个字节可能会有排列顺序的区分。</p>
<p>比如上面的“机”，UTF-16编码中会把码位二进制<code>01100111 00111010</code>放到两个字节里：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>那么在UTF-16 BE和UTF-16 LE中，编码分别为<code>01100111 00111010</code>和<code>00111010 01100111</code>，两个字节的顺序正好相反。</p>
<table>
<thead>
<tr>
<th><strong>UTF-16 BE 编码</strong></th>
<th><code>01100111 00111010</code></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><strong>UTF-16 LE 编码</strong></th>
<th><code>00111010 01100111</code></th>
</tr>
</thead>
</table>
<p>我们上面举例的一些字符，都是以BE的形式来表示的。这个其实没有一个优劣，更多是一种人们情绪化的选择，就好像鸡蛋应该从大的那头拨开还是小的那头拨开一样。感兴趣的可以看看这个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E7%AB%AF%EF%BC%88endian%EF%BC%89%E7%9A%84%E8%B5%B7%E6%BA%90">大小端问题的起源</a>。</p>
<h2 id="五、JavaScript中使用的编码"><a href="#五、JavaScript中使用的编码" class="headerlink" title="五、JavaScript中使用的编码"></a>五、JavaScript中使用的编码</h2><p>说了这么多，在JavaScript中使用的是哪种编码呢？</p>
<h3 id="1-编码格式"><a href="#1-编码格式" class="headerlink" title="1. 编码格式"></a>1. 编码格式</h3><p>其实JavaScript使用的是一个叫做UCS-2的编码，并不是上面的任何一种。UCS-2是一种<strong>定长</strong>的编码转换格式，用2个字节来表示字符，可以理解为是只能用来表示基本平面内字符的UTF-16，不能表示辅助平面内的字符。或者说<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16#UTF-16%E8%88%87UCS-2%E7%9A%84%E9%97%9C%E4%BF%82">UTF-16是基于UCS-2的超集</a>。</p>
<p>同样的，Java和 Objective-C都是使用的是UCS-2。这些语言之所以选择这个编码转换格式，是因为在Unicode早期，大家都以为用2个字节就足够表示所有字符了，所以UCS-2使用了2字节定长编码，且字符编码和字符的Unicode码位的一样的，获取字符的开销是一个常数操作，对于需要处理字符串的编程语言来说是最合适的选择。</p>
<p>但是到后期随着Unicode的扩充，2字节定长编码的UCS-2无法满足需求，也就诞生了基于UCS-2的UTF-16编码，在基本平面内兼容UCS-2，同时通过可变的长度来支持辅助平面内字符。这些编程语言也基本过渡到了UTF-16上。</p>
<p>但是一些稍微新一些的编程语言，比如Python3，Go等，默认的编码转换格式都已经是UTF-8了。</p>
<h3 id="2-获取字符串长度"><a href="#2-获取字符串长度" class="headerlink" title="2. 获取字符串长度"></a>2. 获取字符串长度</h3><p>既然知道了JavaScript中的编码转换格式，那我们来试下获取字符长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.length;   <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.length;  <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.length;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，同样是一个字符，“a”和“机”的长度都是“1”，但是一个笑哭的emoji“😂”，长度却是2。这是为什么呢？<br><em><strong>因为获取字符串长度，本质上就是获取字符串在当前编码格式中占用的码元（Code Unit）数量。</strong></em><br>在UTF-16（UCS-2）中，码元为16（2个字节）：</p>
<ul>
<li>“a”和“机”都是<strong>基本平面</strong>内的字符，都可以用 2 个字节，即 1 个UTF-16码元来表示，所以长度是1</li>
<li>“😂”这个emoji的Unicode码位是<code>U+1F602</code>，已经超出了基本平面<code>U+0000 ~ U+FFFF</code>，是<strong>辅助平面</strong>内的字符，要用 4 个字节，即 2 个UTF-16码元来表示，所以长度是2</li>
</ul>
<p>Java和OC中执行结果也和上面一样。相应的，如果这些字符串放在默认编码方式为UTF-8的语言中，如Go，得到的长度就会是下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="string">&quot;a&quot;</span>)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;机&quot;</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;😂&quot;</span>)   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>这是因为在UTF-8中，码元为8（1个字节）：</p>
<ul>
<li>“a”，<code>U+0061</code>，是用 1 个字节表示，1个码元，所以长度是1</li>
<li>“机”，<code>U+673A</code>，用 3 个字节表示，即 3 个UTF-8码元，所以长度是3</li>
<li>“😂”，<code>U+1F602</code>，用 4 个字节表示，即 4 个UTF-8码元，所以长度是4</li>
</ul>
<p>所以，在一些前后端默认字符编码编码格式不一样的场景，比如前端（JS/Java/OC），后端Go，就可能会出现一些字符串长度判断不一致的情况（看到一篇<a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">文章</a>里就有遇到这种情况）。</p>
<h3 id="3-获取字符串中真正的字符个数"><a href="#3-获取字符串中真正的字符个数" class="headerlink" title="3. 获取字符串中真正的字符个数"></a>3. 获取字符串中真正的字符个数</h3><p>说了这么多，有没有办法在JS中获取到真正的字符个数呢，比如“😂”。有的，通过<code>Array.from(str)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;😂&#x27;</span>).length;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>再来看一个特殊情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>.length;                <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>).length;    <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>);           <span class="comment">// [&#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可以看到“👩‍👩‍👧‍👧”这个emoji，其实是由4个emoji组合到一起的，并且中间用了<code>U+200D</code>这个名字叫做“零宽度连字符”的字符来连接，这个字符的长度是1，所以这个emoji本质上是7个字符组合到一起的，<strong>总计7个字符</strong>，长度为：</p>
<p><strong><code>2 + 1 + 2 + 1 + 2 + 1 + 2 = 11</code></strong></p>
<p>我们也可以反向来试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是空字符串</span></span><br><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;\u&#123;200D&#125;&#x27;</span>);        <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是 U+200D</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其他一些和字符编码有关的方法和逻辑"><a href="#4-其他一些和字符编码有关的方法和逻辑" class="headerlink" title="4. 其他一些和字符编码有关的方法和逻辑"></a>4. 其他一些和字符编码有关的方法和逻辑</h3><h4 id="4-1-获取码位"><a href="#4-1-获取码位" class="headerlink" title="4.1 获取码位"></a>4.1 获取码位</h4><p>在JS中，想要获取一个字符的Unicode码位很简单，只需要通过<code>String.prototype.codePointAt()</code>即可获取码位的<strong>十进制值</strong>。<code>codePointAt</code>接受一个参数，可以用来获取指定码元处码位，不传则默认为<code>0</code>，即这个字符第一个码元处的码位的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.codePointAt();    <span class="comment">// 97 (十进制)</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.codePointAt();   <span class="comment">// 26426</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt();   <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">0</span>);  <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">1</span>);  <span class="comment">// 56834</span></span><br></pre></td></tr></table></figure>

<p>如果指定的这个码元位置的码位是UTF-16<strong>代理对的前导代理</strong>，那么就会返回这个字符完整的Unicode码位，否则就直接返回这个位置的码位，详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt">MDN</a>。</p>
<p>如上面<code>&#39;😂&#39;.codePointAt(0)</code>，因为“😂”这个字符在UTF-16中是用2个码元（4个字节）来表示的，根据规则组成这个字符的 2个码元是一个<strong>代理对</strong>，它的第一个码元是前导代理，所以直接返回了“😂”这个字符的完整Unicode码位<code>128514</code>，即<code>U+1F602</code>。</p>
<p>但是<code>&#39;😂&#39;.codePointAt(1)</code>，因为索引为1的码元，是一个后尾代理，所以直接返回了这个后尾代理的码位<code>56834</code>，即<code>U+DE02</code>。而“😂”的在UTF-16中的完整编码格式为<code>U+D83D</code> <code>U+DE02</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>😂</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+1F602</code></td>
</tr>
<tr>
<td><strong>前导代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>后尾代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>UTF-16 BE 中的表示：</strong></td>
<td><code>U+D83D</code> <code>U+DE02</code></td>
</tr>
</tbody></table>
<h4 id="4-2-用码位表示字符"><a href="#4-2-用码位表示字符" class="headerlink" title="4.2 用码位表示字符"></a>4.2 用码位表示字符</h4><p>JS中是允许用码位来表示字符的，表示方式是<code>\u&#123;xxxx&#125;</code>，即反斜杠 + u + 花括号，花括号内为16进制的码位。又由于JS使用的是UTF-16，所以在JS中可以用下面的方式来表示“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span>;                 <span class="comment">// true Unicode码位表示</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;          <span class="comment">// true UTF-16编码格式表示</span></span><br><span class="line"><span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-直接查看文件中字符的二进制"><a href="#4-3-直接查看文件中字符的二进制" class="headerlink" title="4.3 直接查看文件中字符的二进制"></a>4.3 直接查看文件中字符的二进制</h4><p>说了这么多，都是在讲解，那有什么办法直接查看某个字符或者字符串的二进制编码呢？最简单的我们可以通过一些文本编辑器来看，比如sublime。还是以“机”和“𐐷”为例。</p>
<p>在sublime中输入一个字符，然后以某种编码格式保存，我们这里分别用UTF-8，UTF-16 BE，UTF-16 LE来保存：</p>
<p><img src="https://static.youfindme.cn/blog/character_encoding/save_by_sublime.png" alt="save_by_sublime.png"></p>
<p>然后打开终端，通过<code>xbb -b</code>命令分别查看三个文件的二进制内容：</p>
<p><img src="https://static.youfindme.cn/blog/character_encoding/show_binary.png" alt="show_binary.png"></p>
<p>可以看到二进制内容，和上面讲到的是完全一致的。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>到这里基本上已经说完了，字符编码从二进制，到ASCII问世，到Latin-1、2、3…，再到GB2312、Shift_JIS的“战国时代”，直到最后Unicode万国码“一统天下”。而随Unicode诞生的，还有UTF-32、UTF-16、UTF-8、UCS-2等。</p>
<p>可以看到一个小的字符编码引起的Bug，后面可以挖出这么多，有时候日常开发中不那么起眼的一些点，后面也有很多有趣的内容。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>感谢下面这些参考链接的作者，看这些文章收获很多！</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">Wikipedia 字符编码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_37967865/article/details/103311765">计算机编码发展历史和编码方式_计算机最早的编码方式_cacho_37967865的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">‘👩‍👩‍👧‍👧’.length === 11 ? Emoji 有多长</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/16205678.html">前端开发中需要搞懂的字符编码知识 - jimojianghu - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.xxkid.com/post/e5b12a4a.html">JS 判断带 emoji 的字符串长度的究极方法 - 小小孩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/p/27990849">程序的逻辑 (6) 编码的本质与乱码的恢复</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346662618">《JavaScript 权威指南》解读——字符串是 16 位值的序列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34281537/article/details/92508414">Javascript中的string类型使用UTF-16编码_weixin_34281537的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/308677093">Java 为什么使用 UTF-16 而不是更节省内存的 UTF-8？ - 知乎</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/" class="post-title-link" itemprop="url">聊聊深色模式（Dark Mode）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 10:29:00" itemprop="dateCreated datePublished" datetime="2023-03-13T10:29:00+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-02 20:26:33" itemprop="dateModified" datetime="2024-01-02T20:26:33+08:00">2024-01-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是深色模式"><a href="#什么是深色模式" class="headerlink" title="什么是深色模式"></a>什么是深色模式</h2><p>深色模式（Dark Mode），或者叫暗色模式，黑夜模式，是和日常使用的浅色（亮色）模式（Light Mode）相对应的一种UI主题。</p>
<p>深色模式最早来源于人机交互领域的研究和实践，从2018年左右开始，Apple推出了<strong>iOS 13</strong>，其中包含了系统级别的深色模式，可以将整个系统的界面切换为暗色调。</p>
<p>Google也在<strong>Android 10</strong>中推出了类似的深色模式功能，使深色模式得到了更广泛的应用和推广。</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/dark_mode_example.png" alt="iOS官网的深色模式示例"></p>
<p>它不是简单的把背景变为黑色，文字变为白色，而是一整套的配色主题，这种模式相比浅色模式更加柔和，可以减少亮度对用户眼睛造成的刺激和疲劳。</p>
<p>随着越来越多的应用开始支持深色模式，作为开发也理应多了解下深色模式。</p>
<h2 id="首先，怎么打开深色模式"><a href="#首先，怎么打开深色模式" class="headerlink" title="首先，怎么打开深色模式"></a>首先，怎么打开深色模式</h2><p>在说怎么实现之前，先来说说我们要怎么打开深色模式，一般来说只需要在系统调节亮度的地方就可以调节深色模式，具体我们可以看各个系统的官方网站即可：<br>如何打开深色模式</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT210332">在 iPhone 和 iPad 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT208976">在 Mac 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.google.com/android/answer/9730472?hl=zh-Hans">在 Android 设备上更改为深色模式或颜色模式 - Android帮助</a></li>
<li><a target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9B%B4%E6%94%B9%E9%A2%9C%E8%89%B2-d26ef4d6-819a-581c-1581-493cfcc005fe">在 Windows 中更改颜色 - Microsoft 支持</a></li>
</ul>
<p>但是在开发调试调试时，不断切换深色模式可能比较麻烦，这时浏览器就提供了一种模拟系统深色模式的方法，可以让当前的Web页面临时变为深色模式，以Chrome为例：<br>浏览器模拟深色/浅色模式</p>
<ol>
<li>打开Chrome DevTools</li>
<li><code>Command</code>+<code>Shift</code>+<code>P</code></li>
<li>输入dark或者light</li>
<li>打开深色或者浅色模式<img src="https://static.youfindme.cn/blog/dark_mode/open_dark_mode_in_devtool.png" alt="打开深色模式"><br><img src="https://static.youfindme.cn/blog/dark_mode/open_light_mode_in_devtool.png" alt="打开浅色模式"></li>
</ol>
<p>不过要注意的是，浏览器DevTools里开启深色模式，在关闭开发者工具后就会失效。</p>
<h2 id="自动适配-声明页面支持深色模式"><a href="#自动适配-声明页面支持深色模式" class="headerlink" title="自动适配 - 声明页面支持深色模式"></a>自动适配 - 声明页面支持深色模式</h2><p>其实，在支持深色模式的浏览器中，有一套默认的深色模式，只需要我们在应用中声明，即可自动适配深色模式，声明有两种方式：</p>
<h3 id="1-添加color-scheme的meta标签"><a href="#1-添加color-scheme的meta标签" class="headerlink" title="1. 添加color-scheme的meta标签"></a>1. 添加<code>color-scheme</code>的<code>meta</code>标签</h3><p>在HTML的<code>head</code>标签中增加<code>color-scheme</code>的<code>meta</code>标签，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">	and the page author prefers light.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;color-scheme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;light dark&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上述声明，告诉浏览器这个页面支持深色模式和浅色模式，并且页面更倾向于浅色模式。在声明了这个之后，当系统切换到深色模式时，浏览器将会把我们的页面自动切换到默认的深色模式配色，如下所示：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<h3 id="2-在CSS里添加color-scheme属性"><a href="#2-在CSS里添加color-scheme属性" class="headerlink" title="2. 在CSS里添加color-scheme属性"></a>2. 在CSS里添加<code>color-scheme</code>属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">  and the page author prefers light.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面在<code>:root</code>元素上添加<code>color-scheme</code>属性，值为<code>light dark</code>，可以实现和<code>meta</code>标签一样的效果，同时这个属性不只可用于<code>:root</code>级别，也可用于单个元素级别，比<code>meta</code>标签更灵活。</p>
<p>但是提供<code>color-scheme</code>CSS属性需要首先下载CSS（如果通过<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>引用）并进行解析，使用<code>meta</code>可以更快地使用所需配色方案呈现页面背景。两者各有优劣吧。</p>
<h2 id="自定义适配"><a href="#自定义适配" class="headerlink" title="自定义适配"></a>自定义适配</h2><h3 id="1-自动适配的问题"><a href="#1-自动适配的问题" class="headerlink" title="1. 自动适配的问题"></a>1. 自动适配的问题</h3><p>在上面说了我们可以通过一些标签或者CSS属性声明，来自动适配深色模式，但是从自动适配的结果来看，适配的并不理想：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<ul>
<li><p>首先是默认的黑色字体，到深色模式下变成了纯白色<code>#FFFFFF</code>，和黑色背景（虽然说不是纯黑）对比起来很扎眼，在一些设计相关的文章[<a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">1</a>][<a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">2</a>]里提到，深色模式下避免使用纯黑和纯白，否则更容易使人眼睛👁疲劳，同时容易在页面滚动时出现拖影：</p>
<p>  <img src="https://static.youfindme.cn/blog/dark_mode/smearing_when_scrolling.png" alt="滚动时出现拖影，图片来源「即刻」"></p>
</li>
<li><p>自动适配只能适配没有指定颜色和背景色的内容，比如上面的1、2、3级文字还有背景，没有显式设置<code>color</code>和<code>background-color</code>。</p>
<p>  对于设置了颜色和背景色（这种现象在开发中很常见吧）的内容，就无法自动适配，比如上面的7个色块的背景色，写死了颜色，但是色块上的文字没有设置颜色。最终在深色渲染下渲染出的效果就是，色块背景色没变，但是色块上的文字变成了白色，导致一些文字很难看清。</p>
</li>
</ul>
<p>所以，最好还是自定义适配逻辑，除了解决上面的问题，还可以加一下其他的东西，比如加一些深浅色模式变化时的过渡动画等。</p>
<h3 id="2-如何自定义适配"><a href="#2-如何自定义适配" class="headerlink" title="2. 如何自定义适配"></a>2. 如何自定义适配</h3><p>自定义适配有两种方式，CSS媒体查询和通过JS监听主题模式</p>
<h4 id="1-CSS媒体查询"><a href="#1-CSS媒体查询" class="headerlink" title="1). CSS媒体查询"></a>1). CSS媒体查询</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">prefers-color-scheme - CSS：层叠样式表 | MDN</a><br>我们可以通过在CSS中设置媒体查询<code>@media (prefers-color-scheme: dark)</code>，来设置深色模式下的自定义颜色。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#404040</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#bfbfbf</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">  <span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过媒体查询设置元素在深色模式下的1、2、3级文字的颜色，在浅色模式下设置不同的颜色，在深色模式下，增加不透明度：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_auto_right_manul.png" alt="左边的是自动适配的浅色深色，右边是自定义适配的浅色深色"></p>
<p>对于<code>prefers-color-scheme</code>的兼容性也不必担心，主流浏览器基本都支持了：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/prefers_color_scheme.png" alt="prefers-color-scheme"></p>
<h4 id="2-JS监听主题颜色"><a href="#2-JS监听主题颜色" class="headerlink" title="2). JS监听主题颜色"></a>2). JS监听主题颜色</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia">Window.matchMedia() - Web API 接口参考 | MDN</a></p>
<p>通过CSS媒体查询适配深色模式已经很方便了，完全不需要修改JS代码逻辑，那为什么还需要JS监听主题颜色呢？</p>
<p>因为通过CSS媒体查询虽然方便，但是只能跟随系统的主题颜色变化，假设用户想要类似于下面的自定义主题颜色，不跟随系统变化，或者业务上想做一些什么高级的操作，那么CSS媒体查询就无能为力了。</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/custom_mode.gif" alt="custom_theme.gif"></p>
<p>在JS中，可以通过<code>window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).match</code>来判断当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> darkModeMediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (darkModeMediaQuery.matches) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.matches) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果使用的是React，还可以写一个自定义hooks，来监听当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EColorScheme &#123;</span><br><span class="line">  LIGHT = <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">  DARK = <span class="string">&#x27;dark&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h4><p>我写完这个hooks之后，有一次偶然用Chat GPT让它写一段监听深色模式的代码，写成hooks，最后生成的代码和这个几乎一模一样，Chat GPT还是有点东西的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ThemeType = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTheme</span>(<span class="params"></span>): <span class="title">ThemeType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState&lt;ThemeType&gt;(</span><br><span class="line">    <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleChange = <span class="function">() =&gt;</span> setTheme(mediaQuery.matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    mediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> mediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useTheme;</span><br></pre></td></tr></table></figure>

<p><code>window.matchMedia</code>的兼容性也挺好的：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/window_match_media.png" alt="window.matchMedia"></p>
<p>通过JS监听颜色主题变化之后，那可玩性就很多了，我们可以通过下面这些方式来适配深色模式：</p>
<ul>
<li><p>动态添加类名覆盖样式</p>
<p>  通过判断深色模式来添加一个深色模式的类名，覆盖浅色模式样式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=&#123;classnames(</span><br><span class="line">    style.wrapper,</span><br><span class="line">    scheme === EColorScheme.DARK &amp;&amp; style.darkModeWrapper</span><br><span class="line">  )&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &#123;/* some code here */&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>对于深色模式直接引用不同的CSS资源文件</p>
</li>
<li><p>用一些第三方的库，比如<code>postcss-darkmode</code>等</p>
</li>
</ul>
<p>回到上面话题，通过JS可以监听到系统的颜色主题，那怎么实现用户主动选择颜色主题，不随系统的改变呢？其实也很简单，可以在本地store中设置一个颜色主题的值，用户设置了就优先选用store里的，没有设置就跟随系统，以上面的hooks为例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 store 中取出用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">const</span> manualScheme = useSelector(selectManualColorScheme);</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先取用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">return</span> manualScheme || scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="React-Native中的适配"><a href="#React-Native中的适配" class="headerlink" title="React Native中的适配"></a>React Native中的适配</h2><p>上面说的都是在浏览器里对深色模式的适配，那在React Native里面要怎么适配深色模式呢？</p>
<h3 id="1-大于等于0-62的版本"><a href="#1-大于等于0-62的版本" class="headerlink" title="1. 大于等于0.62的版本"></a>1. 大于等于0.62的版本</h3><p><a target="_blank" rel="noopener" href="https://reactnative.dev/docs/appearance">Appearance · React Native</a></p>
<p>在React Native 0.62版本中，引入了<code>Appearance</code>模块，通过这个模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColorSchemeName = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Appearance &#123;</span><br><span class="line">  <span class="keyword">type</span> AppearancePreferences = &#123;</span><br><span class="line">    <span class="attr">colorScheme</span>: ColorSchemeName;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> AppearanceListener = <span class="function">(<span class="params">preferences: AppearancePreferences</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note: Although color scheme is available immediately, it may change at any</span></span><br><span class="line"><span class="comment">   * time. Any rendering logic or styles that depend on this should try to call</span></span><br><span class="line"><span class="comment">   * this function on every render, rather than caching the value (for example,</span></span><br><span class="line"><span class="comment">   * using inline styles rather than setting a value in a `StyleSheet`).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Example: `const colorScheme = Appearance.getColorScheme();`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add an event handler that is fired when appearance preferences change.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove an event handler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A new useColorScheme hook is provided as the preferred way of accessing</span></span><br><span class="line"><span class="comment"> * the user&#x27;s preferred color scheme (aka Dark Mode).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>Appearance</code>模块，可以获得当前的系统颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = Appearance.getColorScheme();</span><br><span class="line"><span class="keyword">if</span> (colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Appearance.addChangeListener(<span class="function">(<span class="params">prefer: Appearance.AppearancePreferences</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prefer.colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时也提供了一个上面我们自己实现的hooks，<code>useColorScheme</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = useColorScheme();</span><br></pre></td></tr></table></figure>

<h4 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h4><ol>
<li><p><code>Appearance</code>这个接口在Chrome调试模式下，会不生效，永远返回<code>light</code></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></p>
</li>
<li><p><code>Appearance</code>想要生效，还需要Native做一些配置</p>
<p> <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></p>
<blockquote>
<p>Also make sure you do <strong>not</strong> have UIUserInterfaceStyle set in your Info.plist. I had it set to ‘light’ so Appearance.getColorScheme() was always returning ‘light’.</p>
</blockquote>
</li>
</ol>
<h3 id="2-小于0-62的版本"><a href="#2-小于0-62的版本" class="headerlink" title="2. 小于0.62的版本"></a>2. 小于0.62的版本</h3><p>对于0.62之前的版本，由于RN没有提供官方接口，需要通过第三方的库<code>react-native-dark-mode</code>来实现：<br><a target="_blank" rel="noopener" href="https://github.com/codemotionapps/react-native-dark-mode">GitHub - codemotionapps/react-native-dark-mode: Detect dark mode in React Native</a></p>
<p>它的实现原理感兴趣的可以看下：</p>
<blockquote>
<p><strong>react-native-dark-mode 实现原理</strong>(这段实现原理其实也是问Chat GPT得到的答案😂)</p>
<p><code>react-native-dark-mode</code>库的实现原理比较简单，它主要是利用了原生平台的接口来检测当前系统是否处于深色模式。在iOS平台上，它使用了<code>UIUserInterfaceStyle</code>接口来获取当前系统的界面风格，然后判断是否为暗黑模式。在Android平台上，它使用了<code>UiModeManager</code>接口来获取当前系统的 UI 模式，然后判断是否为夜间模式。</p>
<p>具体来说，<code>react-native-dark-mode</code>在React Native项目中提供了一个名为<code>useDarkMode</code>的 React Hooks，用于获取当前系统是否处于深色模式。当使用这个Hooks时，它会首先检测当前平台是否支持暗黑模式，如果支持，就直接调用原生平台的接口获取当前系统的界面风格或UI模式，并将结果返回给调用方。如果不支持，就返回一个默认值（比如浅色模式）。</p>
<p>需要注意的是，由于<code>react-native-dark-mode</code>是一个纯JS库，它无法直接调用原生平台的接口。所以它在Native端编写了一个名为<code>DarkMode</code>的模块，在JS层通过<code>NativeModules.DarkMode</code>来调用。</p>
<ul>
<li>在iOS上，<code>DarkMode</code>模块会通过<code>RCT_EXPORT_MODULE()</code>宏将自己暴露给RN的JS层。同时，它还会使用<code>RCT_EXPORT_METHOD()</code>宏将检测系统界面风格的方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
<li>在Android上，<code>DarkMode</code>模块同样会通过<code>@ReactModule</code>注解将自己暴露给JS层。然后，它会创建一个名为<code>DarkModeModule</code>的Java类，并在该类中实现检测系统UI模式的方法。最后，它会使用<code>@ReactMethod</code>注解将该方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
</ul>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7044043307340529694#heading-8">web深色模式适配指南 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904024085364750">扫盲， H5适配暗黑主题（DarkMode）全部解法 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">紧跟潮流学设计：深色模式设计的8个小技巧-36氪</a></li>
<li><a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">即刻7.0：如何设计深色模式？（非官方） | 人人都是产品经理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xiaoxili.com/hi-face/docs/other/minapp-to-dark-mode.html">【草稿】深色模式在Web端的适配技巧，附带小程序侧的思考 · Hi头像</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cpming.top/p/detect-dark-mode-in-rn">在 React Native 中检测并适配暗黑模式 - 长跑茗</a></li>
<li><a target="_blank" rel="noopener" href="https://web.dev/color-scheme/">Improved dark mode default styling with the color-scheme CSS property and …</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/08/18/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/18/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Jest单元测试中常用的方法和技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-18 09:49:00" itemprop="dateCreated datePublished" datetime="2021-08-18T09:49:00+08:00">2021-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-02 17:21:31" itemprop="dateModified" datetime="2024-01-02T17:21:31+08:00">2024-01-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文首次发布于<a target="_blank" rel="noopener" href="https://juejin.cn/post/6997581158670630948">掘金</a>，转载请注明来源。</p>
</blockquote>
<h2 id="一、mock模块"><a href="#一、mock模块" class="headerlink" title="一、mock模块"></a>一、mock模块</h2><p>在Jest中，对模块进行mock非常简单，只需要使用<code>jest.mock</code>即可，对于模块的mock主要有两种情况：</p>
<ol>
<li><p>只mock模块中的非<code>default</code>导出</p>
<p> 对于只有非<code>default</code>导出的情况（如<code>export const</code>、<code>export class</code>等），只需要使用<code>jest.mock</code>，返回一个对象即可，对象中包含有你想要mock的函数或者变量：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock &#x27;moduleName&#x27; 中的 foo 函数</span></span><br><span class="line">jest.mock(<span class="string">&#x27;../moduleName&#x27;</span>, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">foo</span>: jest.fn().mockReturnValue(<span class="string">&#x27;mockValue&#x27;</span>),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li>
<li><p>mock模块中的<code>default</code>导出</p>
<p> 对于<code>default</code>导出的mock，则不能返回一个简单的对象，而是需要在对象中包含一个<code>default</code>属性，同时添加<code>__esModule: true</code>。</p>
<blockquote>
<p>When using the factory parameter for an ES6 module with a default export, the __esModule: true property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it’s an instruction to import the property named default from the export object</p>
</blockquote>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleName, &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;../moduleName&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../moduleName&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">__esModule</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">default</span>: jest.fn(<span class="function">() =&gt;</span> <span class="number">42</span>),</span><br><span class="line">    <span class="attr">foo</span>: jest.fn(<span class="function">() =&gt;</span> <span class="number">43</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">moduleName(); <span class="comment">// Will return 42</span></span><br><span class="line">foo(); <span class="comment">// Will return 43</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、mock模块部分内容"><a href="#二、mock模块部分内容" class="headerlink" title="二、mock模块部分内容"></a>二、mock模块部分内容</h2><p>如果只想mock模块中的部分内容，对于其他部分保持原样，可以使用<code>jest.requireActual</code>来引入真实的模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getRandom &#125; <span class="keyword">from</span> <span class="string">&#x27;../myModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../myModule&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Require the original module to not be mocked...</span></span><br><span class="line">  <span class="keyword">const</span> originalModule = jest.requireActual(<span class="string">&#x27;../myModule&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">__esModule</span>: <span class="literal">true</span>, <span class="comment">// Use it when dealing with esModules</span></span><br><span class="line">    ...originalModule,</span><br><span class="line">    <span class="attr">getRandom</span>: jest.fn().mockReturnValue(<span class="number">10</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getRandom(); <span class="comment">// Always returns 10</span></span><br></pre></td></tr></table></figure>

<h2 id="三、mock模块内部函数"><a href="#三、mock模块内部函数" class="headerlink" title="三、mock模块内部函数"></a>三、mock模块内部函数</h2><p>设想一种情况，有一个<code>utils.ts</code>文件，内部导出了两个函数<code>funcA</code>和<code>funcB</code>，然后在<code>funcB</code>中引用了<code>funcA</code>:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  funcA();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候在对<code>funcB</code>进行单元测试时，如果想要对<code>funcA</code>进行mock，会发现mock失败：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; funcA, funcB &#125; <span class="keyword">from</span> <span class="string">&#x27;../src/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../src/utils&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originalModule = jest.requireActual(<span class="string">&#x27;../src/utils&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...originalModule,</span><br><span class="line">    <span class="attr">funcA</span>: jest.fn(),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;utils.ts 单元测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&#x27;测试 funcB&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    funcB();</span><br><span class="line">    expect(funcA).toBeCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行单测会得到一个报错</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/get_error_for_test.png" alt="jest单测报错"></p>
<p>很明显，我们对<code>funcA</code>的mock失败了，为什么会有这样的结果呢，因为我们从模块外部导入的<code>funcA</code>引用和模块内部直接使用的<code>funcA</code>引用并不是同一个，通过<code>jest.mock</code>修改<code>funcA</code>并不会影响内部的调用。对于这种情况，建议的解决方法有两种：</p>
<ul>
<li>拆分文件，将<code>funcA</code>拆分到不同的文件。这种做法可能会造成文件过多且分散的问题。</li>
<li>将相互调用的函数，作为一个工具类的方法来实现。即将互相调用的函数，放到同一个工具类中。</li>
</ul>
<h2 id="四、mock类（class）构造函数中对其他成员函数的调用"><a href="#四、mock类（class）构造函数中对其他成员函数的调用" class="headerlink" title="四、mock类（class）构造函数中对其他成员函数的调用"></a>四、mock类（<code>class</code>）构造函数中对其他成员函数的调用</h2><p>当我们在mock一个<code>class</code>的方法的时候，很简单地将类对象的对应方法赋值为<code>jest.fn()</code>即可，但是对于在构造函数中调用的成员方法，却不能这样做。因为类里面的方法只能在实例化完成之后再进行mock，不能阻止<code>constructor</code>中执行原函数。</p>
<p>这时，我们可以考虑一下，<code>class</code>的本质是什么，<code>class</code>是ES6中的语法糖，本质上还是ES5中的原型<code>prototype</code>，所以类的成员方法本质上也是挂载到类原型上的方法，所以我们只需要mock类构造函数的原型上的方法即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.init = jest.fn();</span><br></pre></td></tr></table></figure>

<h2 id="五、mock类中的私有函数（针对TypeScript而言）"><a href="#五、mock类中的私有函数（针对TypeScript而言）" class="headerlink" title="五、mock类中的私有函数（针对TypeScript而言）"></a>五、mock类中的私有函数（针对TypeScript而言）</h2><p>对于ts中类的私有函数（<code>private</code>），无法直接获取（虽然说可以<code>ts-ignore</code>忽略ts报错，不过不建议这样做），这时只需使用同样的方法，在类的原型上直接mock即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">funcA</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.funcA = jest.fn();</span><br></pre></td></tr></table></figure>

<h2 id="六、mock对象的只读属性（getter）"><a href="#六、mock对象的只读属性（getter）" class="headerlink" title="六、mock对象的只读属性（getter）"></a>六、mock对象的只读属性（<code>getter</code>）</h2><p>在单测中，对于可读可写属性我们可以比较方便地进行mock，直接赋值为对应的mocK值即可，如<code>Platform.OS</code>。但是对于只读属性（<code>getter</code>）的mock却不能直接这样写。通常对于只读属性（此处以<code>document.body.clientWidth</code>为例）有以下两种mock方式：</p>
<ol>
<li><p>通过<code>Object.defineProperty</code></p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">document</span>.body, <span class="string">&#x27;clientWidth&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">set</span>: jest.fn(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>jest.spyOn</code></p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockClientWidth = jest.spyOn(<span class="built_in">document</span>.body, <span class="string">&#x27;clientWidth&#x27;</span>, <span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">mockClientWidth.mockReturnValue(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、使用toBeCalledWith对参数中的匿名函数进行断言"><a href="#七、使用toBeCalledWith对参数中的匿名函数进行断言" class="headerlink" title="七、使用toBeCalledWith对参数中的匿名函数进行断言"></a>七、使用<code>toBeCalledWith</code>对参数中的匿名函数进行断言</h2><p>我们需要对于某个方法测试时，有时需要断言这个方法以具体参数被调用，<code>toBeCalledWith</code>可以实现这个功能，但是设想下面一种情况</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> func = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* condition 1 */</span>) &#123;</span><br><span class="line">    moduleA.method1(<span class="number">1</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    moduleA.method1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某种情况下，<code>moduleA.method1</code>将会被传入参数<code>1</code>和一个匿名函数，要怎么用<code>toBeCalledWith</code>断言<code>moduleA.method1</code>被以这些参数调用了呢？因为第二个参数是一个匿名函数，外部没办法mock。这个时候，我们可以使用<code>expect.any(Function)</code>来断言：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moduleA.method1 = jest.fn();</span><br><span class="line"><span class="comment">// 构造出 condition 1</span></span><br><span class="line">func();</span><br><span class="line">expect(moduleA.method1).toBeCalledWith(<span class="number">1</span>, expect.any(<span class="built_in">Function</span>));</span><br></pre></td></tr></table></figure>

<p>因为这里其实只关心<code>moduleA.method1</code>是否被传入第二个参数且参数是否为一个函数，而不关心函数的具体内容，所以可以用<code>expect.any(Function)</code>来断言。</p>
<h2 id="八、mock-localStorage"><a href="#八、mock-localStorage" class="headerlink" title="八、mock localStorage"></a>八、mock <code>localStorage</code></h2><p><code>localStorage</code>是浏览器环境下的一个全局变量，挂载在<code>window</code>下，在单测运行时（Node环境）是获取不到的，对于<code>localStorage</code>，我们可以实现一个简单的mock：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStorageMock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> store: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">setItem</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.store[key] = <span class="built_in">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getItem(key: <span class="built_in">string</span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.store[key] || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">removeItem</span>(<span class="params">key: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.store[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.store = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> key(index: <span class="built_in">number</span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.store)[index] || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">length</span>(): <span class="title">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.store).length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">global</span>.localStorage = <span class="keyword">new</span> LocalStorageMock();</span><br></pre></td></tr></table></figure>

<p>建议把mock放到单独的mocks文件中，在需要测试的地方，单独引入即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./__mocks__/localStorage&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="九、mock-indexedDB"><a href="#九、mock-indexedDB" class="headerlink" title="九、mock indexedDB"></a>九、mock <code>indexedDB</code></h2><p>对于indexedDB，情况和<code>localStorage</code>类似，它是浏览器环境下的一个事务型数据库系统，同样在Node环境中无法获取，但是由于indexedDB接口、类型较多，实现起来较为复杂，不建议自己实现，比较常见的做法是使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/fake-indexeddb">fake-indexeddb</a>这个库，这个库使用纯js在内存中实现了indexedDB的各种接口，主要用于在Node环境中对依赖indexedDB的代码进行测试。</p>
<p>对于需要测试的文件，只需要在文件开头引入<code>fake-indexeddb/auto</code>即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;fake-indexeddb/auto&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要对所有的文件都引入<code>fake-indexeddb</code>，那么只需要在jest配置中添加如下配置：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">setupFiles</span>: [<span class="string">&#x27;fake-indexeddb/auto&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或在<code>package.json</code>中</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;setupFiles&quot;</span>: [<span class="string">&quot;fake-indexeddb/auto&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、测试异步函数"><a href="#十、测试异步函数" class="headerlink" title="十、测试异步函数"></a>十、测试异步函数</h2><p>在单测中，如果需要对异步函数进行测试，针对不同情况有如下操作：</p>
<ol>
<li><p><code>callback</code>回调函数异步</p>
<p> 对于回调函数异步（如<code>setTimeout</code>回调），如果像同步函数一样进行测试，是没办法获取正确的断言结果的：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcA = (callback: <span class="function">(<span class="params">data: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcA&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  funcA(<span class="function">(<span class="params">data</span>) =&gt;</span> expect(data).toEqual(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 像上面那样，<code>funcA</code>会在回调里传入1，单测里就算是直接断言结果为2，也是可以直接通过单测的：</p>
<p> <img src="https://static.youfindme.cn/blog/jest_techniques/callback_async_unit_test.png" alt="callback异步单测"></p>
<p> 这是因为jest在运行完<code>funcA</code>后就直接结束了，不会等待<code>setTimeout</code>的回调，自然也就没有执行<code>expect</code>断言。正确的做法是，传入一个<code>done</code>参数：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcA&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  funcA(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(<span class="number">2</span>);</span><br><span class="line">    done();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 在回调执行完之后显式地告诉jest异步函数执行完毕，jest会等到执行了<code>done()</code>之后再结束，这样就能得到预期的结果了。</p>
</li>
<li><p><code>Promise</code>异步</p>
<p> 除了回调函数外，另外一种很常见的异步场景就是<code>Promise</code>了，对于<code>Promise</code>异步，不用像上面那么复杂，只需要在<code>test</code>用例结束时，把<code>Promise</code>返回即可：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcB = (): <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcB&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> funcB().then(<span class="function">(<span class="params">data</span>) =&gt;</span> expect(data).toEqual(<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 如果使用了<code>async/await</code>语法，就更简洁了，<code>Promise</code>都不需要返回，像测试同步代码一样直接书写即可：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcB&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> funcB();</span><br><span class="line">  expect(data).toEqual(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 对于<code>Promise</code>抛出的异常，测试方法也和上面类似：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcC = (): <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&#x27;something wrong&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcC promise&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> funcC().catch(<span class="function">(<span class="params">error</span>) =&gt;</span> expect(error).toEqual(<span class="string">&#x27;something wrong&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">test(<span class="string">&#x27;funcC await&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> funcC();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    expect(error).toEqual(<span class="string">&#x27;something wrong&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="十一、不执行jest-spyOn-mock的函数"><a href="#十一、不执行jest-spyOn-mock的函数" class="headerlink" title="十一、不执行jest.spyOn mock的函数"></a>十一、不执行<code>jest.spyOn</code> mock的函数</h2><p>我们知道，<code>jest.fn</code>和<code>jest.spyOn</code>都可以用来mock一个函数，区别是<code>jest.fn</code> mock的函数不会去执行，而<code>jest.spyOn</code> mock的函数是会去正常执行的。那么有没有什么办法让<code>jest.spyOn</code> mock的函数不执行呢？其实上面已经用到了，在“mock对象的只读属性（<code>getter</code>）”中，通过<code>jest.spyOn</code> mock了一个<code>getter</code>，然后使用<code>mockReturnValue</code>来mock一个返回值，这个时候原函数就不会执行。</p>
<p>除此之外，使用<code>mockImplementation</code>也有同样的效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockFn.mockImplementation(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>总结下来就是可以使用<code>mockReturnValue</code>和<code>mockImplementation</code>不执行<code>jest.spyOn</code>mock的函数。</p>
<p>另外多说一个建议就是，能使用<code>jest.fn</code>就尽量不要用<code>jest.spyOn</code>，因为<code>jest.spyOn</code>会执行原始代码，在统计单测覆盖率时会被统计进去，导致单测覆盖率看起来很高实际上却又很多代码没有相应单测。</p>
<h2 id="十二、使用test-each"><a href="#十二、使用test-each" class="headerlink" title="十二、使用test.each"></a>十二、使用<code>test.each</code></h2><p>有时我们会遇到这种情况，要写大量单测用例，但是每个用例结构一样或相似，只有细微不同，比如测试某个<code>format</code>函数对于不同的字符串的返回结果，或者调用一个类不同的成员方法但返回的结果类似（如都抛出错误或<code>return null</code>等），对于这些情况，有时我们可以在单测内写一个数组然后遍历执行一下，但其实jest已经提供了应对这种情况的方法，即<code>test.each</code>，举几个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> checkString = (str: <span class="built_in">string</span>): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;mockError 1&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;mockError 2&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// each.test.ts</span></span><br><span class="line">describe(<span class="string">&#x27;each.ts 单元测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test.each&lt;&#123; <span class="attr">param</span>: <span class="built_in">string</span>; expectRes: <span class="built_in">boolean</span> | <span class="built_in">string</span> &#125;&gt;([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="string">&#x27;mockError 1&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="string">&#x27;mockError 2&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ])(<span class="string">&#x27;checkString&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; param, expectRes &#125; = data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = checkString(param);</span><br><span class="line">      expect(result).toEqual(expectRes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      expect(error.message).toEqual(expectRes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>又比如在某种情况下，某个对象<code>store</code>的所有方法都会抛出异常：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test.each&lt;&#123;</span><br><span class="line">  <span class="attr">func</span>: <span class="string">&#x27;get&#x27;</span> | <span class="string">&#x27;delete&#x27;</span> | <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;update&#x27;</span>;</span><br><span class="line">  param?: <span class="built_in">any</span>;</span><br><span class="line">&#125;&gt;([</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;get&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;delete&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;add&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>, <span class="string">&#x27;mockValue&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;update&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>, <span class="string">&#x27;mockValue&#x27;</span>] &#125;,</span><br><span class="line">])(<span class="string">&#x27;调用 store 的方法抛出异常&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> store[data.func](...data.param).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(err).toEqual(<span class="string">&#x27;mockError&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除了<code>test.each</code>外，还有<code>describe.each</code>，更多具体用法可以参考<a target="_blank" rel="noopener" href="https://jestjs.io/docs/api#testeachtablename-fn-timeout">test.each</a>和<a target="_blank" rel="noopener" href="https://jestjs.io/docs/api#describeeachtablename-fn-timeout">describe.each</a></p>
<h2 id="十三、使用-test-js、-test-ts、-test-tsx"><a href="#十三、使用-test-js、-test-ts、-test-tsx" class="headerlink" title="十三、使用.test.js、.test.ts、.test.tsx"></a>十三、使用<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code></h2><p>这点是一个建议，建议单测文件以<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>命名，如对于<code>utils.ts</code>，建议对应的单测以<code>utils.test.ts</code>命名，这样每个单测文件单单从文件名来说就具有清晰的语义，即这是一个单测文件，而不是一个具有具体功能的源码文件。</p>
<p>同时，在搜索文件或者全局搜索字符串时，列表里的文件更清晰可见容易辨认。更进一步来说，现在很多IDE的文件图片icon插件，针对不同的文件名结尾，都有不同的渲染，更加方便辨认：<br><img src="https://static.youfindme.cn/blog/jest_techniques/search_file.png" alt="search_file"><br><img src="https://static.youfindme.cn/blog/jest_techniques/global_search.png" alt="global_search"></p>
<h2 id="十四、配合使用Jest-Runner插件"><a href="#十四、配合使用Jest-Runner插件" class="headerlink" title="十四、配合使用Jest Runner插件"></a>十四、配合使用<code>Jest Runner</code>插件</h2><p>另外推荐一个VSCode插件，<code>Jest Runner</code>，这个插件会在<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>中，渲染几个按钮选项：</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/run_debug.png" alt="run_debug"></p>
<p>点击<code>Run</code>或<code>Debug</code>，可以只运行或调试某一个<code>test</code>或者<code>describe</code>，不需要重新全局<code>npm run test</code>也不用单独<code>jest</code>执行这个文件，极大提高写单测的效率：</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/run_debug_result.png" alt="run_debug_result"></p>
<p>这个插件只针对<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>这几个文件类型有效，所以这也是上面建议单测文件使用使用<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>命名的原因之一。</p>
<p>同时，插件提供的<code>Debug</code>，也省去了繁琐的<code>launch.json</code>配置，可以方便地进行断点调试。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/07/07/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/07/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">前端代码规范化配置最佳实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 10:00:13" itemprop="dateCreated datePublished" datetime="2021-07-07T10:00:13+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文首次发布于个人博客<a href="https://youfindme.top/">youfindme.top</a>，转载请注明来源。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在前端项目开发过程中，我们经常会听到<strong>代码规范化</strong>这个词，即通过多种工具来对代码、Git记录等进行约束，使之达到某种规范。而这些规范工具多种多样，让人眼花缭乱，本文尝试通过一个<strong>工具集</strong>，来给出一种前端代码规范化的最佳实践。</p>
</blockquote>
<p>本文将基于<code>TypeScript</code>来讲解，工具集中主要包括以下工具：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eslint.bootcss.com/"><code>eslint</code></a>：对代码进行风格和规范进行检查，对不符合规范的代码给出提示，同时可以进行一定程度的自动修复</li>
<li><a target="_blank" rel="noopener" href="https://prettier.io/"><code>prettier</code></a>：自动格式化代码工具，根据<code>prettier</code>规范对代码进行修复，拥有比<code>eslint</code>更加强大的代码规范性修复能力</li>
<li><a target="_blank" rel="noopener" href="https://typicode.github.io/husky/#/"><code>husky</code></a>：Git hooks工具，通过配置一系列钩子，可以在<code>git</code>操作的不同阶段执行相应的命令</li>
<li><a target="_blank" rel="noopener" href="https://github.com/okonet/lint-staged"><code>lint-staged</code></a>：在提交代码前进行lint检查时，可以让lint只检查<code>git</code>暂存区（<code>staged</code>）的文件，而不会检查所有文件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/commitizen/cz-cli"><code>commitzen</code></a>：可以实现规范的提交说明的<code>git-cz</code>工具，提供选择的提交信息类别，快速生成提交说明，如果需要在项目中使用<code>commitizen</code>生成符合某个规范的提交说明，则需要使用对应的适配器</li>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint"><code>commit-lint</code></a>：校验提交说明是否符合规范。<code>commitzen</code>只是一个实现规范提交说明的工具，但可能存在不使用这个工具直接用<code>git</code>提交的情况，那么就需要对每次提交说明进行检查是否符合规范</li>
</ul>
<p>除了上面提到的，其他相关工具会在用到的时候再详细说明。</p>
<h2 id="一、eslint-amp-prettier"><a href="#一、eslint-amp-prettier" class="headerlink" title="一、eslint &amp; prettier"></a>一、eslint &amp; prettier</h2><h3 id="1-首先安装eslint和prettier及相关工具"><a href="#1-首先安装eslint和prettier及相关工具" class="headerlink" title="1. 首先安装eslint和prettier及相关工具"></a>1. 首先安装<code>eslint</code>和<code>prettier</code>及相关工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint prettier</span><br><span class="line">npm install --save-dev eslint-plugin-prettier eslint-config-prettier</span><br><span class="line">npm install --save-dev @typescript-eslint/parser  @typescript-eslint/eslint-plugin</span><br><span class="line">npm install --save-dev eslint-plugin-import</span><br><span class="line">npm install --save-dev eslint-import-resolver-typescript</span><br></pre></td></tr></table></figure>

<p>其中除了<code>eslint</code>和<code>prettier</code>外的其他几个工具作用分别是：</p>
<ul>
<li><code>eslint-plugin-prettier</code>：将 prettier 的能力集成到 eslint 中, 按照 prettier 的规则检查代码规范性，并进行修复</li>
<li><code>eslint-config-prettier</code>：让所有可能会与 prettier 规则存在冲突的 eslint rule 失效，并使用 prettier 的规则进行代码检查</li>
<li><code>@typescript-eslint/parser</code>： 解析器，使 eslint 可以解析 ts 语法</li>
<li><code>@typescript-eslint/eslint-plugin</code>：指定了 ts 代码规范的 plugin</li>
<li><code>eslint-plugin-import</code>：对 ES6+ 的导入/导出语法进行 lint, 并防止文件路径和导入名称拼写错误的问题</li>
<li><code>eslint-import-resolver-typescript</code>：这个插件为<code>eslint-plugin-import</code>添加了 ts 支持，详见<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-import-resolver-typescript">此处</a></li>
</ul>
<h3 id="2-配置-eslintrc-js（或者-eslingtrc，-eslintrc-json）"><a href="#2-配置-eslintrc-js（或者-eslingtrc，-eslintrc-json）" class="headerlink" title="2. 配置.eslintrc.js（或者.eslingtrc，.eslintrc.json）"></a>2. 配置<code>.eslintrc.js</code>（或者<code>.eslingtrc</code>，<code>.eslintrc.json</code>）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es6</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析器</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>], <span class="comment">// 使用 eslint 和 typescript-eslint 建议的规则</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>, <span class="string">&#x27;import&#x27;</span>], <span class="comment">// 代码规范插件</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 不符合 prettier 规则的代码，要进行错误提示</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">settings</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;import/parsers&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;import/resolver&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">typescript</span>: &#123;</span><br><span class="line">        <span class="attr">project</span>: <span class="string">&#x27;tsconfig.json&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置<code>.prettierrc.js</code>（或者<code>.prettierrc</code>，<code>.prettierrc.json</code>），常用规则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>,</span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">80</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果需要还可以加上相应的<code>.eslintignore</code>和<code>.prettierignore</code>来忽略想要的目录/文件。</p>
<h3 id="3-向package-json的scripts中添加命令"><a href="#3-向package-json的scripts中添加命令" class="headerlink" title="3. 向package.json的scripts中添加命令"></a>3. 向<code>package.json</code>的<code>scripts</code>中添加命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx ./ --fix&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以尝试一下编辑任意<code>js</code>或<code>ts</code>文件并保存，通过<code>npm run lint</code>命令来对项目进行 lint 检查，查看是否符合规则的预期，如果安装了 ESLint VSCode 插件（强烈建议安装），还可以实时看到报错提醒。通过<code>npm run lint:fix</code>命令可以对不符合风格规范的代码进行自动修复。</p>
<p>如果需要对另外一些语法进行 lint 检查，只需添加对应的工具即可，如需要对<code>react</code>和<code>react hooks</code>进行检查，则安装<code>eslint-plugin-react</code>和<code>eslint-plugin-react-hooks</code>即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-plugin-react eslint-plugin-react-hooks</span><br></pre></td></tr></table></figure>

<h3 id="4-安装-VS-Code-插件"><a href="#4-安装-VS-Code-插件" class="headerlink" title="4. 安装 VS Code 插件"></a>4. 安装 VS Code 插件</h3><p>强烈建议安装VS Code插件：<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">Eslint</a> 和 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter</a>，通过这两个插件可以实现实时查看当前的eslint和prettier报错而不需要执行命名行检查。</p>
<h4 id="顺便聊一下关于-eslint-和-prettier-的区别"><a href="#顺便聊一下关于-eslint-和-prettier-的区别" class="headerlink" title="顺便聊一下关于 eslint 和 prettier 的区别"></a>顺便聊一下关于 eslint 和 prettier 的区别</h4><ul>
<li>eslint侧重<strong>影响代码质量</strong>的问题（比如<code>==</code>和<code>===</code>）</li>
<li>prettier更侧重<strong>代码风格</strong>的问题（比如代码折行），以及对代码自动修复</li>
</ul>
<p>eslint很多地方只能warning警告或者报错，但是不能自动修复，比如下面的例子：</p>
<ol>
<li><p>对于<code>==</code>和<code>===</code>的eslint问题<br><img src="https://static.youfindme.cn/blog/code-normalization/eslint-issue.jpeg" alt="eslint-issue"></p>
<p><img src="https://static.youfindme.cn/blog/code-normalization/eslint-issue-fix.jpeg" alt="eslint-issue-fix"><br>这个是eslint报的一个问题，点击“快速修复”，只能弹出几个选项，比如disable这个规则，或者展示文档，没有版本自动修复（下面的copilot不算，这个是GitHub Copilot插件AI修复，不属于自动修复）</p>
</li>
<li><p>对于prettier的代码风格问题<br><img src="https://static.youfindme.cn/blog/code-normalization/prettier-issue.png" alt="prettier-issue"></p>
<p> <img src="https://static.youfindme.cn/blog/code-normalization/prettier-issue-fix.png" alt="prettier-issue-fix"></p>
</li>
</ol>
<p>对于这个代码风格问题，点击“快速修复”，提供了几个自动修复的选项（Fix this …/Fix all …）</p>
<h2 id="二、husky"><a href="#二、husky" class="headerlink" title="二、husky"></a>二、husky</h2><p>通过上面的步骤，我们已经成功安装并配置了 eslint 相关的检查，但是我们不能仅仅依靠开发人员的自觉来保证提交到仓库的代码符合<code>eslint</code>规范，这时候就需要<code>husky</code>这样一个工具来操作<code>git</code>提供的一些钩子<code>hooks</code>，在提交代码时对代码进行 lint 检查。</p>
<h3 id="1-首先是安装husky"><a href="#1-首先是安装husky" class="headerlink" title="1. 首先是安装husky"></a>1. 首先是安装<code>husky</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev husky</span><br></pre></td></tr></table></figure>

<h3 id="2-向package-json的scripts中添加命令"><a href="#2-向package-json的scripts中添加命令" class="headerlink" title="2. 向package.json的scripts中添加命令"></a>2. 向<code>package.json</code>的<code>scripts</code>中添加命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;husky install&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepare</code>命令会在执行<code>npm install</code>（不带参数的情况下）之后自动执行。也就是说当我们执行<code>npm install</code>安装完项目依赖后会执行<code>husky install</code>命令，该命令会创建<code>.husky/</code>并指定该目录为git hooks所在的目录。这里我们先手动执行一次<code>npm run prepare</code>。</p>
<h3 id="3-配置husky"><a href="#3-配置husky" class="headerlink" title="3. 配置husky"></a>3. 配置<code>husky</code></h3><p>添加<code>pre-commit</code> hooks：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit // 或 npx husky set .husky/pre-commit</span><br></pre></td></tr></table></figure>

<p>这将在<code>./husky/</code>目录下生成一个<code>pre-commit</code>脚本文件，在文件里添加<code>npm run lint</code>这个命令，添加完成后文件内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run lint</span><br></pre></td></tr></table></figure>

<p>通过上面三个步骤，我们在执行<code>git commit</code>或者通过<code>git-cz</code>工具提交时，将会先执行<code>pre-commit</code>脚本的内容，即执行<code>npm run lint</code>检查，对不符合代码规范的提交进行阻止，防止污染代码仓库。</p>
<h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><p>上面配置<code>husky</code>的方式是针对 v5.0+ 的配置方式，针对 v5.0 之前的配置方式，则是在安装<code>husky</code>之后在<code>package.json</code>中添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么改的原因是在<code>husky</code> 5.0版本中，做了破坏性的变更，导致两种配置方式不兼容，详见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366786798">此处</a>。本文推荐使用最新的配置方式。</p>
<h2 id="三、lint-staged"><a href="#三、lint-staged" class="headerlink" title="三、lint-staged"></a>三、lint-staged</h2><p>完成<code>husky</code>配置之后，我们做到了通过每次git提交时都对项目做 lint 检查，防止不符合规范的代码提交到仓库，但是这带来一个问题：每次提交都将对整个项目做 lint 检查，对于一个越来越大的项目来说，这无疑是一个很耗时的操作，除此之外，对于新接入这些配置的项目，项目中可能已经存在了大量不符合规范的代码，不能要求在提交时把所有历史遗留的问题修复之后才能提交。这个时候就需要用到<code>lint-staged</code>这个工具了。</p>
<h3 id="1-安装lint-staged"><a href="#1-安装lint-staged" class="headerlink" title="1. 安装lint-staged"></a>1. 安装<code>lint-staged</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev lint-staged</span><br></pre></td></tr></table></figure>

<h3 id="2-在package-json中配置lint-staged"><a href="#2-在package-json中配置lint-staged" class="headerlink" title="2. 在package.json中配置lint-staged"></a>2. 在<code>package.json</code>中配置<code>lint-staged</code></h3><p>在<code>package.json</code>中添加如下配置，配置表明在运行<code>lint-staged</code>的时候将只匹配<code>src</code>和<code>test</code>目录下的<code>ts</code>和<code>tsx</code>文件，我们可以根据自己项目的需要修改配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;src/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;test/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-修改-husky-pre-commit脚本的内容"><a href="#3-修改-husky-pre-commit脚本的内容" class="headerlink" title="3. 修改.husky/pre-commit脚本的内容"></a>3. 修改<code>.husky/pre-commit</code>脚本的内容</h3><p>将<code>.husky/pre-commit</code>脚本的内容改为<code>npm run lint-staged</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run lint-staged</span><br></pre></td></tr></table></figure>

<p>通过上面的步骤，就完成了<code>lint-staged</code>的配置，这个时候再进行 git 提交时，将只检查暂存区（<code>staged</code>）的文件，不会检查项目所有文件，加快了每次提交 lint 检查的速度，同时也不会被历史遗留问题影响。如下图：<br><img src="https://static.youfindme.cn/blog/code-normalization/lint-staged.png" alt="lint-staged"></p>
<h2 id="四、commitzen"><a href="#四、commitzen" class="headerlink" title="四、commitzen"></a>四、commitzen</h2><p>有了上面的几个配置后，其实已经算是一个比较完善的代码规范配置了，不过还有一些其他的可以去做的事，比如 git 提交记录规范。</p>
<p>在多人协作开发过程中，如果不注意提交记录的规范，那么每个人可能都有自己的提交风格，如“修复了xxx的bug”、“增加了一个按钮,修改了一处文案”、“config配置文件增加了xxx字段”，更有甚者会在对项目文件做了大量变更后只写一个“增加了若干功能”或“修复了若干问题”这种提交信息。</p>
<p>那什么才一个好的提交信息呢，我们以<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular提交信息规范</a>来举例说明。</p>
<p>在 Angular 提交信息规范中，一个好的提交信息的结构应该如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>整个提交说明包括三部分：<code>header</code>页眉、<code>body</code>正文、<code>footer</code>页脚，在每个部分之间有一个空白行分隔，其中<code>header</code>部分是每次提交中必须包含的内容。</p>
<ul>
<li><code>header</code>:<br>对于<code>header</code>来说，又包括三部分：<ul>
<li><code>type</code><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#type">类型</a></li>
<li><code>scope</code>本次提交的<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#scope">影响范围</a>（可选）</li>
<li><code>subject</code><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#subject">主题</a>，即对提交的一个简短描述</li>
</ul>
</li>
<li><code>body</code>:<br>本地提交的详细描述，说明代码提交的详细说明</li>
<li><code>footer</code>:<br>主要包括本次提交的 BREAKING CHANGE（不兼容变更）和要关闭的 issue</li>
</ul>
<p>更加详细的内容请参考<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular提交信息规范</a>。</p>
<p><code>commitzen</code>就是这样一个工具，它可以提供可以选择的提交信息类别，快速生成符合规范的提交说明。</p>
<h3 id="1-先安装commitizen和cz-conventional-changelog"><a href="#1-先安装commitizen和cz-conventional-changelog" class="headerlink" title="1. 先安装commitizen和cz-conventional-changelog"></a>1. 先安装<code>commitizen</code>和<code>cz-conventional-changelog</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>

<p>我们在前言中提到，如果需要在项目中使用<code>commitizen</code>生成符合某个规范的提交说明，则需要使用对应的适配器，而<code>cz-conventional-changelog</code>就是符合AngularJS规范提交说明的<code>commitzen</code>适配器。</p>
<h3 id="2-在package-json中配置commitizen"><a href="#2-在package-json中配置commitizen" class="headerlink" title="2. 在package.json中配置commitizen"></a>2. 在<code>package.json</code>中配置<code>commitizen</code></h3><p>在<code>package.json</code>中添加如下配置，配置指明了cz工具<code>commitizen</code>的适配器路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们就可以使用<code>npm run commit</code>来代替<code>git commit</code>进行提交了：<img src="https://static.youfindme.cn/blog/code-normalization/commitizen.png" alt="commitizen"></p>
<h3 id="3-配置自定义提交信息规范"><a href="#3-配置自定义提交信息规范" class="headerlink" title="3. 配置自定义提交信息规范"></a>3. 配置自定义提交信息规范</h3><p>如果想定制项目的提交信息规范，可以使用<code>cz-customizable</code>适配器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev cz-customizable</span><br></pre></td></tr></table></figure>

<p>然后把<code>package.json</code>中配置的适配器路径修改为<code>cz-customizable</code>的路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-customizable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在根目录下新建一个<code>.cz-config.js</code>来配置自定义的规范，这里提供一个官方的示例<a target="_blank" rel="noopener" href="https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js">cz-config-EXAMPLE.js</a>，修改里面字段、内容为自己想要的规范即可</p>
<h3 id="4-生成日志记录"><a href="#4-生成日志记录" class="headerlink" title="4. 生成日志记录"></a>4. 生成日志记录</h3><p>对于使用了<code>commitzen</code>的项目，还可以配套使用<code>conventional-changelog-cli</code>来生成开发日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev conventional-changelog-cli</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样执行<code>npm run version</code>之后就可以看到生成了<code>CHANGELOG.md</code>日志文件了。</p>
<h2 id="五、commit-lint"><a href="#五、commit-lint" class="headerlink" title="五、commit-lint"></a>五、commit-lint</h2><p>在配置了<code>commitizen</code>之后，我们可以愉快地使用<code>npm run commit</code>规范化提交代码，但是配置<code>commitizen</code>并不等于不能使用<code>git commit</code>或者其他工具提交，还是存在提交不规范记录说明的可能，那么就需要使用<code>commit-lint</code>来对每次提交信息进行限制。</p>
<h3 id="1-安装commitlint和-commitlint-config-conventional"><a href="#1-安装commitlint和-commitlint-config-conventional" class="headerlink" title="1. 安装commitlint和@commitlint/config-conventional"></a>1. 安装<code>commitlint</code>和<code>@commitlint/config-conventional</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitlint @commitlint/config-conventional</span><br></pre></td></tr></table></figure>

<p>其中<code>@commitlint/config-conventional</code>是一个符合Angular规范的校验规则集，就像<code>esint</code>也需要<code>extends</code>一些规则集一样，<code>commitlint</code>也需要<code>extends</code>一些规则集。</p>
<h3 id="2-在package-json中配置commitlint"><a href="#2-在package-json中配置commitlint" class="headerlink" title="2. 在package.json中配置commitlint"></a>2. 在<code>package.json</code>中配置<code>commitlint</code></h3><p>在<code>package.json</code>中添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;@commitlint/config-conventional&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint --edit $1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们可能在别的地方见到过<code>commitlint</code>的下面这种写法</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，这也是一种在<code>husky</code> v5.0 之前的写法，在新版<code>husky</code>中不在使用。</p>
<h3 id="3-向husky中添加commit-msg-hooks"><a href="#3-向husky中添加commit-msg-hooks" class="headerlink" title="3. 向husky中添加commit-msg hooks"></a>3. 向<code>husky</code>中添加<code>commit-msg</code> hooks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg // 或 npx husky set .husky/commit-msg</span><br></pre></td></tr></table></figure>

<p>这将在<code>./husky/</code>目录下生成一个<code>commit-msg</code>脚本文件，在文件里添加<code>npm run commitlint</code>这个命令，添加完成后文件内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run commitlint</span><br></pre></td></tr></table></figure>

<p>这时，如果通过<code>git commit</code>或其他工具在提交时没有按照规范写提交信息，那么本次提交就会被阻止，如下图：<br><img src="https://static.youfindme.cn/blog/code-normalization/commit-lint.png" alt="commit-lint"></p>
<h3 id="4-对于自定义提交信息规范的-lint-校验"><a href="#4-对于自定义提交信息规范的-lint-校验" class="headerlink" title="4. 对于自定义提交信息规范的 lint 校验"></a>4. 对于自定义提交信息规范的 lint 校验</h3><p>上面说的<code>@commitlint/config-conventional</code>是针对Angular规范的校验规则集，对于使用了<code>cz-customizable</code>的自定义提交信息规范，就需要使用<code>commitlint-config-cz</code>这个工具来对自定义规范进行校验了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitlint-config-cz</span><br></pre></td></tr></table></figure>

<p>然后把<code>package.json</code>中<code>commitlint</code>的配置改为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;cz&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过上面的这些步骤，我们算是完成了前端代码规范化的配置，到目前，我们新增的配置有：</p>
<ul>
<li><code>.eslintrc.js</code></li>
<li><code>.eslintignore</code></li>
<li><code>.prettierrc.js</code></li>
<li><code>.prettierignore</code></li>
<li><code>.husky</code><ul>
<li><code>pre-commit</code></li>
<li><code>commit-msg</code></li>
<li><code>_</code> husky自动生成的一个文件夹</li>
</ul>
</li>
<li><code>package.json</code> 下面只列出来新增的配置，对于<code>package.json</code>已有的字段没有列出</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;husky install&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx ./ --fix&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;lint-staged&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint --edit $1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;src/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;test/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;@commitlint/config-conventional&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@commitlint/config-conventional&quot;</span>: <span class="string">&quot;^12.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/eslint-plugin&quot;</span>: <span class="string">&quot;^4.28.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/parser&quot;</span>: <span class="string">&quot;^4.28.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: <span class="string">&quot;^4.2.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;^12.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;conventional-changelog-cli&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cz-conventional-changelog&quot;</span>: <span class="string">&quot;^3.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^7.30.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-config-prettier&quot;</span>: <span class="string">&quot;^8.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-import-resolver-typescript&quot;</span>: <span class="string">&quot;^2.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-import&quot;</span>: <span class="string">&quot;^2.23.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-prettier&quot;</span>: <span class="string">&quot;^3.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;husky&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;^11.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: <span class="string">&quot;^2.3.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置过程虽然繁琐，但是对于一个项目，特别是多人协作的大型项目来说，是必不可少的一部分。其实担心配置麻烦，导致每一个新项目都需要重新走一遍配置流程，可以考虑使用<a target="_blank" rel="noopener" href="https://yowebapp.github.io/">Yeoman</a>这个脚手架工具，把一个已经完成代码规范化配置的项目作为模板，通过<a target="_blank" rel="noopener" href="https://github.com/yeoman/yo"><code>yo</code></a>直接一键生成即可，此处是我创建的一个 demo 工程，包含了上述全部配置：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/lint-demo">https://github.com/JingzheWu/lint-demo</a>，以供参考。</p>
<h2 id="参考文章和链接"><a href="#参考文章和链接" class="headerlink" title="参考文章和链接"></a>参考文章和链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904129463058445">快速配置eslint全家桶</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8312704c6be7">前端代码规范最佳实践：eslint+prettier+editorconfig+lint-staged</a></li>
<li><a target="_blank" rel="noopener" href="https://typicode.github.io/husky/#/">Husky</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/issues/2451">Husky v5 hook installation</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356924268">升级husky5实践</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366786798">husky使用总结</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903831893966856">Cz工具集使用介绍 - 规范Git提交说明</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/132348944">使用 commitizen 规范 Git 提交说明</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular commit message guidelines</a></li>
<li><a target="_blank" rel="noopener" href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">Angular提交信息规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/conventional-changelog-cli">conventional-changelog-cli</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/06/27/%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84AOP%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/27/%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84AOP%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">浅谈JavaScript中的AOP和装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-27 21:21:27" itemprop="dateCreated datePublished" datetime="2021-06-27T21:21:27+08:00">2021-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>AOP在其他编程语言中应用较多，在js中却应用较少，由于最近参与的项目中涉及到性能打点上报等，开始探索和了解无侵入地监控或修改代码的方式，趁此机会深入学习了一下AOP与装饰器</p>
</blockquote>
<h3 id="一、什么是AOP"><a href="#一、什么是AOP" class="headerlink" title="一、什么是AOP"></a>一、什么是AOP</h3><p>AOP（Aspect-Oriented Programming），即<strong>面向切面编程</strong>，是一种编程范式，与之对应的有OOP（Object-Oriented Programming）面向对象编程。在JavaScript开发中，面向对象编程不管是ES5中直接操作原型还是ES6+中的class语法糖，大家用的比较多也应该都挺熟悉，但是相对而言，AOP用的就没那么多了。</p>
<p>对于OOP，我们在开发过程中往往是对类和对象通过继承进行<strong>纵向拓展</strong>，但是在AOP中则更侧重于把对象、方法作为切面，对原对象、方法进行<strong>无侵入</strong>的<strong>横向拓展</strong>，下面我们以一些简单的例子和代码来讲一下AOP。</p>
<p>假设我们有一个按钮，绑定了一个点击事件处理函数<code>handleClick</code>，现在需要对按钮增加点击上报，很简单，只需要在<code>handleClick</code>中调用一下上报函数就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  report(<span class="string">&#x27;一条信息&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以后又需要增加对这个函数运行时间的上报，那么就需要在函数开头和结尾各自计算一下时间。</p>
<p>但是想一下，这样做带来的坏处是显而易见的，一是<strong>不利于拓展</strong>，每次增加新的点都需要改一次<code>handleClick</code>函数，改的越多越不利于后期维护；二是<strong>有悖于单一职责原则</strong>，<code>handleClick</code>里处理了大量非按钮的逻辑，同样增加了维护难度。这时候AOP就是一个很好的解决办法了。</p>
<h3 id="二、ES6-之前的实现"><a href="#二、ES6-之前的实现" class="headerlink" title="二、ES6+之前的实现"></a>二、ES6+之前的实现</h3><p>在ES5以及ES6+的装饰器出现之前，我们往往是这样做的（这里用了ES6的部分语法），通过修改<code>Function</code>构造函数的原型，给原型增加两个方法<code>before</code>和<code>after</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn, beforeFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn, afterFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这两个方法，实现在任意一个函数执行前后，执行我们自己自定义的行为，以达<strong>到装饰或拦截</strong>原函数、对象行为的目的。现在，实现上面点击上报的方式变成了这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handleClick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handleClick = handleClick.after(report, <span class="string">&#x27;一条信息&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>和修改原型类似的，我们还可以用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数HOF</a>来实现一个上报函数执行时间的函数（<code>before</code>和<code>after</code>本质上也是高阶函数，只不过是定义在<code>Function</code>原型上的高阶函数）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reportExeTime = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> beforeTime;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">      .before(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        beforeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      &#125;)</span><br><span class="line">      .after(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        report(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - beforeTime&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handleClick = reportExeTime(handleClick);</span><br></pre></td></tr></table></figure>

<p>假设之后还要增加其他和业务逻辑无关的埋点、统计、监控等逻辑，只需要通过类似的方式来装饰原函数即可，而无需修改原函数。通过这种方式，我们实现了对原函数无侵入的横向拓展，是一种比继承更具弹性的代替方案。</p>
<p>其实到这里，很多小伙伴已经意识到了，在前端开发中已经有很多地方已经用到过AOP这种思想了，例如React的高阶组件HOC、Redux的中间件等，都是这种思想的体现。</p>
<h3 id="三、ES6-通过装饰器实现"><a href="#三、ES6-通过装饰器实现" class="headerlink" title="三、ES6+通过装饰器实现"></a>三、ES6+通过装饰器实现</h3><p>上面说的是ES6+中装饰器出现前AOP的实现方式，然而装饰器（Decorators）的出现给我们提供了另一种更为优雅的实现方式（本质上和高阶函数类似），虽然到目前为止这个特性也还只是在<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-decorators">提案的第二阶段</a>，还未真正引入到ES标准中，但是通过Babel（&gt; 7.1.0）或者使用<a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/decorators.html">TypeScript</a>，就可以提前使用这个特性。</p>
<p>关于装饰器的定义和使用方法已经有很多资料讲解了，这里不做过多介绍，我们来看下用装饰器怎么实现上面的逻辑。很容易想到，这里需要的是<strong>方法装饰</strong>器，首先定义一个上报的方法装饰器<code>withReport</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withReport = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;上报了信息&#x27;</span>); <span class="comment">// 数据上报</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @withReport</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们还可以仿照上面的<code>before</code>和<code>after</code>，分别实现一个方法前置和后置<strong>装饰器工厂</strong>来执行任意前置后置方法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = <span class="function">(<span class="params">beforeFn, beforeFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">return</span> originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">afterFn, afterFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们可以方便地传入一个<code>report</code>函数来实现上报：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @after(report, <span class="string">&#x27;一条信息&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于后续增加的其他非业务相关逻辑，也可以通过多个装饰器组合来实现，如上报函数执行时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reportExeTime = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> beforeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    report(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - beforeTime&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @after(report, <span class="string">&#x27;一条信息&#x27;</span>) <span class="comment">// 这个装饰器后执行</span></span><br><span class="line">  @reportExeTime <span class="comment">// 这个装饰器先执行</span></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过装饰器，我们更优雅地实现了AOP，对方法进行横向拓展，而且不会像之前那样直接修改<code>Function</code>原型（确实是一种不太好的方式，污染原型链），装饰器之所以可以做到这一点是因为它并不是在运行时改变类、属性、方法的行为，而是在代码编译的时候就修改了，所以本质上来讲，装饰器就是一个<strong>在编译时运行的语法糖函数</strong>。</p>
<h3 id="四、-AOP与装饰者模式和职责链模式"><a href="#四、-AOP与装饰者模式和职责链模式" class="headerlink" title="四、 AOP与装饰者模式和职责链模式"></a>四、 AOP与装饰者模式和职责链模式</h3><p>上面提到了，我们可以通过AOP来拓展函数或对象的行为，可以达到<strong>装饰或拦截</strong>原函数、对象行为的目的，对应的有两个设计模式，分别是<strong>装饰者模式</strong>和<strong>职责链模式</strong>（详见《JavaScript设计模式与开发实践》），AOP在这两种模式中的应用有一个明显的区别，就是能否阻断/覆盖原函数、对象的行为。有一点要声明的是，AOP只是实现这两种设计模式的其中一种方式，并不是唯一的实现方式，这里只是探讨在两种模式中AOP的应用。</p>
<p>对于装饰者模式，上面的几个示例都是很好的例子，不管是修改原型实现还是装饰器实现，都是通过<code>before</code>和<code>after</code>这两个来横向（区别于纵向的继承）的拓展原函数的能力，这里的<code>before</code>和<code>after</code>都是<strong>静默执行</strong>的，即<code>before</code>和<code>after</code>里执行的函数都不会阻断后续函数的执行或者覆盖原函数的返回值。应用场景也比较多，如上报、计时、日志等等，这也是AOP应用的比较多的场景。</p>
<p>然而对于职责链模式，对于<code>before</code>和<code>after</code>的能力要求则变成了：<code>before</code>和<code>after</code>里执行的函数可以阻断后续函数的执行，或<code>before</code>和<code>after</code>里执行的函数的返回值可以覆盖原函数的返回值。对应的代码实现变成了类似于下面这种：</p>
<ul>
<li>修改原型实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn, beforeFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> beforeRet = beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">if</span> (!beforeRet) &#123;</span><br><span class="line">      <span class="comment">// 如果不合法则阻断后续操作，这里为了表示方便这样简写</span></span><br><span class="line">      <span class="keyword">return</span> beforeRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn, afterFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="comment">// 返回值符合条件时才返回，这里为了表示方便这样简写</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments); <span class="comment">// 在原函数返回值不符合条件时，执行after后续函数，覆盖原函数返回值</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = <span class="function">(<span class="params">beforeFn, beforeFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> beforeRet = beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">if</span> (!beforeRet) &#123;</span><br><span class="line">        <span class="comment">// 如果不合法则阻断后续操作，这里为了表示方便这样写</span></span><br><span class="line">        <span class="keyword">return</span> beforeRet;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">afterFn, afterFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="comment">// 返回值符合条件时才返回，这里为了表示方便这样简写</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments); <span class="comment">// 在原函数返回值不符合条件时，执行after后续函数，覆盖原函数返回值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种也有很多应用场景，最常见的就是表单等的校验，如传入的值不合法，则阻断后续函数执行，或者在原函数返回值不符合要求时，则用after里函数的返回值来覆盖。</p>
<h3 id="五、-结语"><a href="#五、-结语" class="headerlink" title="五、 结语"></a>五、 结语</h3><p>其实除了上面提到的，我们还可以拓展下思路，上面对于函数的修饰，都是需要项目中的每个开发者手动在方法、类等前面显式调用，那么对于一些基础、通用的修饰方法，能否在打包构建时，通过打包构建插件分析语法树自动地给代码里的特定方法、类增加修饰，这个值得我们进一步思考探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/06/27/%E8%B0%88%E8%B0%88DNS%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/27/%E8%B0%88%E8%B0%88DNS%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">谈谈DNS协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-27 21:11:53" itemprop="dateCreated datePublished" datetime="2021-06-27T21:11:53+08:00">2021-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>DNS协议</strong>也可以称为DNS服务，全称是<strong>Domain Name System</strong>，即<strong>域名系统</strong>，和HTTP协议一样，也是一个位于<strong>应用层</strong>的协议（服务），它是基于运输层的UDP协议的，关于网络协议的分层介绍，见<a href="">这里</a>（还没有写好，先放这里一个空链接）。<br>从DNS的名字我们就可以知道，它提供域名映射到IP地址的服务，那么在我们详细说DNS协议之前，先来大致讲讲互联网的<strong>域名结构</strong>。</p>
<h4 id="1-域名结构"><a href="#1-域名结构" class="headerlink" title="1. 域名结构"></a>1. 域名结构</h4><p>我们都知道，在互联网中，每一台计算机想要访问互联网，都需要一个IP地址来进行网络通信，可以是形如<code>192.168.1.1</code>这样的点分十进制的IPv4地址，也可以是形如<code>[0:0:0:0:0:0:0:1]</code>这样方括号包围的十六进制的IPv6地址，但是这些地址不便于记忆，所以就产生了域名这种方便人们记住的东西（当然你要是记忆力好能记住IP地址，在浏览器地址栏输入URL的时候，也可以直接用IP地址替换掉域名，效果是一样的）。</p>
<p>域名也可以叫做主机名。这里我们先给出一个域名，例如<code>www.abc.com</code>，以这个域名为例，来看一下域名的结构。</p>
<p>域名采用层次化的结构，其中<code>com</code>是顶级域名，<code>abc</code>是二级域名，<code>www</code>是三级域名，从语法上来说，每个域名都是几个不同层级的名字用<code>.</code>连接起来的组合，<strong>域名不区分大小写字母</strong>，所以<code>www.ABC.com</code>和<code>www.abc.com</code>是一样的，按照规定来说，域名有长度限制，这里就不再细讲。</p>
<p>上面提到，<code>com</code>是一个顶级域名（TLD，Top Level Domain），除了<code>com</code>之外，顶级域名还有好多，一般来说可以分为：</p>
<ul>
<li><p>国家顶级域名</p>
<p>  如<code>cn</code>表示中国，<code>us</code>表示美国，<code>uk</code>表示英国，当然还有一些特殊地区也有所谓的国家顶级域名，比如<code>hk</code>表示香港</p>
</li>
<li><p>通用顶级域名</p>
<p>  如<code>com</code>表示公司企业，<code>net</code>表示网络服务机构，<code>org</code>表示非营利组织，<code>edu</code>表示美国教育机构（中国的教育机构一般来说是<code>xxx.edu.cn</code>），<code>gov</code>表示美国政府部门（中国的政府部门一般来说是<code>xxx.gov.cn</code>）等。</p>
</li>
<li><p>基础结构域名</p>
<p>  不常见，不做叙述。</p>
</li>
</ul>
<p>所以说，在中国，企业的域名一般可以是<code>xxx.com</code>、<code>xxx.com.cn</code>、<code>xxx.cn</code>。</p>
<p>下面这个域名树，清晰地展示了互联网的域名空间：</p>
<p><img src="https://my-cos-1254464911.cos.ap-guangzhou.myqcloud.com/DNS-protocol/domain-name-tree.png" alt="互联网的域名结构"></p>
<p>在图中，<code>edu.cn</code>下面，划分除了很多三级域名，如<code>tsinghua</code>、<code>pku</code>等，一旦某个单位有了一个域名，它就可以自己决定是否要进一步划分下属的子域，域名树的树叶节点就是单台计算机的名字，不能再继续划分了，例如<code>mail</code>和<code>www</code>这两台计算机的完整域名分别为<code>mail.tsinghua.edu.cn</code>和<code>www.tsinghua.edu.cn</code>（这里起什么名字都可以，一般来说，人们愿意把用作邮件服务器的计算机叫做mail，把用作网站的服务器叫做www）。</p>
<p>到这里，我们已经知道了为什么要有域名以及域名的结构，域名就是为了便于人们记忆而产生的，但是域名是方便人们记忆了，计算机反而不好处理了，它更善于处理IP地址这种东西，所以这里就用到了我们要讲的DNS协议，用来把域名映射到IP地址，在了解DNS解析域名的过程之前，我们还需要了解一下域名服务器这种东西（怎么这么多东西，写个博客好麻烦啊23333）。</p>
<h4 id="2-域名服务器（DNS服务器）"><a href="#2-域名服务器（DNS服务器）" class="headerlink" title="2. 域名服务器（DNS服务器）"></a>2. 域名服务器（DNS服务器）</h4><p>上面说到了域名体系的树状结构，为了实现域名系统，我们首先想到的就是在域名树的每个节点都设置一台对应的服务器，这样就可以了，但是这样做的后果就是导致域名服务器太多，域名系统的运行效率太低，所以，通常是将好多个节点划分为一个区，用分区的方式来实现域名系统，如下图：</p>
<p><img src="https://my-cos-1254464911.cos.ap-guangzhou.myqcloud.com/DNS-protocol/DNS-partition.png" alt="DNS分区"></p>
<p>其中，(a)是abc这个公司只设置了一个分区的样子，(b)是abc公司设置了两个分区的样子，这两个区分别为<code>abc.com</code>和<code>y.abc.com</code>，这两个区对应了两个<strong>权限域名服务器</strong>（后面还会提到）。下图可以看出域名服务器的层次结构：</p>
<p><img src="https://my-cos-1254464911.cos.ap-guangzhou.myqcloud.com/DNS-protocol/hierarchy-of-domain-name-servers.png" alt="域名服务器的层次结构"></p>
<p>由上图可以看出，根据域名服务器起的作用，可以把域名服务器分为四种不同的类型：</p>
<ul>
<li><p>根域名服务器</p>
<p>  根域名服务器对应的是域名树中的根节点，是最高层次的域名服务器，但是并不是只有一台，而是有好多台，总共有13个不同IP地址的根域名服务器，用a到m来表示，如<code>a.rootservers.net</code>，每个IP地址对应一套装置，一套装置在世界不同地点安装了服务器，总之，数量很多，当访问根域名服务器时，往往就是由路由器找到最近的根域名服务器访问。</p>
<p>  一般来说，每台根域名服务器都知道所有的顶级域名服务器的域名以及IP地址，但往往也只知道这些，所以访问根域名服务器一般只能得到顶级域名服务器的IP地址，而不能直接知晓你要找的具体服务器的IP。一般来讲，如果要通过互联网解析域名，本地域名服务器首先访问的就是根域名服务器，下面还会讲到。</p>
</li>
<li><p>顶级域名服务器</p>
<p>  顶级域名服务器负责管理在顶级域名下的所有二级域名，例如<code>cn</code>是顶级域名服务器，管理<code>edu</code>、<code>gov</code>等二级域名，当接收到查询请求时，要么给出最终结果（即具体IP地址），要么给出下一步应该访问的权限域名服务器的IP地址。</p>
</li>
<li><p>权限域名服务器</p>
<p>  权限域名服务器上面已经提到过一次了，就是每个域名分区对应一个服务器就叫做权限域名服务器。当接收到DNS查询请求时，如果可以给出具体的IP地址就给出（例如前面的<code>abc.com</code>可以给出<code>v.x.abc.com</code>的IP地址，所以直接返回），如果不可以，就把下一步要访问的权限域名服务器的IP地址返回（如<code>abc.com</code>不能给出<code>t.y.abc.com</code>的IP，就会把<code>y.abc.com</code>这个权限域名服务器的IP地址返回）。</p>
</li>
<li><p>本地域名服务器</p>
<p>  可能有人已经发现了，上面的图中并没有本地域名服务器这一层级结构，这是因为本地域名服务器（有时候也叫作首选域名服务器或者默认域名服务器）不属于域名树的层次结构，但是相当重要。当一台计算机要进行DNS查询的时候，就会将查询的请求发给本地域名服务器。</p>
<p>  一般来说，一个互联网服务提供商（ISP）或者是一个大学（甚至是一个系）都有一个本地域名服务器，也就是说，当你再学校内使用校园网时，你的本地域名服务器并不是指你自己的电脑，因为你的系或者你的学校，都共用一个本地域名服务器。</p>
</li>
</ul>
<h4 id="3-域名解析过程"><a href="#3-域名解析过程" class="headerlink" title="3. 域名解析过程"></a>3. 域名解析过程</h4><p>在了解了上面的域名结构以及域名服务器之后，我们来看一下域名的解析过程，总的来讲，主机向本地域名服务器的域名查询一般采用递归查询，而本地域名服务器向根域名服务器的查询一般采用迭代查询。</p>
<p>概念其实很简单，递归查询就是如果主机向本地域名服务器查询IP，本地域名服务器不知道IP地址，这是本地域名服务器就代替主机称为DNS客户，向根域名服务器进行下一步查询。</p>
<p>而迭代查询就是，在本地域名服务器向根域名服务器查询时，根域名服务器要么给出最终的IP地址，要么给出下一步本地域名服务器要访问的顶级域名服务器的IP地址，之后本地域名服务器再去访问相应的顶级域名服务器（而不是让根域名服务器代替本地域名服务器去进行下一步查询）。</p>
<p>简单来说，递归查询返回具体IP地址或者报错没找到，迭代查询返回具体IP地址或者返回下一步的IP地址。如下图：</p>
<p><img src="https://my-cos-1254464911.cos.ap-guangzhou.myqcloud.com/DNS-protocol/domain-name-iterative-query.jpg" alt="域名迭代查询"></p>
<p>当然，我们也可以指定查询方式让查询过程全程使用递归查询，如下图：</p>
<p><img src="https://my-cos-1254464911.cos.ap-guangzhou.myqcloud.com/DNS-protocol/domain-name-recursive-query.jpg" alt="域名递归查询"></p>
<p>下面以一个例子说说明在无缓存的情况下（下面会谈到缓存），通过DNS来查询域名的步骤，假设域名为<code>m.xyz.com</code>的主机想要查询<code>y.abc.com</code>这个域名对应的IP地址，那么他就会按照域名查询方式1（上图）中的方式进行查询：</p>
<ol>
<li>主机<code>m.xyz.com</code>先向本地域名服务器<code>dns.xyz.com</code>进行递归查询。</li>
<li>本地域名服务器无法给出IP地址，所以本地域名服务器向（离自己最近的）根域名服务器查询，这是的查询已经变为了迭代查询。</li>
<li>根域名服务器根据本地域名服务器发送的报文，知道了下一步应该查询的是哪个顶级域名服务器，这时根域名服务器告诉本地域名服务器，下一步应该查询的顶级域名服务器<code>dns.com</code>的IP地址。</li>
<li>本地域名服务器向顶级域名服务器<code>dns.com</code>发送请求查询。</li>
<li>顶级域名服务器<code>dns.com</code>告诉本地域名服务器，下一步应该查询的权限域名服务器<code>dns.abc.com</code>的IP地址。</li>
<li>本地域名服务器向权限域名服务器<code>dns.abc.com</code>发送请求查询。</li>
<li>权限域名服务器<code>dns.abc.com</code>告诉本地域名服务器想要查询的域名<code>y.abc.com</code>的IP地址。</li>
<li>本地域名服务器在拿到IP地址后，将IP地址返回给主机<code>m.xyz.com</code>。<br>这就是域名查询的具体过程，因为DNS协议的基于UDP协议，所以上述8个步骤中，总共使用了8个UDP报文。</li>
</ol>
<p>上面提到，这是在没有缓存的情况下的DNS查询，实际上，为了提高查询的效率以及降低根域名服务器的负荷，一般来说域名服务器中都有高速缓存，用来记录最近查询过的域名的缓存，如果在查询域名时，有想要的域名到IP的映射缓存，并且缓存没有过期，那么就直接将缓存中域名映射的IP地址返回，省去了接下来的查询。</p>
<p>只有在没有缓存或者缓存过期了才会进行下一步的查询。实际上，不知域名服务器有缓存，每台计算机甚至浏览器都会对域名到IP的映射进行缓存，这样一来大大加快的DNS的查询速度。</p>
<p>上面这些就是DNS协议的大概了，如果觉得有哪里写的不对的，还请多多指教。</p>
<p>参考书籍：《计算机网络》谢希仁</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/06/27/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/27/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Git 常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-27 21:11:06" itemprop="dateCreated datePublished" datetime="2021-06-27T21:11:06+08:00">2021-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>以下基本概念相关的描述引自菜鸟教程：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-workspace-index-repo.html">Git 工作区、暂存区和版本库 | 菜鸟教程</a></p>
</blockquote>
<ul>
<li>工作区：就是你在电脑里能看到的目录</li>
<li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）</li>
<li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="https://static.youfindme.cn/blog/git_command/git_structure.jpg" alt="工作区、暂存区和版本库之间的关系"></p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li>
<li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（<code>git commit</code>）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<p><strong>为方便下面的描述，简单区分一下工作区、暂存区和版本库：</strong></p>
<ul>
<li><strong>工作区：本地的项目中没有通过 <code>git add</code> 添加到暂存区的文件</strong></li>
<li><strong>暂存区：本地的项目中通过 <code>git add</code> 添加到暂存区的文件</strong></li>
<li><strong>版本库：本地的项目中通过 <code>git commit</code> 添加到提交历史中的文件</strong></li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><code>git init</code>: 初始化一个本地git仓库repository</li>
<li><code>git status</code>: 查看本地仓库的状态</li>
<li><code>add</code><ul>
<li><code>git add &lt;file&gt;</code>: 将工作区下的某个文件的修改加到暂存区（stage）</li>
<li><code>git add .</code>: 将工作区下的当前目录下的修改加到暂存区（stage）</li>
<li><code>git add -A</code>: 将工作区下的所有目录下的修改加到暂存区（stage）</li>
<li><code>git add -u</code>: 将工作区下的所有目录下的修改加到暂存区（stage），但是不包括新添加的文件</li>
</ul>
</li>
<li><code>commit</code><ul>
<li><code>git commit -m &quot;&lt;some message&gt;&quot;</code>: 将暂存区（stage）提交到版本库，并写一些描述信息</li>
<li><code>git commit -m &quot;&lt;some message&gt;&quot; --no-verify</code>: 将暂存区（stage）提交到版本库，并写一些描述信息，但是不会执行 <code>pre-commit</code> 钩子（<strong>慎用</strong>，通常在pre-commit钩子中做一些代码检查，如果不执行pre-commit钩子，那么就会跳过代码检查，这样就可能会导致一些问题）</li>
<li><code>git commit</code>: 将暂存区（stage）提交到版本库，会弹出一个编辑器，让你输入本次提交的说明，编辑器是git配置的默认编辑器，一般是vim</li>
<li><code>git commit --no-verify</code>: 同上，只不过不会执行 <code>pre-commit</code> 钩子（<strong>慎用</strong>）</li>
</ul>
</li>
<li><code>push</code><ul>
<li><code>git push</code>: 将本地的最新改动记录，推送到远端的和本地分支同名的分支下（前提是远端有同名分支）</li>
<li><code>git push -f</code>: 强制推送，即使远端有比本地更新的提交记录，也会强制推送（<strong>慎用</strong>，可能会导致远端的提交记录丢失，执行这个之前务必知道自己在做什么）</li>
</ul>
</li>
</ul>
<h2 id="clone-命令"><a href="#clone-命令" class="headerlink" title="clone 命令"></a><code>clone</code> 命令</h2><ul>
<li><code>git clone git@server-name:path/repo-name.git</code>: 从远程仓库clone一个仓库到本地，同时会关联到远程仓库</li>
<li><code>git clone -b &lt;branchName&gt; git@server-name:path/repo-name.git</code>: 从远程clone指定分支到本地</li>
</ul>
<h2 id="merge-amp-rebase-命令"><a href="#merge-amp-rebase-命令" class="headerlink" title="merge &amp; rebase 命令"></a><code>merge</code> &amp; <code>rebase</code> 命令</h2><ul>
<li><code>merge</code><ul>
<li><code>git merge &lt;branchName&gt;</code>: 将指定branchName的分支合并到当前分支</li>
<li><code>git merge --no-ff</code>: 表示在系统采取 <code>fast-forward</code> 时让系统采用普通合并方式，而不是采用快速合并，普通合并会多一次commit，这样在以后查看时能够看到合并历史，而 <code>fast-forward</code> 合并则看不到曾经做过的合并</li>
</ul>
</li>
<li><code>rebase</code><ul>
<li><code>git rebase &lt;branchName&gt;</code>: 将当前分支的改动，rebase到branchName分支上，这样就可以保证当前分支的提交记录是线性的，而不是分叉的，这样在以后查看提交记录时会更清晰。但是如果有冲突，可能需要多次解决冲突，比较麻烦</li>
<li><code>git rebase -i</code>: 交互式rebase，可以在rebase的过程中，对提交记录进行修改，比如说合并提交记录、删除提交记录等</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangnan9279/article/details/79287631">Git rebase详细解析_GhostStories的博客-CSDN博客_git rebase 参数</a></li>
</ul>
</li>
</ul>
<h2 id="fetch-amp-pull-命令"><a href="#fetch-amp-pull-命令" class="headerlink" title="fetch &amp; pull 命令"></a><code>fetch</code> &amp; <code>pull</code> 命令</h2><ul>
<li><code>git fetch</code>: 从远程取回所有分支的更新（但不会自动合并）</li>
<li><code>git fetch origin &lt;branchName&gt;</code>: 从远程 <code>origin</code> （<code>origin</code> 换成其他名字，则从对应的远程仓库获取更新）取回branchName分支的更新（但不会自动合并）</li>
<li><code>git pull</code>: 从远程拉取最新的修改到本地并合并，如果有冲突则需要在本地解决。<code>git pull</code> 相当于 <code>git fetch</code> 加上 <code>git merge</code></li>
</ul>
<h2 id="push-命令"><a href="#push-命令" class="headerlink" title="push 命令"></a><code>push</code> 命令</h2><ul>
<li><code>git push -u origin master</code>: 第一次将本地的repository的master分支推送到远程，以后再push就不用加 <code>-u</code> 了，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20019419/answer/13687984">关于-u的用法</a></li>
<li><code>git push origin &lt;branchName&gt;</code>: 将分支推送到远程仓库 <code>origin</code> 的branch分支上，如果远程仓库 <code>origin</code> 中没有叫做 <code>branchName</code> 的分支，则会创建一个</li>
</ul>
<p>如果 <code>git push</code> 省略了远程仓库名则默认会将本地记录推送到名为 <code>origin</code> 的远程仓库上，且目标推送分支是 <code>origin</code> 远程仓库中和本地仓库分支同名的分支</p>
<h2 id="stash-命令"><a href="#stash-命令" class="headerlink" title="stash 命令"></a><code>stash</code> 命令</h2><ul>
<li><code>git stash</code>: 把当前工作现场先存起来（不是add也不是commit），可以暂时去做其他事，之后（主要应用场景是当前手头工作没做完不能commit，但是又有紧急的bug需要切换到其他分支上去修复）</li>
<li><code>git stash list</code>: 查看所有存起来的工作现场</li>
<li><code>git stash pop</code>: 将stash list中，最顶部的工作现场恢复，并将list顶部的给删除掉</li>
<li><code>git stash apply &lt;指定stash&gt;</code>: 将指定的工作现场恢复，但是在stash list当中并不删除指定stash</li>
<li><code>git stash clear</code>: 情况stash list（<strong>慎用</strong>）</li>
</ul>
<h2 id="checkout-命令"><a href="#checkout-命令" class="headerlink" title="checkout 命令"></a><code>checkout</code> 命令</h2><ul>
<li><code>git checkout -- &lt;file&gt;</code>: 将工作区中file文件的修改撤销，包括把删除的file复原（在添加到暂存区之前才有效，如果将工作区文件的修改add到了暂存区，那么再使用这个命令就会无效，这时应该先把暂存区的修改撤销，再使用这个命令）</li>
<li><code>git checkout &lt;branchName&gt;</code>: 切换到branchName分支上</li>
<li><code>git checkout -b &lt;branchName&gt;</code>: 是上面 <code>git branch &lt;branchName&gt;</code> 和 <code>git checkout &lt;branchName&gt;</code> 两条命令合并之后的简写，即创建一个名为name的分支并切换到那个分支</li>
<li><code>git checkout &lt;commit_id&gt;</code>: 切换到指定的commit（可以是当前分支也可以是其他分支）</li>
</ul>
<h2 id="reset-命令"><a href="#reset-命令" class="headerlink" title="reset 命令"></a><code>reset</code> 命令</h2><ul>
<li><code>git reset --hard HEAD^</code> / <code>git reset --hard HEAD~1</code>: 将git的HEAD指针指向版本库中上一个版本，同时也会把整个项目的文件回退到上一个版本。这个会把最近的一个commit以及对应的改动完全丢弃，不再保留。如需要多回退几个版本，可以使用 <code>HEAD~n</code>，<code>n</code> 表示回退几个版本</li>
<li><code>git reset --hard &lt;commit_id&gt;</code>: 将git的HEAD指针指向版本库中某个commit指定的版本，同时也会把整个项目的文件回退到这个版本。这个会把commit_id之后的所有commit以及对应的改动完全丢弃，不再保留</li>
<li><code>git reset --soft HEAD^</code> / <code>git reset --soft HEAD~1</code>: 将将git的HEAD指针指向版本库中上一个版本，但是不会修项目的文件，会把上一个版本的改动，保留到git暂存区（不会修改工作区，只改暂存区）。如果当前暂存区有内容，会将上一个版本的改动和暂存区的内容合并到暂存区</li>
<li><code>git reset --soft &lt;commit_id&gt;</code>:  将将git的HEAD指针指向版本库中某个commit指定的版本，但是不会修项目的文件，会把commit_id之后的所有commit对应的改动，保留到git暂存区（不会修改工作区，只改暂存区）。如果当前暂存区有内容，会将commit_id之后的所有commit对应的改动和暂存区的内容合并到暂存区</li>
<li><code>git reset --mixed HEAD^</code> / <code>git reset --mixed HEAD~1</code> / <code>git reset HEAD^</code> / <code>git reset HEAD~1</code>: 将git的HEAD指针指向版本库中上一个版本，但是不会修项目的文件，会把上一个版本的改动，保留到git工作区，同时也会将暂存区的内容清空。如果当前暂存区有内容，会将上一个版本的改动和暂存区的内容合并到工作区</li>
<li><code>git reset --mixed &lt;commit_id&gt;</code> / <code>git reset &lt;commit_id&gt;</code>: 将git的HEAD指针指向版本库中某个commit指定的版本，但是不会修项目的文件，会把commit_id之后的所有commit对应的改动，保留到git工作区，同时也会将暂存区的内容清空。如果当前暂存区有内容，会将commit_id之后的所有commit对应的改动和暂存区的内容合并到工作区</li>
</ul>
<p>其中，<code>--hard</code>、<code>--soft</code>、<code>--mixed</code>是三种不同的模式，<code>--mixed</code>是默认的模式，如果不指定模式，那么就是<code>--mixed</code>模式。</p>
<p>可以理解为 <code>git reset --hard</code> 通常用于丢弃最近的提交，而另外两个通常用于修改最近的提交。</p>
<h2 id="revert-命令"><a href="#revert-命令" class="headerlink" title="revert 命令"></a><code>revert</code> 命令</h2><ul>
<li><code>git revert &lt;commit_id&gt;</code>: 撤销提交记录中间的某次commit，同时会生成一条新的commit记录</li>
<li><code>git revert -m &lt;commit_id&gt;</code>: 撤销提交记录中间的某次commit，同时会生成一条新的commit记录（这次commit是别的分支合并过来的）</li>
<li><code>git revert --no-commit commit_id1..commit_id2</code>: 撤销提交记录中间的几个连续的commit（注意这是一个左开右闭区间，即不包括 <code>commit_id1</code>，但包括 <code>commit_id2</code>）</li>
</ul>
<h2 id="cherry-pick-命令"><a href="#cherry-pick-命令" class="headerlink" title="cherry-pick 命令"></a><code>cherry-pick</code> 命令</h2><ul>
<li><code>git cherry-pick &lt;commit_id&gt;</code>: 将另一个分支上的指定提交记录，摘抄到当前分支</li>
<li><code>git cherry-pick &lt;commit_id1&gt;..&lt;commit_id2&gt;</code>: 将另一个分支上的从<code>commit_id1</code>到<code>commit_id2</code>之间的提交记录摘抄到到当前分支</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/w958796636/article/details/78492017">git 场景——从一个分支cherry-pick一个或多个commit到另一个分支</a></p>
<h2 id="branch-命令"><a href="#branch-命令" class="headerlink" title="branch 命令"></a><code>branch</code> 命令</h2><ul>
<li><code>git branch</code>: 查看本地所有分支，当前所在分支前面有一个 <code>*</code> 号</li>
<li><code>git branch -r</code>: 查看远程所有分支</li>
<li><code>git branch -a</code>: 查看本地和远程所有分支</li>
<li><code>git branch -d &lt;name&gt;</code>: 删除名为name的分支</li>
<li><code>git branch -D &lt;name&gt;</code>: 强行删除名为name的分支，用 <code>-d</code> 删除的话，如果name分支没有被合并就无法删除，那么就要用 <code>-D</code></li>
<li><code>git branch &lt;name&gt;</code>: 创建一个名为name的分支</li>
</ul>
<h2 id="log-命令"><a href="#log-命令" class="headerlink" title="log 命令"></a><code>log</code> 命令</h2><ul>
<li><code>git log</code>: 查看提交的日志信息（按q退出）</li>
<li><code>git log --pretty=oneline</code>: 查看只有一行的简略日志信息</li>
<li><code>git log --graph</code>: 查看日志信息的图示信息</li>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code>: 查看日志信息的图示信息，且只有一行的简略日志信息，且commit id只显示前几位</li>
</ul>
<h2 id="remote-命令"><a href="#remote-命令" class="headerlink" title="remote 命令"></a><code>remote</code> 命令</h2><ul>
<li><code>git remote</code>: 查看远程仓库信息，远程库默认名字是 <code>origin</code></li>
<li><code>git remote -v</code>: 查看更详细的远程仓库信息</li>
<li><code>git remote add origin git@server-name:path/repo-name.git</code>: 关联一个远程库，或者说添加一个远程库（一个本地仓库可以有多个远程库），在这里添加的远程仓库名为 <code>origin</code></li>
<li><code>git remote remove origin</code>: 删除已添加的远程仓库地址，这里删除的是名为 <code>origin</code> 的远程仓库</li>
<li><code>git remote set-url origin https://xxxxx.xxx/repo-name.git</code>: 更改远程仓库 <code>origin</code> 的url，比如说github项目地址改了，或者运维配置的gitlab域名变更了，可以用这个修改</li>
<li><code>git remote rename origin old-origin</code>: 重命名远程仓库，将远程仓库 <code>origin</code> 重命名为 <code>old-origin</code></li>
</ul>
<h2 id="diff-命令"><a href="#diff-命令" class="headerlink" title="diff 命令"></a><code>diff</code> 命令</h2><ul>
<li><code>git diff &lt;filename&gt;</code>: 不带参数就是比较工作区和暂存区中filename文件的不同</li>
<li><code>git diff --cached &lt;filename&gt;</code>: 比较暂存区和版本库中filename文件的不同</li>
<li><code>git diff HEAD &lt;filename&gt;</code>: 比较工作区和版本库中filename文件的不同</li>
</ul>
<h2 id="rev-parse-命令"><a href="#rev-parse-命令" class="headerlink" title="rev-parse 命令"></a><code>rev-parse</code> 命令</h2><ul>
<li><code>git rev-parse HEAD</code>: 获取当前分支的commit id</li>
<li><code>git rev-parse --short HEAD</code>: 获取当前分支的commit id的前几位</li>
<li><code>git rev-parse --abbrev-ref HEAD</code>: 获取当前分支名</li>
<li><code>git rev-parse --symbolic --branches</code>: 获取所有分支的名字</li>
<li><code>git rev-parse --show-toplevel</code>: 获取当前git仓库的根目录的绝对路径</li>
<li><code>git rev-parse --git-dir</code>: 获取当前git仓库的 <code>.git</code> 目录</li>
<li><code>git rev-parse --show-prefix</code>: 获取当前目录相对于git仓库根目录的相对路径</li>
<li><code>git rev-parse branchName</code>: 获取本地分支 <code>branchName</code> 的commit id</li>
<li><code>git rev-parse origin/branchName</code>: 获取远程分支 <code>branchName</code> 的commit id</li>
<li><code>git rev-parse origin/branchName^&#123;commit&#125;</code>: 和上面一样，获取远程分支 <code>branchName</code> 的commit id</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-首次关联本地仓库到远端空仓库"><a href="#1-首次关联本地仓库到远端空仓库" class="headerlink" title="1. 首次关联本地仓库到远端空仓库"></a>1. 首次关联本地仓库到远端空仓库</h3><ol>
<li><code>git remote add origin git@server-name:path/repo-name.git</code>: 关联一个远程库</li>
<li><code>git push -u origin master</code>: 第一次将本地的repository的master分支推送到远程，以后再push就不用加 <code>-u</code> 了</li>
</ol>
<h3 id="2-push时其他人已经push了新的提交，被reject"><a href="#2-push时其他人已经push了新的提交，被reject" class="headerlink" title="2. push时其他人已经push了新的提交，被reject"></a>2. push时其他人已经push了新的提交，被reject</h3><p>如果多个人同时关联了远程库（多人协作时），在push的时候，发现有人已经向remote推送了他的提交，而你对同样的文件做了修改，那么在push的时候就会报错rejected推送失败，因为有冲突，所以这时候应该git pull拉取最新的提交并（自动地）在本地合并，产生冲突，然后本地解决冲突之后再add、commit，再push</p>
<h3 id="3-在本地新建一个分支再push到远端"><a href="#3-在本地新建一个分支再push到远端" class="headerlink" title="3. 在本地新建一个分支再push到远端"></a>3. 在本地新建一个分支再push到远端</h3><ol>
<li><code>git checkout -b newBranch</code></li>
<li><code>git push origin newBranch</code></li>
</ol>
<h3 id="4-对于已经添加到的-gitignore文件，仍然会被trace到的解决方法"><a href="#4-对于已经添加到的-gitignore文件，仍然会被trace到的解决方法" class="headerlink" title="4. 对于已经添加到的.gitignore文件，仍然会被trace到的解决方法"></a>4. 对于已经添加到的.gitignore文件，仍然会被trace到的解决方法</h3><p><code>git rm --cached dir_name/file_name</code></p>
<p>原因是添加了 <code>.gitignore</code> 忽略这些路径后， 由于这个路径是已经增加到过仓库管理中，所以尽管已经在 ignore 列表里，依然 会被 git trace 到每个文件的变化。这时只需删除已缓存的trace就可以了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冰河</p>
  <div class="site-description" itemprop="description">冰河的个人网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冰河</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
