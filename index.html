<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"youfindme.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="冰河的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="冰河">
<meta property="og:url" content="https://youfindme.top/index.html">
<meta property="og:site_name" content="冰河">
<meta property="og:description" content="冰河的个人网站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冰河">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://youfindme.top/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冰河</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冰河</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冰河</p>
  <div class="site-description" itemprop="description">冰河的个人网站</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2025/11/19/AI%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%83%91%E7%B3%BB%E5%88%97-RAG/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/19/AI%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%83%91%E7%B3%BB%E5%88%97-RAG/" class="post-title-link" itemprop="url">AI概念解惑系列 - RAG</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-19 11:28:44 / 修改时间：12:13:46" itemprop="dateCreated datePublished" datetime="2025-11-19T11:28:44+08:00">2025-11-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>随着最近几年AI在各个领域大放异彩，作为一个前端开发，我也对AI里的各种技术概念产生了浓厚的兴趣，希望能详细了解这些技术概念和背后的原理后，找寻和前端结合的一些思路。今天我们就来一起了解下AI领域常用到的一个技术——<strong>RAG（Retrieval-Augmented Generation）</strong>，检索增强生成。</p>
<h2 id="一、-开始之前"><a href="#一、-开始之前" class="headerlink" title="一、 开始之前"></a>一、 开始之前</h2><p>在开始介绍RAG之前，我们先来简单回顾一下大语言模型LLM的原理。</p>
<p>LLM通过预训练，让模型学习了全网公开的知识（网页、书籍、论文、代码等等），得到一堆“参数”，之后根据用户的输入来不断地预测下一个token应该是什么，最终得到输出。</p>
<p>这种训练好的模型，在通用领域有着比较好的表现。但是根据LLM的原理，我们也能发现它的一些不足：</p>
<ul>
<li>“<strong>预训练</strong>”：由于是使用了旧的数据进行的训练，对于在训练之后产生新信息，LLM无法回答</li>
<li>“<strong>公开的知识</strong>”：LLM使用了公开的知识训练，对于一些非公开的内容，或者专业数据，LLM同样无法回答</li>
<li>“<strong>预测</strong>”：因为LLM本质上是一个“看前文、猜下文”的大规模统计生成器，所以对于它不知道的信息，在回答时往往会“胡说八道”，也就是常说的Hallucination，“<strong>幻觉</strong>”</li>
</ul>
<p>对于普通用户一些不要求实时性的通用性问题来说，上面这些不是什么大问题，但是一旦涉及到<strong>实时性、专业数据、企业内私有数据</strong>时，上面的问题就会严重影响用户体验。</p>
<p>为了解决这些问题，通常有下面两个手段：</p>
<ol>
<li>微调大模型</li>
<li>手动给LLM添加额外知识</li>
</ol>
<h2 id="二、-微调-vs-外挂知识库"><a href="#二、-微调-vs-外挂知识库" class="headerlink" title="二、 微调 vs 外挂知识库"></a>二、 微调 vs 外挂知识库</h2><h3 id="1-微调Fine-tuning"><a href="#1-微调Fine-tuning" class="headerlink" title="1. 微调Fine-tuning"></a>1. 微调Fine-tuning</h3><p>所谓<strong>微调（Fine-tuning）</strong>，就是在预训练模型的基础上，使用特定任务的数据（如私有数据、专业领域知识、最新的信息等）进行进一步训练，让模型在特定领域表现更好。</p>
<p>举个比较形象的例子，通过预训练得到的大模型，就是学习了小学到高中的通识教育的知识，学会语言、数学、常识、逻辑思维，知识面广但不够专业。</p>
<p>而微调阶段（Fine-tuning）类似于专业教育，就好像学习了专业领域课程、成为某个领域的专家。</p>
<p>即“<strong>通用模型 + 专业数据 + 针对性训练 = 专业模型</strong>”：</p>
<ul>
<li>GPT + 代码数据 + 代码任务训练 = CodeGPT</li>
<li>GPT + 医学数据 + 医学任务训练 = MedicalGPT</li>
<li>GPT + 法律数据 + 法律任务训练 = LegalGPT</li>
</ul>
<h3 id="2-外挂知识库"><a href="#2-外挂知识库" class="headerlink" title="2. 外挂知识库"></a>2. 外挂知识库</h3><p>在和LLM交互时，我们可以通过一些特殊手段，从外部知识库检索相关信息提供给LLM，相当于给AI配个”外挂知识库”，让它可以获取到专业领域知识、私有数据、实时信息等等。</p>
<p>而RAG就是比较常用的手段。</p>
<h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h3><p>对比这两个不难发现，微调是内化知识到了模型参数中，最终的效果肯定是稍微好一些的。</p>
<p>但是考虑到微调下面这些点：</p>
<ul>
<li>需要<strong>大量的标注训练数据</strong>（需要对文档等进行数据清洗、标注等）</li>
<li><strong>较高的训练成本</strong>（比如训练需要较高的算力，有不小的经济成本和时间成本）</li>
<li><strong>较高的实现难度</strong>（需要AI领域的专业知识）</li>
<li><strong>无法保持数据是最新的</strong>（内化的知识需要重新训练才能更新）</li>
</ul>
<p>对于个人或者中小型企业来说，通过RAG外挂知识库是一个更合适的选择：</p>
<ul>
<li>只需要<strong>结构化的文档</strong></li>
<li><strong>不需要训练</strong></li>
<li><strong>较低的实现难度</strong>（大多是工程方面的实现）</li>
<li><strong>知识库更新很方便</strong>（不需要重新训练，只需要重新向量化即可）</li>
</ul>
<h2 id="三、-RAG"><a href="#三、-RAG" class="headerlink" title="三、 RAG"></a>三、 RAG</h2><p>那我们来看下RAG是什么，所谓<strong>RAG（Retrieval-Augmented Generation）</strong>检索增强生成，就是：</p>
<ol>
<li><strong>检索(Retrieval)</strong>: 从外部知识库中检索相关信息</li>
<li><strong>增强(Augmented)</strong>: 将检索到的信息作为上下文</li>
<li><strong>生成(Generation)</strong>: 大模型基于检索内容生成回答</li>
</ol>
<p>它的本质就是上面说的给LLM外挂一个知识库，而它的工作过程，简单来讲就是下面这样：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/rag_flow_simple.png" alt="工作流程"></p>
<p>而一个RAG完整工程的架构示意图，则如下所示：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/rag_arc.png" alt="架构示意图"></p>
<p>看不懂？没关系，我们一步一步来讲解。</p>
<h2 id="四、-向量和向量化"><a href="#四、-向量和向量化" class="headerlink" title="四、 向量和向量化"></a>四、 向量和向量化</h2><p>首先，最基础的一个概念，什么是<strong>向量（Vector）</strong>和<strong>向量化（Vectorization/Embedding）</strong>。</p>
<h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F">向量</a>我们应该不陌生，我们最早应该在高中就学过了，就是一个同时具有数值和方向的量。相对应的，标量则只有数值，没有方向。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/vector.png" alt="向量"></p>
<p>向量通常用一个有序的数字数组来表示，比如：</p>
<ul>
<li>2维向量: [3, 4]，可以理解为一个有x轴和y轴的平面直角坐标系，从原点指向[3, 4]这个坐标点的一个向量</li>
<li>3维向量: [1, 2, 3]，可以理解为一个有x、y、z三个轴的空间直角坐标系，从原点执行[1, 2, 3]这个坐标点的一个向量</li>
<li>高维向量: [0.2, 0.5, 0.1, …, 0.8]，以此类推，在数学或者计算机领域，一个向量可以有任意多个维度， 比如有几百甚至上千维</li>
</ul>
<p>而在AI领域，向量是<strong>原始数据的数值化表示</strong>,用来捕捉语义信息，比如</p>
<ul>
<li>文本“苹果很好吃”，可以用这样一个向量表示：[0.12, 0.34, 0.89, …, 0.45]</li>
<li>图片🍎，可以用这样一个向量表示：[0.23, 0.67, 0.12, …, 0.91]</li>
</ul>
<p>而具体是怎么把一串文本或者图片转换为向量的，就是向量化所做的工作了。</p>
<h3 id="向量化（Vectorization-Embedding）"><a href="#向量化（Vectorization-Embedding）" class="headerlink" title="向量化（Vectorization/Embedding）"></a>向量化（Vectorization/Embedding）</h3><p>向量化，就是将非结构化原始数据(文本、图片、音频等)转换为向量的过程。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/embedding.png" alt="向量化"></p>
<p>而为了将一个非结构化数据，变为向量，我们首先需要给这个数据定义好它的<strong>维度</strong>。</p>
<p>世界上的所有数据，都可以根据它在某一项特点上的程度而打一个分，数值越高代表这个原始数据在这个特点上的特征越强烈。我们规定**数值的范围是[-1, 1]**，1代表完全符合这个特征，-1代表拥有完全相反的特征。</p>
<p>例如下面这个二维的向量空间：</p>
<ul>
<li>横坐标代表情感极性，越靠近1代表越正向的情感，越靠近-1代表越负向的情感</li>
<li>纵坐标代表内容类型，越靠近1代表越主观的观点评价，越靠近-1代表越客观的事实陈述</li>
</ul>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/vector_demo.png" alt="二维向量示例"></p>
<p>上面的几个原始文本数据里：</p>
<blockquote>
<ol>
<li>这部电影太精彩了，演员表演完美<ul>
<li>横轴（情感）：+0.9（强烈正面）</li>
<li>纵轴（内容类型）：+0.8（明显观点评价）</li>
<li>坐标：[0.9, 0.8]</li>
</ul>
</li>
<li>水的沸点是100摄氏度<ul>
<li>横轴（情感）：0.0（完全中性）</li>
<li>纵轴（内容类型）：-0.9（纯粹事实）</li>
<li>坐标：[0.0, -0.9]</li>
</ul>
</li>
<li>这个产品质量很差，完全不符合预期<ul>
<li>横轴（情感）：-0.8（明显负面）</li>
<li>纵轴（内容类型）：+0.7（个人评价）</li>
<li>坐标：[-0.8, 0.7]</li>
</ul>
</li>
<li>令人失望的是，数据显示销售额下降了20%”<ul>
<li>横轴（情感）：-0.6（负面情绪）</li>
<li>纵轴（内容类型）：-0.3（偏向事实但带有主观色彩）</li>
<li>坐标：[-0.6, -0.3]</li>
</ul>
</li>
<li>数据表明用户流失率高达30%<ul>
<li>横轴（情感）：-0.7（负面情绪）</li>
<li>纵轴（内容类型）：-0.8（事实陈述，且没有明显主观评价在里面）</li>
<li>坐标：[-0.7, -0.8]</li>
</ul>
</li>
<li>我们彩票中了500万<ul>
<li>横轴（情感）：+0.9（正面）</li>
<li>纵轴（内容类型）：-0.8（事实陈述，且没有明显主观评价在里面）</li>
<li>坐标：[0.9, -0.8]</li>
</ul>
</li>
</ol>
</blockquote>
<p>可以看到，在我们对原始的文本数据从不同维度打分后会出现</p>
<ul>
<li>相似文本会聚集：比如所有正面评价都会集中在第一象限</li>
<li>距离/夹角反映相似度：坐标距离/夹角越近，文本在情感和类型上越相似</li>
</ul>
<p>我们的例子里只有两个维度，而在实际应用中可能有几百上千个维度，每个维度代表不同特征，这样的话就可以得到一个高维的向量空间，在向量空间内可以体现出不同数据之间或近或远的关系。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/vector_space.png" alt="向量空间"></p>
<p>另外，向量化除了叫做Vectorization外，也时候也会叫做<strong>Embedding，嵌入</strong>。这是因为向量化的过程，不只是将一个非结构化数据转为向量数字，更重要的是在这个过程中，将原始数据的语义信息嵌入到了向量空间中,使得语义关系被保留。</p>
<p>举个例子，通常情况下“国王King”和“王后Queen”常出现在相似的上下文中，“男人Man”和“女人Women”经常出现在相似的上下文中。</p>
<p>皇室词汇（King, Queen, Prince）之间的相似度整体大于它们与普通人词汇（Man, Women）的相似度。但是“国王King”和“男人Man”之间又有一些相似，“王后Queen”和“女人Women”之间有一些相似。</p>
<p>而将这四个单词进行向量化后，可能如下图所示：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/king_queen_man_woman.jpeg" alt="语义嵌入"></p>
<p>“国王King”、“王后Queen”、“男人Man”、“女人Women”的语义以及语义关系被嵌入了向量空间，做到了：</p>
<ol>
<li><strong>保持语义关系</strong>: 意思相近的词在向量空间中也靠近</li>
<li><strong>支持语义运算</strong>: 实现了<code>king - man + woman ≈ queen</code>这种神奇的运算</li>
</ol>
<h3 id="如何向量化"><a href="#如何向量化" class="headerlink" title="如何向量化"></a>如何向量化</h3><p>向量化是一个很复杂的过程，通常都是使用模型来实现的，即“<strong>Embedding models</strong>”，比如OpenAI的text-embedding-ada-002（需要API密钥访问），或者也可以使用一些开源的模型。</p>
<p>通常一个模型向量化数据后的维度越高，在后续进行信息检索时就会越精准。</p>
<p>其实除了调用模型这一步之外，完整的向量化过程还有一些其他工作要做，整个过程大概如下：</p>
<ol>
<li><p>读取文档</p>
<ul>
<li>PDF → 提取文本</li>
<li>Word → 提取文本  </li>
<li>Markdown → 读取内容</li>
<li>…</li>
</ul>
</li>
<li><p>清洗文本</p>
<ul>
<li>去除乱码</li>
<li>统一格式</li>
<li>去除无用内容（页眉页脚等）</li>
</ul>
</li>
<li><p>把文本进行切割，即<strong>文本分块 (Chunking)</strong></p>
<p> 为什么要分块？因为原始文档可能特别长，几千上万字，不方便后续进行向量化和检索。</p>
<p> 而分块的规则也有多种，比如根据标点符号分割，但是可能会存在有的块长度很长，有的又很短的情况；也可以根据固定长度分割，但是可能会导致一个完整的语义被切割到不同的块，每个块里的部分词变得毫无语义价值。</p>
<p> 所以RAG 分割一般用<strong>相同块大小</strong> + <strong>块重叠</strong>的办法，即所谓的<strong>滑动窗口分块</strong>，这和按长度截断来分割有点像。用这种办法，在一定程度上能避免文档原意被截断导致分出来的片段变得没价值，而且重叠块里有重复的信息，能让模型更好地理解文档内容。</p>
<p> <img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/text_chunking.png" alt="文本分块"></p>
</li>
<li><p>使用某个模型进行<strong>向量化（Embedding）</strong></p>
<ul>
<li><p>BGE-base-zh (中文效果好)</p>
</li>
<li><p>all-MiniLM-L6-v2 (英文，轻量)</p>
</li>
<li><p>text-embedding-ada-002 (OpenAI，需联网)</p>
<p> 假设选择BGE-base-zh (中文)，输出维度768维，模型大小约 400MB</p>
</li>
</ul>
</li>
<li><p>将向量化后的数据存入向量数据库，<strong>构建索引（Indexing）</strong></p>
<p> 普通的数据存储有数据库，那么向量的存储，也有专门的<strong>向量数据库</strong>，它是专为存储与检索高维嵌入向量而设计的数据库。支持基于相似度的检索并可结合元数据过滤，常用于语义搜索、推荐和 RAG。常见的数据库有：</p>
<ul>
<li>Chroma</li>
<li>Milvus</li>
<li>Qdrant</li>
</ul>
<p> 假设选择Chroma，那么它的每条记录的存储结构大概为：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;doc_1_chunk_1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;vector&quot;</span>: [<span class="number">0.23</span>, <span class="number">0.45</span>, ..., <span class="number">0.12</span>],  <span class="comment">// 768维向量</span></span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;source&quot;</span>: <span class="string">&quot;系统架构文档.pdf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chunk_index&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;第一章 系统架构...&quot;</span>  <span class="comment">// 原始文本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在做完上述的几个步骤之后，就算是完成了RAG的准备工作，即给LLM准备好了“外挂的知识库”。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/chunking_embedding.png" alt="知识库向量化过程"></p>
<h2 id="五、-RAG-R-Retrieval"><a href="#五、-RAG-R-Retrieval" class="headerlink" title="五、 RAG - R (Retrieval)"></a>五、 RAG - R (Retrieval)</h2><p>在准备好知识库之后，就可以和LLM进行问答了。那在提出问题后，如何让LLM知晓知识库的内容呢？答案就是RAG中的R，<strong>Retrieval检索</strong>。</p>
<p>在上面的知识库的准备过程中，我们使用了某个<strong>Embedding Model</strong>进行了知识库的向量化，那么在用户提出问题Query之后，也需要使用相同的<strong>Embedding Model</strong>，对用户的输入Query进行相同的向量化。</p>
<p>在都进行了向量化之后，就可以开始在向量数据库中检索了。</p>
<h3 id="相似度匹配"><a href="#相似度匹配" class="headerlink" title="相似度匹配"></a>相似度匹配</h3><p>和普通数据库基于关键字的检索不同，向量数据库是基于语义的检索。那怎么判断两个向量的语义是否接近，常见的衡量标准有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E6%80%A7">余弦相似度（Cosine Similarity）</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧氏L2（Euclidean L2/Square L2）</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E7%A7%AF">内积IP（Inner Product）</a></li>
</ul>
<p>这三个的具体定义和区别如下所示：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">公式</th>
<th align="left">定义</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">余弦相似度（Cosine Similarity）</td>
<td align="left"><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/cosine.png" alt="cosine"></td>
<td align="left">余弦相似度通过测量两个向量的夹角的余弦值来度量它们之间的相似性。<br/>仅反映方向一致性而与长度无关。</td>
<td align="left">当你关心“语义方向/形状”而不想被向量长度影响。<br/>典型应用场景有文本/图像嵌入检索、RAG 向量检索、语义去重、语义聚合。</td>
</tr>
<tr>
<td align="left">欧氏L2（Euclidean L2/Square L2）</td>
<td align="left"><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/L2.png" alt="L2"></td>
<td align="left">对两向量差的平方和开平方来度量几何距离（或向量自身长度），反映它们在空间中的直线距离。</td>
<td align="left">当你你需要真正的几何距离（度量性质、三角不等式）时。<br/>典型应用场景有K-means 聚类（目标是平方 L2）、最小二乘/MSE、几何邻近、部分 ANN 索引默认。</td>
</tr>
<tr>
<td align="left">内积（Inner Product/Dot Product）</td>
<td align="left"><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/inner_product.png" alt="Inner Product"></td>
<td align="left">将两个向量对应分量相乘后求和，得到同时受方向与长度影响的对齐程度（线性打分）。</td>
<td align="left">典型应用场景有最大内积搜索（MIPS）、推荐召回、因子分解机/embedding 打分。</td>
</tr>
</tbody></table>
<p>而在RAG语义搜索中，通常使用余弦相似度来计算两个向量是否相似，即通过跑男的两个向量的夹角，来判断两个向量的语义是否接近。还是以上面的这个图为例：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/vector_space_with_arrow.png" alt="向量空间夹角"></p>
<p>在这个向量空间里，Chicken和“鸡”的图片之间，向量的夹角很小，Dog和Wolf夹角很小，Banana和Apple夹角很小，Apple和Apple公司的Logo夹角很小。但是动物和水果之间的向量夹角就很大了，语义上相差很远。</p>
<blockquote>
<p>为什么用余弦相似度？<br>因为文本长度不重要（一句话和一段话可能表达同一意思），我们只关心语义方向是否一致。</p>
</blockquote>
<h3 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h3><p>在上面的图中，我们还看到了一个叫做Approximate Nearest Neighbor（ANN）近似最近邻检索算法的东西，这个和余弦相似度有什么关系呢？</p>
<p>简单来讲，ANN是“怎么快地找相似向量”（检索算法/索引），余弦相似度是“用什么标准衡量相似”（度量/打分）；在RAG中它们是配套使用的：用余弦相似度等度量定义“近邻”，再用ANN在大规模向量库上高效近似地找这些近邻。</p>
<h3 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h3><p>在完成检索后，通常会拿到Top-K最相关的几条数据。假设用户输入的问题是“如何配置HTTPS？”，那么过程大概如下：</p>
<ol>
<li><p>用户提问：“如何配置HTTPS？”</p>
</li>
<li><p>用户问题向量化，使用和文档向量化时相同的Embedding Model</p>
</li>
<li><p>得到Query的向量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_vector = [0.31, 0.48, 0.73, ..., 0.15]  // 768维</span><br></pre></td></tr></table></figure></li>
<li><p>在向量数据库中搜索</p>
</li>
<li><p>计算相似度<br> Chroma自动计算query_vector与所有向量数据库中向量的相似度</p>
<ul>
<li>向量1: [0.23, 0.45, …] → 相似度 0.45</li>
<li>向量2: [0.31, 0.52, …] → 相似度 0.89 ⭐</li>
<li>向量3: [0.12, 0.34, …] → 相似度 0.32</li>
<li>…</li>
<li>向量8234: [0.29, 0.51, …] → 相似度 0.91 ⭐⭐</li>
<li>向量8235: [0.35, 0.48, …] → 相似度 0.87 ⭐</li>
<li>…</li>
</ul>
</li>
<li><p>返回 Top-K 最相关的，假设我们设置 K=3，返回相似度最高的3个文本块</p>
<p> 结果：<br> a. (相似度 0.91) “4.2 HTTPS配置步骤：首先需要申请SSL证书…”<br> b. (相似度 0.89) “安全配置章节：HTTPS是保障网站安全的关键…”<br> c. (相似度 0.87) “第五章 证书管理：SSL/TLS证书的申请与部署…”</p>
</li>
</ol>
<h2 id="六、-RAG-A-Augmented"><a href="#六、-RAG-A-Augmented" class="headerlink" title="六、 RAG - A (Augmented)"></a>六、 RAG - A (Augmented)</h2><p>在得到Top-K相关的数据后，会把这几条结果的原始数据（每条数据的metadata中会有原始数据），和用户的Query，一起给LLM。为什么叫<strong>Augmented增强</strong>呢？</p>
<p>其实Augmented，就是一个Prompt Engineering提示词工程相关的工作，把Query和知识库中的相关数据，通过一些特殊的Prompt给到LLM，让LLM更好地回答问题。即通过清晰的结构 + 明确的指令，让模型知道该参考什么。例如，一个完整的增强后的提示词可能如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">你是一个技术支持助手。请根据以下参考资料回答用户问题。</span><br><span class="line"></span><br><span class="line"><span class="section">## 参考资料</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 文档1（相关度：91%）</span></span><br><span class="line">来源：网络安全配置手册.pdf</span><br><span class="line">内容：&#123;检索到的文本块1&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">### 文档2（相关度：89%）</span></span><br><span class="line">来源：服务器部署指南.pdf  </span><br><span class="line">内容：&#123;检索到的文本块2&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">### 文档3（相关度：87%）</span></span><br><span class="line">来源：证书管理文档.pdf</span><br><span class="line">内容：&#123;检索到的文本块3&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">## 回答要求</span></span><br><span class="line"><span class="bullet">1.</span> 必须基于上述参考资料</span><br><span class="line"><span class="bullet">2.</span> 如果资料不足，明确说明</span><br><span class="line"><span class="bullet">3.</span> 给出具体步骤</span><br><span class="line"><span class="bullet">4.</span> 标注信息来源</span><br><span class="line"></span><br><span class="line"><span class="section">## 用户问题</span></span><br><span class="line">如何配置HTTPS？</span><br><span class="line"></span><br><span class="line"><span class="section">## 你的回答</span></span><br></pre></td></tr></table></figure>

<h2 id="七、-RAG-G-Generation"><a href="#七、-RAG-G-Generation" class="headerlink" title="七、 RAG - G (Generation)"></a>七、 RAG - G (Generation)</h2><p>最后一步的Generation生成，就和平时使用LLM没什么区别了，LLM会根据提示词，来回答问题并按照指定的格式来输出内容。即：</p>
<ol>
<li>读取参考资料</li>
<li>理解用户问题</li>
<li>从资料中提取相关信息</li>
<li>组织成结构化回答</li>
<li>逐字生成输出</li>
</ol>
<p>以上面的问题为例，LLM最终生成的内容可能如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">根据参考资料，HTTPS配置步骤如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> <span class="strong">**申请SSL证书**</span></span><br><span class="line"><span class="bullet">   -</span> 可以通过Let&#x27;s Encrypt获取免费证书</span><br><span class="line"><span class="bullet">   -</span> 或购买商业证书（来源：证书管理文档）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**安装证书**</span></span><br><span class="line"></span><br><span class="line">   <span class="code">```bash</span></span><br><span class="line"><span class="code">   sudo cp cert.pem /etc/ssl/certs/</span></span><br><span class="line"><span class="code">   sudo cp key.pem /etc/ssl/private/</span></span><br><span class="line"><span class="code">   # ...</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>…</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">到这里，整个RAG的过程就算是结束了。</span><br><span class="line"></span><br><span class="line">![RAG流程](https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/query_with_vector.png)</span><br><span class="line"></span><br><span class="line">## 八、 完整RAG过程</span><br><span class="line"></span><br><span class="line">现在把上面几个步骤结合起来：</span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line">私有的知识库</span><br><span class="line">→ 文本分块Chunking</span><br><span class="line">→ 向量化Embedding</span><br><span class="line">→ 存储向量构建索引Indexing</span><br><span class="line">→ 用户提问Query</span><br><span class="line">→ 检索Retrieval</span><br><span class="line">→ 增强Augmented</span><br><span class="line">→ 生成Generation</span><br></pre></td></tr></table></figure>

<p>之后就得到了最开始的这个架构示意图：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/ai_rag/rag_arc.png" alt="架构示意图"></p>
<h2 id="九、-FAQ"><a href="#九、-FAQ" class="headerlink" title="九、 FAQ"></a>九、 FAQ</h2><p>下面是一些常见的问题：</p>
<ol>
<li><p><strong>RAG和传统的全文模糊搜索有什么区别？</strong></p>
<p> 传统的模糊搜索是关键词匹配的，比如</p>
<ul>
<li>用户搜索：”如何做蛋糕”</li>
<li>系统匹配：只能找到包含”蛋糕”字样的文档</li>
<li>结果：❌ 找不到”烘焙教程”、”甜点制作”等相关内容</li>
</ul>
<p> 而RAG最重要的一步就是把知识库做了向量化，是根据语义进行搜索的</p>
<ul>
<li>用户搜索：”如何做蛋糕”</li>
<li>系统理解：用户想学习烘焙技能</li>
<li>结果：✅ 找到”烘焙教程”、”甜点制作”、”面包制作”等相关内容</li>
</ul>
</li>
<li><p><strong>既然RAG里面还是要要通过构造提示词来吧参考资料放入提示词，那这和“直接在问题里把参考文档也输入进去”有什么区别？</strong></p>
<p> 这是因为我们要考虑成本和效率，一个知识库可能很大，成百上千个文档，数万数十万字，在实际操作的时候，要考虑到：</p>
<ul>
<li>Token限制：GPT-4 最多128K tokens ≈ 10万字，知识库无法塞进去</li>
<li>成本问题：即使能塞进去，128K tokens可能一次调用可能要几美元，成本激增</li>
<li>效率低下：LLM要读完所有无关内容</li>
<li>响应缓慢：处理海量文本需要很长时间<br>所以RAG中R检索这一步，就是在做过滤，它的本质就是把“无限大”的知识库变成“刚刚好”的上下文</li>
</ul>
</li>
<li><p><strong>在做向量化的时候，使用到的Embedding Model和LLM的Model有什么关联，为什么Embedding Model可以识别原始数据的语义？</strong></p>
<p> 简单来讲，<strong>Embedding模型</strong>和<strong>大语言模型</strong>，他们的基础架构是相似，但目标和训练方式不同。<br> 两者都基于Transformer架构，即：</p>
<ul>
<li>多头自注意力机制 (Multi-Head Attention)</li>
<li>前馈神经网络 (Feed-Forward)</li>
<li>层归一化 (Layer Normalization)</li>
<li>位置编码 (Positional Encoding)</li>
</ul>
<p> 但是</p>
<ul>
<li>Embedding Model：专门学习“理解和表示”，输出是向量</li>
<li>LLM：专门学习“生成文本”，输出是文字<br>完整的Transformer可以理解为Encoder编码器 + Decoder解码器。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>组成</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Transformer</td>
<td>Encoder编码器</td>
<td>理解输入，提取特征</td>
</tr>
<tr>
<td></td>
<td>Decoder解码器</td>
<td>生成输出，逐字生成</td>
</tr>
</tbody></table>
</li>
</ol>
<p>Embedding模型主要用的是Encoder，大语言模型主要用Decoder。而Embedding模型之所以比LLM小很多（如BGE-base-zh只有400M），主要是因为它的任务相对简单（映射到向量空间），不需要生成能力，也就不需要记忆海量知识和复杂的推理能力。</p>
<h2 id="十、-小结"><a href="#十、-小结" class="headerlink" title="十、 小结"></a>十、 小结</h2><p>这篇文章里，我们一起了解了一下RAG，以及这个技术如何通过外挂知识库解决大语言模型的三大局限：</p>
<ul>
<li>时效性不足（无法处理训练后新数据）</li>
<li>私有数据缺失</li>
<li>幻觉问题</li>
</ul>
<p>它的核心机制包含三个阶段：</p>
<ul>
<li>基于语义的向量化检索</li>
<li>结构化提示词增强上下文</li>
<li>以及大模型的知识整合生成</li>
</ul>
<p>这样就能实现低成本、易于维护的专业领域知识融合。相比微调方案， RAG无需训练标注数据且支持实时更新，适合用在企业知识库问答、实时政策解读这些场景里。</p>
<p>还有就是这篇文章（或者说《AI概念解惑》这个系列）更专注于概念解惑和原理解析，所以没有包含什么代码实操。</p>
<p>另外这也只是一个简单的原理解析，实际的RAG工程中可能还会包含很多其他的步骤，比如：</p>
<ul>
<li>文本分块时可能会同时使用语义分块+滑动窗口分块</li>
<li>Retrieval阶段可能不只是用向量相似度检索，会使用向量相似度+关键词（如BM25）的混合检索<ul>
<li>为什么？因为向量相似度只对语义敏感，对关键词不敏感，比如“Python 3.12”和“Python 3.13”的向量基本相同，但是用户可能是提问具体Python版本的问题</li>
</ul>
</li>
<li>在Retrieval检索后还可能存在一个Reranking重排的步骤<ul>
<li>对候选片段进行精细化打分和排序</li>
</ul>
</li>
<li>对于用户的问题Query可能会增加一个Query Rewriting<ul>
<li>是为了让问题更规范，比如从一个口语化的表达到一个规范化的表达</li>
</ul>
</li>
<li>使用多路检索（Multi-Path Retrieval）、上下文压缩（Context Compression）、自我反思（Self-Reflection）等手段进行优化</li>
<li>引入RAG评分机制，对RAG的输出结果进行评估</li>
<li>…</li>
</ul>
<p>感兴趣的可以自行搜索了解。</p>
<p>希望这篇文章能帮助你理解RAG的核心原理和应用场景，如果这篇文章有什么问题，辛苦大家指正。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7464756728685936694">检索增强生成技术RAG：向量化与大模型的结合</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7251903805980524581">被 AI 带火的向量数据库是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7554986681502957587#heading-5">大模型系列教程：什么是RAG（检索增强生成模型）技术</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7379831020495732773">RAG-检索增强生成</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7502279037948313651">第一章：RAG 开发入门与基础概念</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/647646322">文本 Embedding 基本概念和应用实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://weaviate.io/blog/distance-metrics-in-vector-search">Distance Metrics in Vector Search</a></li>
<li><a target="_blank" rel="noopener" href="https://datacream.substack.com/p/rag-explained-understanding-embeddings">RAG Explained: Understanding Embeddings, Similarity, and Retrieval</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2025/04/20/%E5%89%8D%E7%AB%AF%E8%BD%AE%E8%AF%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/20/%E5%89%8D%E7%AB%AF%E8%BD%AE%E8%AF%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" class="post-title-link" itemprop="url">前端轮询那些事儿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-20 21:15:12 / 修改时间：22:13:07" itemprop="dateCreated datePublished" datetime="2025-04-20T21:15:12+08:00">2025-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="当AI开始“说人话”——从大模型流式回答说起"><a href="#当AI开始“说人话”——从大模型流式回答说起" class="headerlink" title="当AI开始“说人话”——从大模型流式回答说起"></a>当AI开始“说人话”——从大模型流式回答说起</h2><p>深夜，你盯着屏幕上ChatGPT的回答逐字跳出，仿佛有个隐形的打字员在网络另一端敲击键盘，站在用户的角度，这种“流式回答”的魔法，好像让冰冷的技术有了一丝温度。那么站在开发者的视角，这种流式输出（即数据实时更新）的背后，是用的什么来实现的呢？</p>
<p>这就是我们今天要讨论的内容，前端轮询的那些事儿——如何优雅实现实时数据更新。</p>
<h2 id="一、-页面刷新：原始人的刀耕火种"><a href="#一、-页面刷新：原始人的刀耕火种" class="headerlink" title="一、 页面刷新：原始人的刀耕火种"></a>一、 页面刷新：原始人的刀耕火种</h2><p>在前端最原始的时代，网页的内容还是极其简单的门户网站、博客等，这个时候甚至Ajax技术都还没诞生，浏览器用户为了获取最新的网站内容，往往都是通过最原始的方式——刷新页面。通过浏览器刷新页面，重新加载整个页面内容，包括HTML/JS/CSS在内的所有资源都会被重新加载。</p>
<p>典型的例子包括新闻网站的最新内容更新以及博客留言板上的评论更新。在这种情况下，数据更新与“实时”的概念毫无关联，完全依赖于用户刷新页面时按F5键的速度。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/press_f5.jpeg" alt="按F5刷新"></p>
<p>虽然说这个时候也有一些非刷新页面的数据更新方式（比如通过隐藏的<code>iframe</code>等），但是这些都属于hack手段，不是标准化的技术，可以认为在Ajax普及之前，页面刷新是主要的数据更新方式。</p>
<h2 id="二、-短轮询：最直白的请求"><a href="#二、-短轮询：最直白的请求" class="headerlink" title="二、 短轮询：最直白的请求"></a>二、 短轮询：最直白的请求</h2><p>这种情况的改善是在2005年左右，随着Ajax（Asynchronous JavaScript and XML）的提出和兴起，这种通过异步发送HTTP请求，并使用这些服务端返回的内容更新页面相关部分，而无需重新加载整个页面的技术，让人们看到了数据实时更新的希望。</p>
<blockquote>
<p>当然这里指的是浏览器端，Ajax是浏览器端的一种请求技术，对于其他客户端比如桌面端，本身就支持异步请求。</p>
</blockquote>
<h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p>短轮询的技术原理很简单，就是前端设置一个定时器，每隔一定的时间（比如3s）就发送一次普通的HTTP请求到服务端，查询有没有最新的数据，服务端在收到请求后返回最新的数据结果或者通知前端无更新内容。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/short_polling.png" alt="短轮询"></p>
<p>浏览器端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 短轮询：定时发送请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shortPoll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/short-poll-api&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Short Polling:&#x27;</span>, data);</span><br><span class="line">  &#125;, <span class="number">3000</span>); <span class="comment">// 每3秒请求一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短轮询处理：直接返回当前数据</span></span><br><span class="line">app.get(<span class="string">&#x27;/short-poll-api&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hasNewData = checkDataUpdate(); <span class="comment">// 模拟检查数据更新</span></span><br><span class="line">  res.json(&#123; <span class="attr">data</span>: hasNewData ? <span class="string">&#x27;New Data&#x27;</span> : <span class="string">&#x27;No Data&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="协议视角"><a href="#协议视角" class="headerlink" title="协议视角"></a>协议视角</h3><p>从代码实现上来看，短轮询很简单，就是一次普通的接口请求，似乎没什么不妥。而从网络协议角度看就会发现短轮询的问题。</p>
<p>我们都知道HTTP是无状态的，HTTP基于的TCP是有状态的。每次发起短轮询的HTTP请求都会先建立TCP连接，而每个TCP连接在建立的时候都会经过三次握手，在短轮询结束之后会断开连接，又会经过四次挥手。</p>
<p>即每次请求都是一个独立的TCP连接，每次TCP连接的建立和断开，都是比较大的网络资源消耗，而且大多数情况下是没有数据更新的，无效请求数量较高。</p>
<p>即便是在Ajax技术诞生时HTTP/1.1中已经默认启用了<code>Connection: Keep-Alive</code>来开启TCP长连接，使多个HTTP请求可以复用一个TCP连接，并且可以通过pipelining技术来同时发生多条请求，但是在HTTP/1.1的时代，还是存在<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903853985366023">队头阻塞</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Connection_management_in_HTTP_1.x#%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87">单域名连接数量的限制</a>（单个域名限制连接数量6个）的问题，同时大量的用户的短轮询也会给服务端带来比较大的压力。</p>
<blockquote>
<p>更多HTTP/1.x连接管理的内容：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Connection_management_in_HTTP_1.x">HTTP/1.x 的连接管理 - HTTP | MDN</a></p>
</blockquote>
<h3 id="优缺点和应用场景"><a href="#优缺点和应用场景" class="headerlink" title="优缺点和应用场景"></a>优缺点和应用场景</h3><ul>
<li>优点：<ul>
<li>十分简单：浏览器和服务端都不需要做任何特殊逻辑，直接请求即可</li>
<li>兼容性极佳（所有浏览器都支持）</li>
</ul>
</li>
<li>缺点：<ul>
<li>频繁TCP连接建立/关闭（未启用长连接时）</li>
<li>无效请求占比高（无数据更新时），浪费网络带宽和服务器资源</li>
<li>数据更新的实时性较差，实时性取决于轮询的间隔</li>
<li>访问量较大的大型网站，对服务端会有较大的压力</li>
</ul>
</li>
<li>应用场景：<ul>
<li>对实时性要求没那么高的网站和小型网站</li>
<li>简单的通知和定时查询的场景</li>
</ul>
</li>
</ul>
<h2 id="三、-长轮询：等待的艺术"><a href="#三、-长轮询：等待的艺术" class="headerlink" title="三、 长轮询：等待的艺术"></a>三、 长轮询：等待的艺术</h2><p>既然短轮询发送太频繁，服务端即便在没有数据更新的时候也会返回数据，那么有没有什么优化方式呢？有的，长轮询。</p>
<h3 id="技术原理-1"><a href="#技术原理-1" class="headerlink" title="技术原理"></a>技术原理</h3><p>针对短轮询的问题，我们自然而然地可以想到一个对短轮询的优化方式：在服务端收到请求后不立刻返回，而是把请求挂起，一直等待直到有数据更新或者超时。浏览器端在收到数据响应或者超时后，再重新发起一次请求。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/long_polling.png" alt="长轮询"></p>
<p>浏览器端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长轮询：递归调用，响应后立即重新请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longPoll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">&#x27;/long-poll-api&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Long Polling:&#x27;</span>, data);</span><br><span class="line">      longPoll(); <span class="comment">// 立即发起下一次请求</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;Error:&#x27;</span>, err);</span><br><span class="line">      <span class="built_in">setTimeout</span>(longPoll, <span class="number">1000</span>); <span class="comment">// 错误时延迟重试</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长轮询处理：挂起请求直到数据更新或超时（使用 EventEmitter 模拟数据更新）</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> dataEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/long-poll-api&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.json(&#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;); <span class="comment">// 超时返回空数据</span></span><br><span class="line">  &#125;, <span class="number">30000</span>); <span class="comment">// 强制30秒超时</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听数据更新事件</span></span><br><span class="line">  <span class="keyword">const</span> dataHandler = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    res.json(&#123; data &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dataEmitter.once(<span class="string">&#x27;update&#x27;</span>, dataHandler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端断开连接时清理资源</span></span><br><span class="line">  req.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    dataEmitter.off(<span class="string">&#x27;update&#x27;</span>, dataHandler);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据更新</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dataEmitter.emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;New Data&#x27;</span>);</span><br><span class="line">&#125;, <span class="built_in">Math</span>.random() * <span class="number">15000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="协议视角-1"><a href="#协议视角-1" class="headerlink" title="协议视角"></a>协议视角</h3><p>从协议视角来看连接保持的原理，就是：当服务端不立即返回响应时，TCP连接会保持打开状态（由 HTTP Keep-Alive 机制管理），直到：</p>
<ul>
<li>服务端主动发送响应</li>
<li>客户端主动取消请求</li>
<li>中间设备（代理、负载均衡器）触发超时</li>
<li>操作系统强制关闭连接</li>
</ul>
<p>正是因为HTTP/1.1支持了长连接，才有了长轮询对短轮询的改进。</p>
<blockquote>
<p>这里插入一句：</p>
<p>根据<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7230#section-6.3">RFC 7230第6.3节</a>，在HTTP/1.1中默认启用了<code>Connection: Keep-Alive</code>，因此在HTTP/1.1的响应头不需要显式设置这个响应头。<br>另外根据<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7540#section-8.1.2.2">RFC 7540第8.1.2.2节</a>，HTTP/2 明确禁止使用<code>Connection</code>字段，现代浏览器（如 Safari）在HTTP/2下会严格遵循规范，可能导致连接被拒绝。</p>
<p>所以请只有在明确需要兼容HTTP/1.0时再设置<code>Connection: Keep-Alive</code></p>
</blockquote>
<h3 id="优缺点和应用场景-1"><a href="#优缺点和应用场景-1" class="headerlink" title="优缺点和应用场景"></a>优缺点和应用场景</h3><ul>
<li>优点：<ul>
<li>请求频率低：对比短轮询大大降低了请求频率</li>
<li>实时性对比短轮询要好</li>
<li>兼容性好</li>
</ul>
</li>
<li>缺点：<ul>
<li>资源占用：服务器需要保持与每个客户端的连接，高并发时压力大</li>
<li>超时重连时可能会有一些实时性的延迟</li>
<li>实现较短轮询来说复杂一些</li>
</ul>
</li>
<li>应用场景：<ul>
<li>中等实时性需求，如邮件通知、订单状态更新等</li>
<li>作为无法使用 WebSocket/SSE 时的替代方案</li>
</ul>
</li>
</ul>
<h2 id="四、-SSE：来自服务端的推送"><a href="#四、-SSE：来自服务端的推送" class="headerlink" title="四、 SSE：来自服务端的推送"></a>四、 SSE：来自服务端的推送</h2><p>从上面的短轮询和长轮询的应用场景我们发现，这些场景大多是服务端到前端的单向的数据更新，如果是这样的话，SSE（Server-Sent Events）会是一个更好的选择。</p>
<p>在2008年左右，SSE作为HTML5标准提案的一部分被提出，支持服务端单向推送，之后在2011年，SSE通过<code>EventSource</code> API实现了标准化，并被主流浏览器逐步支持，最终在HTTP/2中成为正式标准。</p>
<p><strong>而大多数的网页端的AI大模型对话的流式回答，也正是通过SSE来实现的。</strong></p>
<h3 id="技术原理-2"><a href="#技术原理-2" class="headerlink" title="技术原理"></a>技术原理</h3><p>SSE和长轮询一样，都是服务端收到请求后不立刻返回，而是保持这个连接打开，之后服务器按照如下要求进行返回：</p>
<ul>
<li>响应头：<code>Content-Type: text/event-stream</code>，用于标识SSE数据流</li>
<li>数据格式：每条消息由<code>data:</code>开头，以<code>\n\n</code>结尾（即用双换行符分隔）</li>
</ul>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/sse.png" alt="SSE"></p>
<p>服务端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line">app.use(express.static(path.join(__dirname)));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/sse&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="comment">// 设置SSE需要的响应头</span></span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span>,</span><br><span class="line">    <span class="comment">// 为了保证前端展示的是最新数据，需要设置 Cache-Control: no-cache </span></span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每隔一段时间发送一次数据，模拟实时数据流</span></span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="built_in">Date</span>.now(),</span><br><span class="line">      <span class="comment">// 生成随机字符串模拟数据</span></span><br><span class="line">      <span class="attr">msg</span>: <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">2</span>, <span class="number">12</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSE数据格式要求</span></span><br><span class="line">    res.write(<span class="string">`data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n\n`</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开连接时清理资源</span></span><br><span class="line">  req.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Client disconnected&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Client connected&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running on http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在浏览器端，则通过浏览器通过<code>EventSource</code> API监听服务器推送：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source;</span><br><span class="line"><span class="keyword">const</span> start = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Started listening to events&#x27;</span>);</span><br><span class="line">  source = <span class="keyword">new</span> EventSource(<span class="string">&#x27;/sse&#x27;</span>);</span><br><span class="line">  source.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>).innerHTML += <span class="string">`&lt;p&gt;接收到数据: <span class="subst">$&#123;data.msg&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (source) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Stopped listening to events&#x27;</span>);</span><br><span class="line">    source.close();</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>).innerHTML += <span class="string">&#x27;&lt;p&gt;Connection closed&lt;/p&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/sse_get.gif" alt="EventSource实现SSE效果"></p>
<h3 id="协议视角-2"><a href="#协议视角-2" class="headerlink" title="协议视角"></a>协议视角</h3><p>从协议视角来看，SSE仍然是基于HTTP协议的一个普通请求，并且和长轮询一样是收到请求后不立刻结束请求，而是保持连接打开，通过设置特定的响应头，在同一个请求里返回多个特定格式的数据片段。</p>
<p>和长轮询不同的是，长轮询是有数据更新时会立刻返回并结束当前请求，需要前端重新发起一个请求。而SSE则是可以持续不断地返回数据，直到数据发送完毕服务端断连接或者前端主动断开连接。</p>
<p>如果因为网络错误等导致连接断开，浏览器默认自动尝试重新连接。</p>
<p>而这一切只需要按照SSE的规范，设置响应头<code>Content-Type: text/event-stream</code>和按照特定的数据格式返回即可。</p>
<h3 id="原生EventSource的不足"><a href="#原生EventSource的不足" class="headerlink" title="原生EventSource的不足"></a>原生EventSource的不足</h3><p>通过EventSource虽然可以实现SSE，但是有一些限制：</p>
<ul>
<li><p><code>EventSource</code>只能支持GET请求</p>
<p>在AI大模型对话的这种场景来看，GET请求明显不合适，GET请求只能在URL的query中添加数据，但是浏览器对于URL的长度是有限制的，而且一些敏感的数据也不适合放到query里，这种情况下使用POST请求是更好选择</p>
</li>
<li><p><code>EventSource</code>只支持发送UTF-8编码的文本，不支持发送二进制流</p>
</li>
</ul>
<p>针对这两个问题，可以尝试不使用<code>EventSource</code>，而是用<code>fetch</code>来实现SSE：</p>
<ul>
<li>前端请求的时候，使用<code>fetch</code> API和<code>ReadableStream</code>可读流来代替<code>EventSource</code></li>
<li>服务端支持POST方法的请求</li>
<li>前端和服务端自己实现event-stream的组装和解析</li>
</ul>
<p>这里我们用一个模拟AI大模型回答的例子来看下POST请求的SSE如何实现。</p>
<h3 id="模拟实现AI大模型回答"><a href="#模拟实现AI大模型回答" class="headerlink" title="模拟实现AI大模型回答"></a>模拟实现AI大模型回答</h3><p>服务端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">app.use(express.static(path.join(__dirname)));</span><br><span class="line">app.use(express.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST SSE</span></span><br><span class="line">app.post(<span class="string">&#x27;/post-sse&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;收到POST请求:&#x27;</span>, req.body);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取前端提交的数据</span></span><br><span class="line">  <span class="keyword">const</span> clientName = req.body.name;</span><br><span class="line">  <span class="keyword">const</span> question = req.body.question;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`收到来自 <span class="subst">$&#123;clientName&#125;</span> 的POST SSE请求，用户的问题是: <span class="subst">$&#123;question&#125;</span>`</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置SSE所需的响应头</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送初始消息，包含客户端提供的数据，并在末尾添加换行</span></span><br><span class="line">  res.write(<span class="string">`data: &#123;&quot;message&quot;: &quot;你好，<span class="subst">$&#123;clientName&#125;</span>！收到了你的问题：<span class="subst">$&#123;question&#125;</span>\\n\\n&quot;&#125;\n\n`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> intervalId;</span><br><span class="line">  <span class="comment">// 读取 ./text.md 文件 模拟大模型回答问题</span></span><br><span class="line">  <span class="keyword">const</span> textFilePath = path.join(__dirname, <span class="string">&#x27;text.md&#x27;</span>);</span><br><span class="line">  fs.readFile(textFilePath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;读取文件时出错:&#x27;</span>, err);</span><br><span class="line">      res.write(<span class="string">&#x27;data: &#123;&quot;message&quot;: &quot;读取文件时出错&quot;&#125;\n\n&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每隔 50~100ms 发送 3~5 个字符，模拟大模型回答问题</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= data.length) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">        <span class="comment">// 发送完成标记</span></span><br><span class="line">        res.write(<span class="string">&#x27;data: &#123;&quot;message&quot;: &quot;&quot;, &quot;answerFinished&quot;: true&#125;\n\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`已发送完 <span class="subst">$&#123;clientName&#125;</span> 的问题的回答`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟一点时间再结束响应，确保最后的消息能被客户端接收</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`结束 <span class="subst">$&#123;clientName&#125;</span> 的 SSE 连接`</span>);</span><br><span class="line">          res.end();</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>) + <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">const</span> chunk = data.slice(index, index + chunkSize);</span><br><span class="line">      index += chunkSize;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 确保特殊字符被正确转义，特别是换行符</span></span><br><span class="line">      <span class="keyword">const</span> escapedChunk = <span class="built_in">JSON</span>.stringify(chunk).slice(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">      res.write(<span class="string">`data: &#123;&quot;message&quot;: &quot;<span class="subst">$&#123;escapedChunk&#125;</span>&quot;&#125;\n\n`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`已发送 <span class="subst">$&#123;chunk.length&#125;</span> 个字符给 <span class="subst">$&#123;clientName&#125;</span>`</span>);</span><br><span class="line">    &#125;, getRandomInterval(<span class="number">50</span>, <span class="number">100</span>));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开连接时清理资源</span></span><br><span class="line">  res.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`客户端 <span class="subst">$&#123;clientName&#125;</span> 断开连接`</span>);</span><br><span class="line">    intervalId &amp;&amp; <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInterval</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`SSE 服务器运行在 http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>前端代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abortController = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> responseElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;aiResponse&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendQuestion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> accumulatedResponse = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建AbortController用于取消请求</span></span><br><span class="line">    abortController = <span class="keyword">new</span> AbortController();</span><br><span class="line">    <span class="keyword">const</span> signal = abortController.signal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备请求数据</span></span><br><span class="line">    <span class="keyword">const</span> requestData = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">      <span class="attr">question</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送POST请求</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/post-sse&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(requestData),</span><br><span class="line">      <span class="attr">signal</span>: signal</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`服务器返回错误: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理SSE数据流</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;已连接，正在接收数据...&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取可读流并创建读取器</span></span><br><span class="line">    <span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line">    <span class="keyword">const</span> decoder = <span class="keyword">new</span> TextDecoder();</span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据流</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;数据接收完成&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 解码二进制数据</span></span><br><span class="line">      <span class="keyword">const</span> chunk = decoder.decode(value, &#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      buffer += chunk;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理SSE格式数据（以\n\n分隔）</span></span><br><span class="line">      <span class="keyword">const</span> events = buffer.split(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">      buffer = events.pop() || <span class="string">&#x27;&#x27;</span>; <span class="comment">// 保留可能不完整的最后一部分数据</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理每个事件</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> event <span class="keyword">of</span> events) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.trim()) &#123;</span><br><span class="line">          <span class="comment">// 解析SSE数据行</span></span><br><span class="line">          <span class="keyword">const</span> dataMatch = event.match(<span class="regexp">/^data: (.+)$/m</span>);</span><br><span class="line">          <span class="keyword">if</span> (dataMatch) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(dataMatch[<span class="number">1</span>]);</span><br><span class="line">              <span class="keyword">if</span> (data.message !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// 追加消息到 accumulatedResponse</span></span><br><span class="line">                accumulatedResponse += data.message;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将累积的响应数据 accumulatedResponse 更新到页面</span></span><br><span class="line">                responseElement.innerHTML = accumulatedResponse;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 如果收到完成标志，中断连接</span></span><br><span class="line">              <span class="keyword">if</span> (data.answerFinished === <span class="literal">true</span>) &#123;</span><br><span class="line">                stopRequest();</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;回答完成&#x27;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="built_in">console</span>.error(<span class="string">&#x27;解析JSON出错:&#x27;</span>, e);</span><br><span class="line">              <span class="comment">// 如果不是JSON，直接显示文本</span></span><br><span class="line">              accumulatedResponse += dataMatch[<span class="number">1</span>];</span><br><span class="line">              responseElement.innerHTML = accumulatedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.name === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求已取消&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;请求出错:&#x27;</span>, error);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`错误: <span class="subst">$&#123;error.message&#125;</span>`</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    abortController = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (abortController) &#123;</span><br><span class="line">    abortController.abort();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;正在停止请求...&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端，我们通过<code>app.post</code>支持了post请求，并且通过读取一个markdown文件并随机返回不同数量的字符来模拟大模型的回答问题。</p>
<p>在前端代码中，<code>fetch</code> API的<code>Response.body</code>暴露一个<code>ReadableStream</code>类型的body内容，即一个可读的字节流。同时正是因为是字节流，所以需要通过<code>TextDecoder</code>来解析字节流，之后自行解析后端返回的数据并输出到屏幕。</p>
<p>如果我们优化一下前端UI的话，并且支持了Markdown的解析的话，就可以得到类似AI输出的效果：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/sse_post.gif" alt="POST SSE模拟AI对话回答"></p>
<p>再看下Chat GPT的对话，可以看到也是同样的效果：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/chat_gpt.gif" alt="Chat GPT效果"></p>
<p>其实不想自己实现<code>fetch</code> SSE的话，可以用一些第三方库，比如微软的<a target="_blank" rel="noopener" href="https://github.com/Azure/fetch-event-source">fetch-event-source</a>，实现了类似于原生<code>EventSource</code>的能力，不需要自行解析数据，同时支持POST请求。</p>
<h3 id="优缺点和应用场景-2"><a href="#优缺点和应用场景-2" class="headerlink" title="优缺点和应用场景"></a>优缺点和应用场景</h3><ul>
<li>优点：<ul>
<li>请求频率低：对比短轮询长轮询来说请求频率很低</li>
<li>实时性很好</li>
<li>在实时性较好的同时，实现上比WebSocket要简单很多（尤其是<code>EventSource</code>）</li>
<li><code>EventSource</code>支持自动重连，连接断开后浏览器会自动尝试重新连接，不需要手动维护</li>
</ul>
</li>
<li>缺点：<ul>
<li>连接建立后只能服务端到客户端单向通信</li>
<li>通过<code>EventSource</code>来实现的话，只支持GET请求，不支持发送二进制流，只能发送UTF-8编码的文本</li>
<li>通过<code>fetch</code>来实现的话则会有一些复杂性</li>
</ul>
</li>
<li>应用场景：<ul>
<li>实时数据流（如股票行情、新闻推送、日志监控等）</li>
<li>需要服务器主动推送但无需客户端响应的场景</li>
</ul>
</li>
</ul>
<h2 id="五、-WebSocket：双向通信的任意门"><a href="#五、-WebSocket：双向通信的任意门" class="headerlink" title="五、 WebSocket：双向通信的任意门"></a>五、 WebSocket：双向通信的任意门</h2><p>SSE作为提案被提出的时间是2008年左右，而与此同时，一个支持双向实时传输的全双工通信方式，WebSocket也被提出来了，并且在<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>中正式发布。</p>
<blockquote>
<p>单工、半双工、全双工</p>
<ul>
<li>单工：数据只能单向传输，一方只能作为发送方，另一方只能作为接收方，比如A→B</li>
<li>半双工：数据可以双向传输，但是不能同时进行，同一时间只能存在一个方向的数据传输，比如A→B或者B→A</li>
<li>全双工：数据可以双向传输，也可以同时进行，即同一时间可以同时存在两个方向的数据传输，A⇄B</li>
</ul>
</blockquote>
<h3 id="技术原理-3"><a href="#技术原理-3" class="headerlink" title="技术原理"></a>技术原理</h3><p>WebSocket最开始是由HTTP发起的请求，为了兼容现有的浏览器和服务器，它使用标准的HTTP端口（80/443），通过一个特殊的HTTP请求头来升级协议。</p>
<p>客户端：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>

<p>握手成功后，连接从HTTP协议升级为WebSocket协议，这个连接会变成一个<strong>全双工</strong>（双向）、<strong>持久化</strong>的连接。</p>
<p>一旦连接建立，<strong>客户端和服务器可以随时相互发送数据</strong>，不需要再像 HTTP 那样请求-响应模式：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/websocket.png" alt="WebSocket"></p>
<h3 id="协议视角-3"><a href="#协议视角-3" class="headerlink" title="协议视角"></a>协议视角</h3><p>从协议的角度看，WebSocket和上面的长短轮询以及SSE完全不同了，WebSocket只是借助HTTP来完成协议的切换，只会在连接建立的时候使用到HTTP协议，一旦协议切换完成，就是一个全新的协议了。</p>
<p>WebSocket和HTTP一样，都是在传输层TCP协议之上的应用层协议，同时因为不是HTTP，所以也没有HTTP的一些同源跨域的限制（所以WebSocket也是实现跨域请求的一种方式，只不过成本有点高）。</p>
<h3 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h3><p>在使用WebSocket的时候，前端只需要简单地使用<code>WebSocket</code> API即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://example.com/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;收到消息:&#x27;</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket连接已关闭&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;用户1&#x27;</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;你好，WebSocket!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息到服务器</span></span><br><span class="line">ws.send(<span class="built_in">JSON</span>.stringify(data));</span><br></pre></td></tr></table></figure>

<p>而服务端，也是用类似的方式进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(express.static(path.join(__dirname)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HTTP服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建WebSocket服务器，将其附加到HTTP服务器</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; server &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听WebSocket连接事件</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;客户端已连接&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送欢迎消息给客户端</span></span><br><span class="line">  ws.send(<span class="built_in">JSON</span>.stringify(&#123; </span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;system&#x27;</span>, </span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;欢迎连接到WebSocket服务器！&#x27;</span> </span><br><span class="line">  &#125;));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 监听客户端发来的消息</span></span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;收到消息:&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 监听连接关闭事件</span></span><br><span class="line">  ws.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;客户端已断开连接&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 监听错误事件</span></span><br><span class="line">  ws.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;WebSocket错误:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另外还可以将每个客户端的 ws 实例保存下来，用来实现给所有已连接的客户端进行消息广播等</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3000</span>;</span><br><span class="line">server.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`WebSocket服务器运行在 http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里用一个网络聊天室的Demo来看下效果：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/websocket_chat_room.gif" alt="网络聊天室Demo"></p>
<p>协议升级：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/websocket_upgrade.png" alt="协议升级"></p>
<p>数据帧：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/websocket_data_frame.png" alt="数据帧"></p>
<p>服务端日志：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/websocket_server_log.png" alt="数据帧"></p>
<p>上面的聊天室只是一个很小的WebSocket Demo，实际应用中可能还需要考虑心跳处理和断线重连等，比如服务端或者客户端定时发送一个空的心跳包给对方，如果一定时间内没有收到，就认为对方已经离线。</p>
<h3 id="HTTP-2中的实现"><a href="#HTTP-2中的实现" class="headerlink" title="HTTP/2中的实现"></a>HTTP/2中的实现</h3><p>另外，上面提到过在HTTP/1.1 默认启用了<code>Connection: Keep-Alive</code>，在HTTP/2 甚至明确禁止使用头<code>Connection</code>字段，那么上面的WebSocket的握手方式就明显不适用了，即原始WebSocket（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>）只支持HTTP/1.1。</p>
<p>那怎么解决？有没有办法在HTTP/2中使用WebSocket？</p>
<p>为了让WebSocket可以在HTTP/2上运行，IETF发布了<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8441">RFC 8441</a>，引入了一种新机制：使用HTTP/2的<code>extended CONNECT</code>方法来升级到WebSocket协议。</p>
<ul>
<li>客户端：</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:method = CONNECT</span><br><span class="line">:protocol = websocket</span><br><span class="line">:scheme = https</span><br><span class="line">:authority = example.com</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端：</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:status = 200</span><br></pre></td></tr></table></figure>

<p>这些冒号开头的请求头，（如 <code>:method</code>, <code>:path</code>, <code>:authority</code> 等）是HTTP/2引入的伪首部字段（pseudo-header fields），和传统HTTP/1.x的请求头格式不同。</p>
<blockquote>
<p>在 HTTP/2 和 HTTP/3 中，为了更高效地传输协议控制信息，规范规定了以冒号（:）开头的特殊头字段，这些叫作<strong>伪首部字段（pseudo-header fields）</strong>。</p>
<p>它们并不是普通的请求头，而是用来描述请求的核心元素，比如方法、路径、协议等。这主要是为了配合HTTP/2的头部压缩（HPACK）机制以及支持多路复用，所以将这些核心字段标准化成<code>:method</code>、<code>:path</code>、<code>:authority</code>等“伪头部”字段，直接编码进头部帧</p>
</blockquote>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/http2_header.png" alt="HTTP/1.1到HTTP/2 Header的变化"></p>
<p>通过上面的请求头和响应头，WebSocket连接就可以建立成功，接下来就是WebSocket协议数据帧的交互了。</p>
<p>为了支持HTTP/2的WebSocket，服务端需要做一些调整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http2 = <span class="built_in">require</span>(<span class="string">&#x27;http2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http2.createSecureServer(&#123; </span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">cert</span>: <span class="string">&#x27;...&#x27;</span> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;stream&#x27;</span>, <span class="function">(<span class="params">stream, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (headers[<span class="string">&#x27;:protocol&#x27;</span>] === <span class="string">&#x27;websocket&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 WebSocket 连接</span></span><br><span class="line">    stream.respond(&#123; <span class="string">&#x27;:status&#x27;</span>: <span class="number">200</span> &#125;);</span><br><span class="line">    handleWebSocket(stream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleWebSocket</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  stream.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 WebSocket 数据帧</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而前端则不需要做特殊处理，那些请求头也和HTTP/1.1一样，由浏览器自动处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论 HTTP/1.1 还是 HTTP/2，代码一致</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://example.com/chat&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然而鉴于以下因素：</p>
<ul>
<li>服务器和浏览器对于<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8441">RFC 8441</a>的机制，并不是完全支持（比如Nginx不支持，Safari部分支持）</li>
<li>目前的服务器和浏览器都支持HTTP/1.1，在连接时会自动协商使用的HTTP版本</li>
<li>WebSocket只是借用HTTP来完成握手和协议切换，切换完成后和HTTP本身是哪个版本就没多大关系了，HTTP2并不会对WebSocket带来特别大的优化</li>
</ul>
<p>考虑这些因素，目前仍然建议WebSocket走独立的HTTP/1.1路由或者端口。</p>
<h3 id="优缺点和应用场景-3"><a href="#优缺点和应用场景-3" class="headerlink" title="优缺点和应用场景"></a>优缺点和应用场景</h3><ul>
<li>优点：<ul>
<li>全双工通信，实时性最高</li>
<li>高效（减少HTTP头开销，支持二进制和文本数据）</li>
<li>跨域通信，WebSocket允许跨域通信</li>
</ul>
</li>
<li>缺点：<ul>
<li>实现复杂（需处理连接状态、心跳检测等），对于小型应用有些由于复杂</li>
<li>可能被防火墙或代理拦截，一些网络环境中，防火墙和代理可能会阻止WebSocket连接</li>
</ul>
</li>
<li>应用场景：<ul>
<li>高频双向交互，如在线游戏、在线文档的协同编辑等</li>
<li>实时聊天、金融交易等低延迟场景</li>
</ul>
</li>
</ul>
<h2 id="六、-插一嘴关于HTTP的版本"><a href="#六、-插一嘴关于HTTP的版本" class="headerlink" title="六、 插一嘴关于HTTP的版本"></a>六、 插一嘴关于HTTP的版本</h2><p>上面提到了好多次不同的HTTP版本，那么我们可能会想到下面几个问题。</p>
<h3 id="1-查看版本"><a href="#1-查看版本" class="headerlink" title="1. 查看版本"></a>1. 查看版本</h3><p><em><strong>如何在浏览器里怎么查看一个请求的HTTP版本？</strong></em></p>
<p>这个很简单，直接看浏览器开发者工具的“网络”面板就可以，右键勾选“协议”，就可以直接在协议这一列看到当前的HTTP请求的协议版本</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/fe_polling/check_http_version.png" alt="查看HTTP版本"></p>
<h3 id="2-支持多版本"><a href="#2-支持多版本" class="headerlink" title="2. 支持多版本"></a>2. 支持多版本</h3><p><em><strong>客户端和服务端怎么支持不同的HTTP版本？</strong></em></p>
<p>对于HTTP/1.1，目前前后端基本上都默认支持了。</p>
<p>对于HTTP2，前端不需要做额外处理，只需要启用HTTPS即可，因为浏览器仅在加密连接下支持HTTP/2。</p>
<p>而在服务端，则需要特殊处理来兼容HTTP/2，以Node实现的服务端为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http2 = <span class="built_in">require</span>(<span class="string">&#x27;http2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取SSL证书</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">&#x27;私钥路径/server.key&#x27;</span>),</span><br><span class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">&#x27;证书路径/server.crt&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HTTP/2服务器</span></span><br><span class="line"><span class="keyword">const</span> http2Server = http2.createSecureServer(options, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello from HTTP/2!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选：创建HTTP/1.1服务器（非必须，ALPN会自动回退）</span></span><br><span class="line"><span class="keyword">const</span> httpServer = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello from HTTP/1.1!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口（通常HTTP/2用443，HTTP/1.1可共用或分开）</span></span><br><span class="line">http2Server.listen(<span class="number">443</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HTTP/2 server running on port 443&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">httpServer.listen(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HTTP/1.1 server running on port 80&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果使用Nginx作为反向代理服务器的话，则还需要在Nginx上修改配置。</p>
<h3 id="3-确定版本"><a href="#3-确定版本" class="headerlink" title="3. 确定版本"></a>3. 确定版本</h3><p><em><strong>在请求时，具体使用哪个版本的HTTP是谁来决定的呢？</strong></em></p>
<p>在请求时，具体使用哪个版本的协议，是由​​客户端和服务端协商​​决定，而非单方强制决定。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>角色</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>客户端（前端）</td>
<td>发起连接时声明支持的协议列表（如 <code>ALPN: h2, http/1.1</code>）</td>
</tr>
<tr>
<td>2</td>
<td>服务端（后端）</td>
<td>根据自身能力选择最高优先级的协议（如优先选 <code>h2</code>）</td>
</tr>
<tr>
<td>3</td>
<td>最终协议</td>
<td>双方共同支持的最高版本（如客户端支持 <code>h2</code>，服务端也支持 → 使用 <code>h2</code>）</td>
</tr>
</tbody></table>
<p>而上面的ALPN，就是​​Application-Layer Protocol Negotiation​​，应用层协议协商，用来建立连接时客户端和服务端协商确认使用哪个版本的协议。</p>
<h2 id="七、-结语"><a href="#七、-结语" class="headerlink" title="七、 结语"></a>七、 结语</h2><p>这篇文章从AI的流式回答切入，我们一起了解了从页面刷新，到短轮询长轮询，再到SSE和WebSocket，那么再回到最开始的那个问题，如何优雅实现实时数据更新？</p>
<p>这个问题好像并没有正确的答案，因为没有最完美的技术，只有恰逢其时的选择，每个技术都有自己的优缺点和适用场景，还是要根据自己的业务场景来选择，找到技术和体验的平衡点才是我们要做的事。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7291931828029472806">Web实时通信技术调研：长轮询、短轮询、WebSocket 和 SSE</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7451991754561880115">WebSocket太笨重？试试SSE的轻量级魅力！</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sisterAn/blog/issues/98">HTTP/2对比HTTP/1.1，特性是什么？是如何解决队头阻塞与压缩头部的？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903853985366023">什么是队头阻塞以及如何解决</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7079936383925616653">HTTP发展史，HTTP1.1与HTTP2.0的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7020964728386093093">一文吃透 WebSocket 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7481600956309979151">SSE(Server-Sent Events)，解密AI流式输出和呈现</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2024/12/16/%E5%AD%97%E5%BD%A2%E6%B7%B7%E6%B7%86%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/16/%E5%AD%97%E5%BD%A2%E6%B7%B7%E6%B7%86%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2/" class="post-title-link" itemprop="url">字形混淆：浏览器里的攻与防</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-16 18:38:21" itemprop="dateCreated datePublished" datetime="2024-12-16T18:38:21+08:00">2024-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>免责声明：本文以及文中涉及的代码仅用于个人学习交流，禁止转载。同时请勿将本文介绍的相关技术用于非法用途，对于非法用途或者滥用相关技术而产生的风险和相关的法律后果，与本文作者无关。请在阅读本文内容时，确保仅用于个人学习交流，并遵守当地法律法规。</p>
</blockquote>
<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>不知道大家有没有用过一些剪藏助手的浏览器插件，就可以把在网页上看到内容，通过插件将内容收藏起来。我自己平时就会把这些自己觉得有收藏价值的内容，通过印象笔记、金山文档等剪藏助手收藏起来，供以后翻看。</p>
<p>但是前段时间，在剪藏一篇文章时，发现了一个奇怪的事情。我打开了一个网站，这个网站是讲历史的，在拿出我的剪藏助手想要收藏时，遇到了下面的问题。这里我随便找一篇这个网站的文章作为例子截图演示一下：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/1_article_example.webp" alt="以这篇文章为例演示一下"></p>
<p>但是剪藏完之后一看，发现不对的地方了，怎么句子都读不通顺？难道剪藏助手出bug了？</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/2_article_obtained.webp" alt="语句都读不通顺的内容"></p>
<p>要知道，所谓的剪藏助手，它的原理就是读取网页的HTML，把里面的文字和样式获取到然后塞到自己新创建的文档里，正常来讲不应该有问题的。打开这个网站浏览器开发者工具看一下：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/3_diff_in_dom.webp" alt="DOM结构中的内容，和最终渲染的内容不一样"></p>
<p>可以看到DOM中的内容，和最终展示的内容确实不一样，而剪藏助手截取的内容，也确实是DOM中的内容无疑，并不是剪藏助手的bug。</p>
<p>这就奇怪了，为啥内容会不一样呢？明明就是很简单的纯文字渲染，也没有什么魔法在里面。<br>这个时候我注意到右下角有一个CSS属性：<code>font-family</code>，它的值是很奇怪的一个内容：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/4_spetical_font.webp" alt="一串好像是编码后的字符串"></p>
<h2 id="初现端倪"><a href="#初现端倪" class="headerlink" title="初现端倪"></a>初现端倪</h2><p>这个<code>font-family</code>看起来有点奇怪，我们来尝试改一下看看。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/5_change_font.webp" alt="修改font-family为其他字体"></p>
<p>可以看到，在改了字体之后，渲染出来的内容，和DOM里的文字就对得上了，同样的读不通顺的句子。并且在来回切换字体的时候，页面渲染出来的内容也随着字体变化而变化：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/6_change_font.gif" alt="渲染的UI随着font-family变化"></p>
<p>看来这个<code>font-family</code>就是问题所在。</p>
<h2 id="揭开面纱"><a href="#揭开面纱" class="headerlink" title="揭开面纱"></a>揭开面纱</h2><p>既然找到了问题所在，那么我们来看下这个有点特别的<code>font-family</code>是什么，既然不是一个标准字体，那就应该是用户自定义的字体了，自定义在DOM中全局搜一下这个字体:</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/7_custom_font.webp" alt="自定义字体"></p>
<p>可以看到这个字体是通过base64的方式引入的，并且内容也恰好是<code>data:font/ttf</code>这样一个字体格式。</p>
<blockquote>
<p>TTF（TrueType Font），一种二进制格式的文件。TTF 文件包含字体的矢量信息、度量信息和其他相关数据，用于在计算机上显示和打印文本。</p>
</blockquote>
<p>我们知道，base64是可以解码的，那我们把这段base64复制下来，还原为二进制ttf文件，可以参考下面的脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToArrayBuffer</span>(<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> binaryString = atob(base64.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> len = binaryString.length;</span><br><span class="line">  <span class="keyword">const</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    bytes[i] = binaryString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bytes.buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveArrayBufferToFile</span>(<span class="params">buffer, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([buffer], &#123; <span class="attr">type</span>: <span class="string">&#x27;font/ttf&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  link.href = URL.createObjectURL(blob);</span><br><span class="line">  link.download = filename;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">  link.click();</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> base64Data = <span class="string">&#x27;data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8S...&#x27;</span>; <span class="comment">// 你的 base64 编码数据</span></span><br><span class="line"><span class="keyword">const</span> arrayBuffer = base64ToArrayBuffer(base64Data);</span><br><span class="line">saveArrayBufferToFile(arrayBuffer, <span class="string">&#x27;font.ttf&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>或者通过网上的一下小工具来实现这一步：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014291497/article/details/54915879">将base64格式的字体信息解码成可用的字体文件</a></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/8_font_file.png" alt="ttf字体文件"></p>
<p>用一些字体编辑器打开这个字体文件发现，这个字体文件里有一些自定义的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Glyph">字形（Glyphs）</a>。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/9_glyphs_in_font.webp" alt="字体文件包含自定义字形"></p>
<p>而如果我们去了解一下<a target="_blank" rel="noopener" href="https://help.fontlab.com/fontlab/7/manual/About-Glyphs/">字体相关的知识</a>的话，就会知道：</p>
<p><strong>字符</strong>是Unicode码位标识的逻辑单元，而<strong>字形</strong>则是字体的图形单元。</p>
<p><strong>Characters</strong> are logical text units identified by Unicode code points, whereas <strong>glyphs</strong> are graphical font units.</p>
<h2 id="字符和字形"><a href="#字符和字形" class="headerlink" title="字符和字形"></a>字符和字形</h2><p>我们都知道，Unicode又叫万国码，是Unicode联盟整理和编码的字符集，可以用来展示世界上大部分的文字系统。</p>
<p>Unicode编码从0开始，为每一个字符分配一个唯一的编号，这个编号就叫做码位（code point，也叫码点），以“计算机”的“机”字举例，“机”的码位为<code>26426</code>（十进制），即Unicode字符集中第26426个字符，就是“机”。</p>
<p>但是在表示一个Unicode的字符时，通常会用<code>U+</code>然后紧接着一组十六进制的数字来表示这一个字符。也就是说，“机”在Unicode中的表示方式是<code>U+673A</code>，码位是<code>673A</code>。</p>
<blockquote>
<p>更多关于字符编码的知识可以看这篇文章：<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7301908233320874025">字符编码简史：从二进制到UTF-8</a></p>
</blockquote>
<p>但是这个Unicode编码只是一个逻辑单元，在逻辑上给每个字符分配了一个编号。真正要展示的时候，还是需要给每个编号对应的字符，一个真正的图形，去展示去渲染，这个图形就是所谓的字形。</p>
<p>而在字体文件中，比如ttf，字形通常可以用SVG来标识，或者是使用一种叫做 “字形描述语言”（Glyph Description Language）的语言来描述。这种语言可以像SVG一样描述复杂的字形，包括直线、曲线和其他形状。</p>
<p>在字体文件中，每个字形都有一个唯一的标识符，这个标识符通常就是这个字符的Unicode码位。字形和Unicode码位之间的映射关系是在字体文件中定义的。</p>
<p>当浏览器读取到一个字体文件时，往往会进行以下步骤来渲染对应的字体：</p>
<ol>
<li>解码字体数据：浏览器会通过CSS的<code>font-face</code>拿到字体文件或者字体的base64编码字符串，解析得到字体文件的原始数据</li>
<li>加载字体：浏览器将解码后的字体数据加载到内存中，然后解析字体文件，读取其中的字形和对应的Unicode码位</li>
<li>渲染字体：当需要渲染一个字符时，浏览器会使用这个字符的Unicode码位，去字体文件中找到对应的字形，然后使用对应的字形来渲染这个字符</li>
</ol>
<h2 id="谜底"><a href="#谜底" class="headerlink" title="谜底"></a>谜底</h2><p>到这里，谜底差不多就已经揭晓了。</p>
<p>既然每个字符在渲染的时候，都有一个字形去控制渲染的形状，那么同一个字符可以根据不同的风格以不同的方式渲染或绘制，比如字母A，在不同的字体下可能有不同的形状：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/10_various_a.png" alt="不同字体下的“A”"></p>
<p>同时从另一个角度看，有时字形可能看起来相同，但代表不同的字符。例如，拉丁字母A、西里尔字母А 和希腊大写字母Alpha Α看起来都一样，但代表不同文字的不同字符。</p>
<p>那更进一步呢？我们是不是在一个字体里，可以把字符“A”的字形，映射到字形“B”，把字符“B”的字形，映射到字形“C”？这样的话一段字符串“AB”，最终浏览器渲染出来的，会是“BC”。</p>
<p>答案揭晓，上面剪藏内容对不上，就是使用了这种技术，这种常被称为“<strong>字形替换</strong>”或“<strong>字形混淆</strong>”，或者换一个爬虫领域常用的名字，“<a target="_blank" rel="noopener" href="https://juejin.cn/search?query=%E5%AD%97%E4%BD%93%E5%8F%8D%E7%88%AC">字体反爬</a>”。</p>
<p>它的原理就是使用一个特殊的字体，这个字体将每个字符映射到一个不同的字形。例如，字体可能将字符“A”映射到字形“B”，将字符“B”映射到字形“C”，等等。</p>
<p>这样，当用户查看网页时，可以将看似乱码的内容，映射到正确的文本，用户会看到正确的文本。但是当他们尝试复制和粘贴文本时，或者说通过剪藏助手这种爬虫工具爬取页面内容时，得到的就是错误的文本。</p>
<p>我们来简单验证一下这个结论：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/11_random_word.jpeg" alt="随便找几个字"></p>
<p>随便找几个对不上的字看一下，用红框圈出来，去看下字体文件里这几个字的字形：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/12_corresponding_glyphs.webp" alt="字体文件里对应的字形"></p>
<p>可以看到果然这些字都在自定义字形里，每个字的左下角是字符，中间是字形，这些字形恰好对应上了上面浏览器里的渲染结果。</p>
<p>点开一个字查看具体信息也可以看到，比如“管”这个字：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/13_guan_in_font.webp" alt="“管”这个字"></p>
<p>码位是<code>U+7BA1</code>，去第三方网站上搜一下这个码位对应的字符也确实是“管”：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/14_guan_in_unicode.png" alt="U+7BA1"></p>
<p>而这个字符的字形，确实是“这”的形状：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/15_shape_of_zhe.webp" alt="“管”对应“这”的形状"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/16_path_of_zhe.webp" alt="“这”的形状矢量图"></p>
<p>可以看到是类似于SVG的这种矢量图，我们还可以自己随便拖拽这些点，改变字形：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/17_changed_path_of_zhe.webp" alt="被编辑的“这”的矢量图"></p>
<p>而如果有兴趣的话，还可以自己画或者设计一款专属字体，比如我下面自己用鼠标随便画了一个形状，字母“a”的字形，有点丑：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/18_my_custom_a.webp" alt="自定义“a”"></p>
<p>导出这个ttf文件并在CSS中引用，就可以看到我们自己的字体了：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/19_custom_a_render.webp" alt="使用自定义“a”"></p>
<h2 id="攻与防"><a href="#攻与防" class="headerlink" title="攻与防"></a>攻与防</h2><p>到这里已经把上面遇到的“奇怪”事情搞清楚了，这个网站通过这种技术，来实现反爬虫，防止爬虫抓取内容，也可以防止剪藏助手这类工具剪藏一些内容，因为即便爬虫抓取或者剪藏了HTML里的内容，拿到的也是混淆后的错误内容，想要看到正确的内容，只能通过实时网络获取编码后的字体，来渲染为正确的内容。</p>
<p>可以说内容的“正确”，只会体现在浏览器的渲染层面，数据层面本身就是错误的。并且，这个字形的混淆以及对应的字体，每次请求都不一样。即每次加载页面请求服务端时，服务端都会先预先对内容进行一次混淆，每次使用的混淆字形都是不同的字符和字形。</p>
<p>通过上面这些操作，防止了第三方获取到本站的内容，本站内容只能在本站查看，提高了网站的用户留存率之类的。</p>
<p>即便爬虫在每次抓取内容时，获取对应的字体文件，也很难解析到字符和字形的对应关系，大大提高了爬虫爬取的成本。</p>
<p>但是上面说的这些，都是“防”，是一种防御手段，还记得标题吗，“攻与防”，“攻”体现在哪里？</p>
<p>其实在知道了字形混淆的原理，一些钓鱼网站可以用这种方式来进行攻击，比如：</p>
<ul>
<li>钓鱼网站通过字形混淆来绕过一些安全检查器，检查器获取到的是无意义的乱码，但是用户看到的是可读的文字，通过这种方式来进行钓鱼攻击</li>
<li>将恶意Linux命令伪装成安全命令（使<code>rm -rf /h*</code>看起来像<code>echo hello</code>），粗心的用户可能直接复制粘贴到终端并执行，造成严重后果</li>
<li>通过将垃圾邮件伪装成有用邮件来绕过垃圾邮件过滤</li>
<li>通过内嵌某种字体到pdf文档中（pdf可以内嵌字体，发给其他人查看时不需要其他人在他们电脑上安装对应字体），来绕过某些对文档、论文等内容的查重处理，比如将字形进行混淆，查重工具读到的是乱码，那么查重结果自然不会有什么问题，同时通过pdf内嵌的字体，保证了人在看文档的时候的可读性（<em>注：抄袭剽窃可耻，学术造假侵权违法，不要这样做</em>）</li>
<li>…</li>
</ul>
<p>上面这些都是利用字形混淆的方式来进行攻击的场景，我们这里只是讨论和学习这种技术可能存在的攻击手段，不是教导大家去这样搞，法网恢恢疏而不漏，<strong>大家不要去做这种攻击的事情</strong>。</p>
<p>同时这也提醒我们在复制网上一些内容时，一定要检查内容的正确性。</p>
<h2 id="自己尝试实现一下"><a href="#自己尝试实现一下" class="headerlink" title="自己尝试实现一下"></a>自己尝试实现一下</h2><p>在知道了上面的原理后，我们自己也可以实现字形混淆，但是总不能手动编辑每个字的字形矢量图吧，而且像是上面那种每次打开都会重新对不同字符的字形进行混淆的，肯定是需要把字形混淆的操作脚本化的，那假设我们自己也有一个网站需要对内容进行保护，我们要怎么实现上面的字形混淆逻辑呢？</p>
<p>我们的目标是：对于一段提供好的文本，针对其中部分字符或者全部字符，进行字形混淆，并生成混淆后的文本以及对应的字体文件。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/20_expected_handle_flow.png" alt="预期处理流程"></p>
<p>整体思路是：</p>
<ol>
<li><strong>准备一个基础字体文件</strong><br> 这个基础字体文件用于获取字体中字符信息和字形信息。</li>
<li><strong>确定好原始文本中需要进行混淆的字符列表</strong><br> 比如对于原始文本“ABCD”，需要对其中的“ABC”这三个字符进行混淆。</li>
<li><strong>确定好混淆的目标字符列表</strong><br> 比如上面“ABCD”中，对“ABC”三个字符进行混淆，分别混淆成“XYZ”。最终生成“XYZD”，但是展示出来的样子还是“ABCD”的样子。</li>
<li><strong>从基础字体文件中，获取字形信息</strong><br> 获取原始字符（比如“A”）和混淆的字符（比如混淆成“X”）各自的字形信息</li>
<li><strong>替换字形形状的矢量图</strong><br> 将混淆字符（“X”）的字形信息中，描述字形形状的矢量图路径，替换为原始字符（“A”）的字形信息中的描述字形形状的矢量图路径。<br> 把所有需要替换字形形状的字符（“ABC”）都替换完。</li>
<li><strong>反向替换字形形状的矢量图</strong><br> 但是把“XYZ”的字形形状改成“ABC”之后，真的需要展示“XYZ”的形状了怎么办？这个时候就需要进行反向混淆，把“ABC”这三个字符，随机指向“XYZ”的字形的形状。<br> 比如字符“A”的字形形状改为“Y”，字符“B”的字形形状改为“Z”，字符“C”的字形形状改为“X”。操作方法同上。<br> 这里随机指向而不是直接“A”指向“X”，“B”指向“Y”，“C”指向“Z”，也是为了加大破解难度，如果字符比较多的话，比如100个字符的字形随机相互指向，那么在没有字体文件的情况破解难度会很大。</li>
<li><strong>修改原始文本中的字符为混淆后的字符</strong><br> 把原始文本中的字符，根据上面的字形替换映射关系，改成对应的混淆字符，生成最终混淆后的文本。即，把“ABCD”编辑修改为“XYZD”，在DOM中写“XYZD”即可。</li>
</ol>
<p>最终效果就是，在DOM中写“XYZD”，展示出来的时候，展示为“ABCD”，如果需要展示“XYZ”本身，那么在DOM中写“CBA”。</p>
<p>下面给出一份代码Demo，根据提供的文本，随机从中间选出一些字符作为需要进行混淆的字符。然后从100个最常用的中文字符中，随机选出相同数量的字符作为混淆的目标字符。并最终返回混淆后的文本、字体文件，以及对应的映射关系。</p>
<p>支持指定混淆的等级，分别进行低、中、高不同程度以及全部文本字符的混淆：</p>
<p><code>fontObfuscateRandom.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> opentype = <span class="built_in">require</span>(<span class="string">&#x27;opentype.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; frequentlyUsedCnChar &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./const&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_FONT_PATH = path.resolve(__dirname, <span class="string">&#x27;./微软雅黑.ttf&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> OUTPUT_PATH = path.resolve(__dirname, <span class="string">&#x27;../output&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Randomly pop an element from the given array, and return it. Will modify the original array.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>arr The array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span> </span>The popped element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrRandomPop</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">  <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get specified count of random characters from the given list, excluding the characters in the except list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; string[] &#125;</span> </span>charList The list of characters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; number &#125;</span> </span>count The count of characters to get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; string[] &#125;</span> </span>exceptList The list of characters to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123; string &#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomCharsFromList</span>(<span class="params">charList, count, exceptList = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> charSet = <span class="keyword">new</span> <span class="built_in">Set</span>(charList);</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (result.length &lt; count) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * charSet.size);</span><br><span class="line">    <span class="keyword">const</span> randomChar = <span class="built_in">Array</span>.from(charSet)[index];</span><br><span class="line">    <span class="keyword">if</span> (exceptList.includes(randomChar)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(randomChar);</span><br><span class="line">    charSet.delete(randomChar);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef <span class="type">&#123; Object &#125;</span> <span class="variable">IObfuscatePlusParams</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123; string &#125;</span> </span>originalText The original text that need to obfuscate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123; &#x27;low&#x27; | &#x27;middle&#x27; | &#x27;high&#x27; | &#x27;all&#x27; &#125;</span> </span>obfuscateLevel The level of obfuscation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123; string &#125;</span> </span>fontName The name of the font family</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123; string &#125;</span> </span>fontFilename The name of the output font file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obfuscate a font by replacing the paths of glyphs with the paths of other glyphs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; IObfuscatePlusParams &#125;</span> <span class="variable">params</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123; Promise&lt;&#123; obfuscatedText: string, fontFilePath: string, obfuscatedMap: &#123; [key: string]: string &#125;</span> </span>&#125;&gt; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obfuscateRandom</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; originalText, obfuscateLevel, fontName, fontFilename &#125; = params;</span><br><span class="line">  <span class="keyword">const</span> allCharsSet = <span class="keyword">new</span> <span class="built_in">Set</span>(originalText);</span><br><span class="line">  <span class="keyword">const</span> levelMap = &#123; <span class="attr">low</span>: <span class="number">0.3</span>, <span class="attr">middle</span>: <span class="number">0.5</span>, <span class="attr">high</span>: <span class="number">0.7</span>, <span class="attr">all</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> countOfLevel = <span class="built_in">Math</span>.round(allCharsSet.size * levelMap[obfuscateLevel]);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="built_in">Math</span>.min(countOfLevel, frequentlyUsedCnChar.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obfuscateMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> oppositeMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> displayChars = getRandomCharsFromList(originalText, count);</span><br><span class="line">  <span class="keyword">const</span> obfuscateChars = getRandomCharsFromList(</span><br><span class="line">    frequentlyUsedCnChar,</span><br><span class="line">    count,</span><br><span class="line">    displayChars</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> displayChar = displayChars[i];</span><br><span class="line">    <span class="keyword">const</span> obfuscateChar = obfuscateChars[i];</span><br><span class="line">    obfuscateMap[displayChar] = obfuscateChar;</span><br><span class="line">  &#125;</span><br><span class="line">  obfuscateChars.forEach(<span class="function"><span class="params">obfuscateChar</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> randomDisplayChar = arrRandomPop(displayChars);</span><br><span class="line">    oppositeMap[obfuscateChar] = randomDisplayChar;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> finalMap = &#123; ...obfuscateMap, ...oppositeMap &#125;;</span><br><span class="line">  <span class="keyword">const</span> finalObfuscateList = <span class="built_in">Object</span>.keys(finalMap).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">displayChar</span>: key,</span><br><span class="line">    <span class="attr">obfuscatedChar</span>: finalMap[key],</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obfuscatedText = originalText</span><br><span class="line">    .split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">char</span> =&gt;</span> finalMap[char] || char)</span><br><span class="line">    .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    opentype.load(BASE_FONT_PATH, <span class="function">(<span class="params">err, font</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;Could not load font: &#x27;</span> + err);</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> obfuscatedGlyphs = finalObfuscateList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; displayChar, obfuscatedChar &#125; = item;</span><br><span class="line">        <span class="comment">// Get the glyph for the display character and the obfuscated character</span></span><br><span class="line">        <span class="keyword">const</span> displayGlyph = font.charToGlyph(displayChar);</span><br><span class="line">        <span class="keyword">const</span> obfuscatedGlyph = font.charToGlyph(obfuscatedChar);</span><br><span class="line">        <span class="comment">// Clone the obfuscated glyph and replace its path with the display glyph&#x27;s path</span></span><br><span class="line">        <span class="keyword">const</span> cloneObfuscatedGlyph = <span class="built_in">Object</span>.assign(</span><br><span class="line">          <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obfuscatedGlyph)),</span><br><span class="line">          obfuscatedGlyph</span><br><span class="line">        );</span><br><span class="line">        cloneObfuscatedGlyph.path = displayGlyph.path;</span><br><span class="line">        cloneObfuscatedGlyph.name = displayChar;</span><br><span class="line">        <span class="keyword">return</span> cloneObfuscatedGlyph;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This .notdef glyph is required, it&#x27;s used for characters that doesn&#x27;t have a glyph in the font</span></span><br><span class="line">      <span class="keyword">const</span> notDefGlyph = <span class="keyword">new</span> opentype.Glyph(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;.notdef&#x27;</span>,</span><br><span class="line">        <span class="attr">advanceWidth</span>: <span class="number">650</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="keyword">new</span> opentype.Path(),</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a new font object with the obfuscated glyphs</span></span><br><span class="line">      <span class="keyword">const</span> newFont = <span class="keyword">new</span> opentype.Font(&#123;</span><br><span class="line">        <span class="attr">familyName</span>: fontName,</span><br><span class="line">        <span class="attr">styleName</span>: <span class="string">&#x27;Regular&#x27;</span>,</span><br><span class="line">        <span class="attr">unitsPerEm</span>: font.unitsPerEm,</span><br><span class="line">        <span class="attr">ascender</span>: font.ascender,</span><br><span class="line">        <span class="attr">descender</span>: font.descender,</span><br><span class="line">        <span class="attr">glyphs</span>: [notDefGlyph, ...obfuscatedGlyphs],</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Save the new font to a file</span></span><br><span class="line">      <span class="keyword">const</span> outputFilePath = path.resolve(OUTPUT_PATH, <span class="string">`<span class="subst">$&#123;fontFilename&#125;</span>.ttf`</span>);</span><br><span class="line">      <span class="keyword">const</span> buffer = newFont.toArrayBuffer();</span><br><span class="line">      fs.writeFileSync(outputFilePath, Buffer.from(buffer));</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        obfuscatedText,</span><br><span class="line">        <span class="attr">fontFilePath</span>: outputFilePath,</span><br><span class="line">        <span class="attr">obfuscatedMap</span>: finalMap,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> obfuscateRandom(&#123;</span><br><span class="line">    <span class="attr">originalText</span>: <span class="string">&#x27;找到夺嫡密码的，自始至终都只有一个人而已。&#x27;</span>,</span><br><span class="line">    <span class="attr">obfuscateLevel</span>: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">    <span class="attr">fontName</span>: <span class="string">&#x27;MyObfuscatedFont&#x27;</span>,</span><br><span class="line">    <span class="attr">fontFilename</span>: <span class="string">&#x27;my-obfuscated-font&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;obfuscatedText: \n&#x27;</span>, result.obfuscatedText);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fontFilePath: \n&#x27;</span>, result.fontFilePath);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;obfuscatedMap: \n&#x27;</span>, result.obfuscatedMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure>

<p>运行之后效果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node ./src/fontObfuscateRandom.js</span></span><br><span class="line">obfuscatedText: </span><br><span class="line"> 找到部嫡进码的说量多至终机们点一个来分是。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fontFilePath: </span><br><span class="line"> /Users/your_user_name/font-obfucate-demo/output/my-obfuscated-font.ttf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obfuscatedMap: </span><br><span class="line"> &#123;</span><br><span class="line">  &#x27;只&#x27;: &#x27;们&#x27;,</span><br><span class="line">  &#x27;密&#x27;: &#x27;进&#x27;,</span><br><span class="line">  &#x27;而&#x27;: &#x27;分&#x27;,</span><br><span class="line">  &#x27;已&#x27;: &#x27;是&#x27;,</span><br><span class="line">  &#x27;夺&#x27;: &#x27;部&#x27;,</span><br><span class="line">  &#x27;始&#x27;: &#x27;多&#x27;,</span><br><span class="line">  &#x27;都&#x27;: &#x27;机&#x27;,</span><br><span class="line">  &#x27;，&#x27;: &#x27;说&#x27;,</span><br><span class="line">  &#x27;有&#x27;: &#x27;点&#x27;,</span><br><span class="line">  &#x27;人&#x27;: &#x27;来&#x27;,</span><br><span class="line">  &#x27;自&#x27;: &#x27;量&#x27;,</span><br><span class="line">  &#x27;们&#x27;: &#x27;已&#x27;,</span><br><span class="line">  &#x27;进&#x27;: &#x27;只&#x27;,</span><br><span class="line">  &#x27;分&#x27;: &#x27;自&#x27;,</span><br><span class="line">  &#x27;是&#x27;: &#x27;都&#x27;,</span><br><span class="line">  &#x27;部&#x27;: &#x27;而&#x27;,</span><br><span class="line">  &#x27;多&#x27;: &#x27;，&#x27;,</span><br><span class="line">  &#x27;机&#x27;: &#x27;有&#x27;,</span><br><span class="line">  &#x27;说&#x27;: &#x27;夺&#x27;,</span><br><span class="line">  &#x27;点&#x27;: &#x27;密&#x27;,</span><br><span class="line">  &#x27;来&#x27;: &#x27;人&#x27;,</span><br><span class="line">  &#x27;量&#x27;: &#x27;始&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="keyword">@font-face</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-family</span>: MyObfuscatedFont;</span></span><br><span class="line"><span class="css">        <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;my-obfuscated-font.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.myFont</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-family</span>: <span class="string">&#x27;MyObfuscatedFont&#x27;</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;myFont&quot;</span>&gt;</span>找到部嫡进码的说量多至终机们点一个来分是。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/21_final_res.png" alt="最终效果"></p>
<p>选中这段文字进行复制，复制到剪贴板的内容也是DOM中的“<em>找到部嫡进码的说量多至终机们点一个来分是。</em>”。</p>
<p>如果打开生成的字体文件看一下的话，会发现和上面讨论的那个网站的字体文件中的效果也是类似的：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/22_final_font.webp" alt="最终字体文件"></p>
<p>有我们生成的自定义的字形，并且和上面DOM和渲染中的结果也是一一对应的。</p>
<p>而如果进行了最大程度的混淆，即对原始文本中所有字符混淆，最终混淆的内容将完全不可读：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/23_final_res_full_obfuscate.png" alt="完全混淆"></p>
<p>而且由于是随机选择文本和目标字符进行混淆的，每次执行混淆脚本，都会生成完全不同的字体和混淆文本，这个也和上面内容里提到的效果对得上。</p>
<p>到此为止，我们也算是揭开了字形混淆的“神秘面纱”，也基本上通过代码实现了类似的效果，还可以进一步做的事情就是把字体文件进行base64编码并通过base64字符串来在CSS里引用了。</p>
<p>那除了上面的这些场景，字形混淆还有哪些用法呢？</p>
<h2 id="一些其他的用法"><a href="#一些其他的用法" class="headerlink" title="一些其他的用法"></a>一些其他的用法</h2><p>字形混淆除了用在上面的场景外，还有一种无关反爬虫或者恶意攻击的用法，那就是字体图标，比如比较出名的<a target="_blank" rel="noopener" href="https://www.iconfont.cn/">iconfont</a>，大家可能还用过。</p>
<p>这是阿里提供的一个矢量图标库，可以下载各种矢量图，同时也支持通过字体的方式来渲染图标。原理就是上面提到的，把一些字符的字形，改为一些icon图标的形状，在用这个图标的地方就可以通过下面这种方式来使用：</p>
<ol>
<li>声明字体</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;iconfont.tff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;tff&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用字体</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将字符渲染成icon</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe650;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以渲染出这个字符对应的图标，比如我这里：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/24_icon_font_demo.png" alt="iconfont demo"></p>
<p>这里有一个点要说一下，因为是使用了替换某些字符的字形来实现的icon，为了不影响这些字符的正常展示，肯定是不能把常用中文或者英文等字符的字形来进行替换的，所以目前我看到的是他们使用了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">Unicode第一平面</a>内的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%81%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%8C%BA">私人使用区</a>的一些字符：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/25_private_area_1.png" alt="私人使用区"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/26_private_area_2.webp" alt="私人使用区"></p>
<p>可以看到上面<code>span</code>里的字符<code>&amp;#xe650;</code>是用的Unicode的HTML实体字符的形式来写的，码位是<code>e650</code>，可以看到<code>e650</code>正好是落在了第一平面内的私人使用区范围内：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/27_private_area_3.png" alt="U+E650"></p>
<p>而顾名思义，私人使用区就是没有公共定义的Unicode区域，这些区域没有在Unicode标准中指定对应的具体字符是哪个，可以由个人或组织根据需要自行使用。把这些私人使用区的字符的字形，在字体文件中指定为需要使用到的icon，就可以做到不影响常用字符的渲染和展示了。</p>
<p>而且私人使用区内的字符，因为没有真正的字符来对应，在自定义字体文件没有加载好的时候，也不用担心会使用默认字体渲染出其他字符，而是会展示出一个框<code>口</code>，就像上面DOM结构里看到的那样。</p>
<p>那这种字体图标的好处在哪里呢？为什么不直接使用图片？其实目前看下来有以下几个优势：</p>
<ol>
<li>相比于图片，字体是矢量的，可以随意缩放而不影响图片的清晰度，在不同分辨率的屏幕上表现都很好</li>
<li>即使是图片中的矢量图SVG，体积大小也比字体文件中专门优化过的、效率更高的字形描述语言描述的字形，体积要更大，做了一个对比，同样是25个上面的那种图标，字体文件要比SVG的体积小上很多</li>
</ol>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/28_size_of_font_and_svg.png" alt="字体文件和SVG体积对比"></p>
<ol start="3">
<li>减少网络请求次数，如果每个SVG单独下载，那么会发起多个网络请求，但是如何合并到一个字体文件里，只需要一次网络请求即可</li>
<li>图标作为字体来渲染，可以像操作字体一样来操作图标，比如设置颜色、字重、斜体、字号等，常规图片展示则没办法通过这些来控制</li>
</ol>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/font_obfuscate/29_control_icon_font.png" alt="使用字体属性控制icon"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里这篇文章就差不多结束了，简单总结一下字形混淆在各个场景的应用：</p>
<h3 id="1-内容保护"><a href="#1-内容保护" class="headerlink" title="1. 内容保护"></a>1. 内容保护</h3><p>可以用在内容保护上，防止爬虫爬取或者文档剪藏工具剪藏，保护网站内容，不过从其他角度多想一下，感觉这种技术也不是没有缺点，比如下面的：</p>
<ul>
<li>可访问性：这种技术可能会影响到屏幕阅读器等辅助技术的使用，因为这些工具通常会读取DOM中原始的字符，而不是渲染后的字形</li>
<li>搜索引擎优化（SEO）：搜索引擎通常会索引网页的原始文本，而不是渲染后的文本。使用字形替换技术可能会影响到网站在搜索结果中的排名</li>
<li>用户体验：如果用户需要引用网站的内容，这种技术就可能会带来不好的用户体验。而且从防爬防复制角度来说，虽然这种技术可以防止用户直接复制文本，但是它不能防止用户通过其他方式获取文本，例如通过截图和OCR技术，甚至是物理拍照的方式，只能在某种程度上保护网站内容。</li>
</ul>
<p>另外除了字形混淆外，还有其他方式来保护内容，比如用canvas来渲染所有的文本内容，canvas元素本身只是一个绘图区域，里面的内容是通过JS绘制的，绘制的文本实际上是作为图像的一部分存在的，不会直接出现在HTML文档中。但是这种方案仍然存在上面的几个潜在问题。</p>
<p>综合来讲还是要根据自己的业务场景来区分是否要混淆，如果需要提高用户留存率，甚至是保护一些付费内容的话，还是很有字形混淆的必要性的。</p>
<h3 id="2-恶意攻击"><a href="#2-恶意攻击" class="headerlink" title="2. 恶意攻击"></a>2. 恶意攻击</h3><p>一些钓鱼网站或者垃圾邮件，可能通过这种技术来绕过检测和拦截进行攻击。同时我们要注意不受信的网站上复制的内容要注意也是不可信的，可能复制到非预期的危险内容，需要注意鉴别。</p>
<h3 id="3-icon图标"><a href="#3-icon图标" class="headerlink" title="3. icon图标"></a>3. icon图标</h3><p>通过对一些字符进行字形替换，可以用字体的方式来控制和渲染icon图标，做到比直接使用图片更好的展示效果和更低的开发成本。</p>
<p>这篇文章算是上一篇文章《<a target="_blank" rel="noopener" href="https://juejin.cn/post/7301908233320874025">字符编码简史：从二进制到UTF-8</a>》的一个延伸，分别从字符和字形的角度，探寻日常编程中那些不易察觉的微妙场景，感觉还是很有趣的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://help.fontlab.com/fontlab/7/manual/About-Glyphs/">About Glyphs: Character vs. Glyph</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@doctoreww/day-3-next-level-font-obfuscation-7a6cd978c7a5">Next Level Font Obfuscation</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@doctoreww/beating-plagiarism-checkers-for-science-step-by-step-1e477795e261">Beating Plagiarism Checkers for Science</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27381252">字号与行高</a></li>
<li><a target="_blank" rel="noopener" href="https://purplebamboo.github.io/2014/01/09/iconfont/">iconfont 记录</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/purplebamboo/blog/issues/18">iconfont字体生成原理及使用技巧 · Issue #18 · purplebamboo/blog</a></li>
<li><a target="_blank" rel="noopener" href="https://www.iconfont.cn/help/detail?spm=a313x.help_index.i3.28.79c43a81ttcV0a&helptype=code">iconfont-阿里巴巴矢量图标库-使用帮助</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7301908233320874025">字符编码简史：从二进制到UTF-8</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014291497/article/details/54915879">将base64格式的字体信息解码成可用的字体文件_base64字体-CSDN博客</a></li>
</ul>
<p><em>免责声明：本文以及文中涉及的代码仅用于个人学习交流，禁止转载。同时请勿将本文介绍的相关技术用于非法用途，对于非法用途或者滥用相关技术而产生的风险和相关的法律后果，与本文作者无关。请在阅读本文内容时，确保仅用于个人学习交流，并遵守当地法律法规。</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2024/05/08/%E5%89%8D%E7%AB%AF%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/08/%E5%89%8D%E7%AB%AF%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">前端视角下的鸿蒙开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-08 10:23:01" itemprop="dateCreated datePublished" datetime="2024-05-08T10:23:01+08:00">2024-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>鸿蒙系统，一个从诞生就一直处于舆论风口浪尖上的系统，从最开始的“套壳”安卓的说法，到去年的不再兼容安卓的NEXT版本的技术预览版发布，对于鸿蒙到底是什么，以及鸿蒙的应用开发的讨论从来没停止过。</p>
<p>这次我们就从一个前端开发的角度来了解一下鸿蒙，学习一下鸿蒙应用的开发。</p>
</blockquote>
<h2 id="一、-什么是鸿蒙"><a href="#一、-什么是鸿蒙" class="headerlink" title="一、 什么是鸿蒙"></a>一、 什么是鸿蒙</h2><p>在开始之前，先问大家一个问题，大家听说过几种鸿蒙？</p>
<p>其实到目前为止，我们经常听到的鸿蒙系统，总共有三种，分别是：</p>
<p>OpenHarmony，HarmonyOS，以及HarmonyOS NEXT。</p>
<h3 id="1-OpenHarmony"><a href="#1-OpenHarmony" class="headerlink" title="1. OpenHarmony"></a>1. OpenHarmony</h3><p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/open_harmony.png" alt="OpenHarmony"></p>
<p><a target="_blank" rel="noopener" href="https://www.openharmony.cn/">OpenHarmony（开源鸿蒙系统）</a>，由开放原子开源基金会进行管理。开放原子开源基金会由华为、阿里、腾讯、百度、浪潮、招商银行、360等十家互联网企业共同发起组建。包含了“鸿蒙操作系统”的基础能力，是“纯血”鸿蒙的底座。</p>
<p>这个版本的鸿蒙是开源的，代码仓库的地址在这里：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony">https://gitee.com/openharmony</a>。</p>
<p>从我个人的一些粗浅理解来看，OpenHarmony类似于Android里的AOSP，可以装到各种设备上，比如手表、电视甚至是一些嵌入式设备上，详见可见官网的一些<a target="_blank" rel="noopener" href="https://www.openharmony.cn/armList/?id=6">例子</a>。</p>
<h3 id="2-HarmonyOS"><a href="#2-HarmonyOS" class="headerlink" title="2. HarmonyOS"></a>2. HarmonyOS</h3><p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/harmony_os.png" alt="HarmonyOS"></p>
<p>基于 OpenHarmony、AOSP等开源项目，同时加入了自己的HMS（因为被美国限制后无法使用GMS）的商用版本，可以兼容安卓，也可以运行部分OpenHarmony开发的鸿蒙原生应用。</p>
<p>这个也是目前经常被吐槽是“套壳”安卓的系统，截止到目前（2024.04）已经更新到了HarmonyOS 4.2。</p>
<h3 id="3-HarmonyOS-NEXT"><a href="#3-HarmonyOS-NEXT" class="headerlink" title="3. HarmonyOS NEXT"></a>3. HarmonyOS NEXT</h3><p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/harmony_os_next.png" alt="HarmonyOS NEXT"></p>
<p>2023年秋季发布的技术预览版，在当前HarmonyOS的基础上去除了AOSP甚至是JVM，不再兼容安卓，只能运行鸿蒙原生应用，同时对OpenHarmony的能里进行了大量的更新，增加和修改了很多API。</p>
<p>这个也就是所谓的“纯血”鸿蒙系统，可惜的是这个目前我们用不到，需要以公司名义找华为合作开权限，或者个人开发者使用一台Mate60 Pro做专门的开发机。并且目前由于有保密协议，网上也没有太多关于最新API的消息。</p>
<blockquote>
<p>NEXT版本文档：<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-releases/releasenotes-overview-0000001602419138">https://developer.huawei.com/consumer/cn/doc/harmonyos-releases/releasenotes-overview-0000001602419138</a></p>
</blockquote>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/can_not_access_next_doc.png" alt="无法直接访问的NEXT版本的开发文档"></p>
<p>据说目前HarmonyOS NEXT使用的API版本已经到了API12，目前官网可以访问的最新文档还是API9，所以接下来的内容也都是基于API9的版本来的。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>所以一个粗略的视角来看，OpenHarmony、HarmonyOS以及HarmonyOS NEXT这三者之间的关系是这样的：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/relationship.png" alt="三者之间的关系"></p>
<h2 id="二、-初识鸿蒙开发"><a href="#二、-初识鸿蒙开发" class="headerlink" title="二、 初识鸿蒙开发"></a>二、 初识鸿蒙开发</h2><p>在大概知道了什么是鸿蒙之后，我们先来简单看一下鸿蒙开发的套件。下图是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">官网</a>所描述的一些开发套件，包括了设计、开发、测试、上架所涉及到的技术和产品。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/development_kit.png" alt="鸿蒙开发套件"></p>
<p>我们这篇文章里主要讨论右下角的三个：<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkts/">ArkTS</a>、<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkui/">ArkUI</a>、<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">ArkCompiler</a>。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/arkts_arkui.png" alt="ArkTS&amp;ArkUI"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/arkcompiler.png" alt="ArkCompiler"></p>
<h2 id="三、-关于ArkTS的一些疑惑"><a href="#三、-关于ArkTS的一些疑惑" class="headerlink" title="三、 关于ArkTS的一些疑惑"></a>三、 关于ArkTS的一些疑惑</h2><p>作为一个前端开发，最常用的编程语言就是JavaScript或者TypeScript，那么在看到鸿蒙应用开发用到的编程语言是ArkTS之后，我脑子里最先蹦出来的就是下面这几个问题：</p>
<p><strong>1. ArkTS语言的运行时是啥？</strong><br>   既然编程语言是TS（TS的拓展，ArkTS），那么它的运行时是什么呢？是V8？JSC？Hermes？还是其他什么呢？<br><strong>2. ArkTS还是单线程语言吗？</strong><br>   ArkTS还是和JS一样，是单线程语言吗？<br><strong>3. 基于TS拓展了什么？</strong><br>   TS是JS的超集，对JS进行了拓展，增加了开发时的类型支持。而ArkTS对对TS又进行了拓展，是TS的超集，那它基于TS拓展了什么内容呢？</p>
<p>下面我们一个一个来看。</p>
<h3 id="1-Question1-ArkTS语言的运行时"><a href="#1-Question1-ArkTS语言的运行时" class="headerlink" title="1. Question1 - ArkTS语言的运行时"></a>1. Question1 - ArkTS语言的运行时</h3><p>先说结论，ArkTS的运行时不是V8，不是JSC、Hermes，不是目前任何一种JS引擎。ArkTS的运行时是一个自研的运行时，叫做方舟语言运行时（简称方舟运行时）。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/runtime.png" alt="方舟运行时"></p>
<p>而这个运行时，执行的也不是JS/TS/ArkTS代码，而是执行的<strong>字节码和机器码</strong>。<br>这是因为方舟运行时是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">ArkCompiler（方舟编译器）</a>的一部分，对于JS/TS/ArkTS的编译在运行前就进行了（和Hermes有点像，下面会讲到）。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/dev_framework.png" alt="方舟开发框架示意图"></p>
<p>我们来简单了解一下ArkCompiler，从官网的描述可以看到，ArkCompiler关注的重点主要有三个方面：</p>
<ul>
<li>AOT 编译模式</li>
<li>LiteActor 轻量化并发</li>
<li>源码安全</li>
</ul>
<h4 id="AOT-编译模式"><a href="#AOT-编译模式" class="headerlink" title="AOT 编译模式"></a>AOT 编译模式</h4><p>首先是编译模式，我们知道，目前编程语言大多以下几方式运行：</p>
<ul>
<li>机器码AOT编译<br>在程序运行之前进行AST生成和代码编译，编译为机器码，在运行的时候无需编译，直接运行，比如C语言。</li>
<li>中间产物AOT编译<br>在程序运行前进行AST生成并进行编译，但不是编译为机器码，而是编译为中间产物，之后在运行时将字节码解释为机器码再执行。比如Hermes或Java编译为字节码，之后运行时由Hermes引擎或JVM解释执行字节码。</li>
<li>完全的解释执行<br>在程序运行前不进行任何编译，在运行时动态地根据源码生成AST，再编译为字节码，最后解释执行字节码。比如没有开启JIT的V8引擎执行JS代码时的流程。</li>
<li>混合的JIT编译<br>在通过解释执行字节码时（运行时动态生成或者AOT编译生成），对多次执行的热点代码进行进一步的优化编译，生成机器码，后续执行到这部分逻辑时，直接执行优化后的机器码。比如<a target="_blank" rel="noopener" href="https://juejin.cn/post/7179130165262286885">开启JIT的V8引擎</a>运行JS或者<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">支持JIT的JVM</a>运行class文件。</li>
</ul>
<blockquote>
<p>当然，以上仅考虑生产环境下的运行方式，不考虑部分语言在生产和开发阶段不同的运行方式。比如Dart和Swift，一般是开发阶段通过JIT实时编译快速启动，生产环境下为了性能通过AOT编译。</p>
</blockquote>
<p>在V8 JIT出现之前，所有的JS虚拟机所采用的都是采用的<strong>完全解释执行</strong>的方式，在运行时把源码生成AST语法树，之后生成字节码，然后将字节码解释为机器码执行，这是JS执行速度过慢的主要原因之一。</p>
<p>而这么做有以下两个方面的原因：</p>
<ul>
<li>JS是动态语言，变量类型在运行时可能改变</li>
<li>JS主要用于Web应用，Web应用如果提前编译为字节码将导致体积增大很多，对网络资源的消耗会更大</li>
</ul>
<p>我们一个一个来说。</p>
<h5 id="a-JS变量类型在运行时可能改变"><a href="#a-JS变量类型在运行时可能改变" class="headerlink" title="a. JS变量类型在运行时可能改变"></a>a. JS变量类型在运行时可能改变</h5><p>首先我们来看一张图，这张图描述了现在V8引擎的工作流程，目前Chrome和Node里的JS引擎都是这个：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/v8_work_flow.png" alt="V8现有工作流程"></p>
<p>从上面可以看到，V8在拿到JS源码后，会先解析成AST，之后经过Ignition解释器把语法树编译成字节码，然后再解释字节码执行。</p>
<p>于此同时还会收集热点代码，比如代码一共运行了多少次、如何运行的等信息，也就是上面的Feedback的流程。</p>
<p>如果发现一段代码会被重复执行，则监视器会将此段代码标记为热点代码，交给V8的Turbofan编译器对这段字节码进行编译，编译为对应平台（Intel、ARM、MIPS等）的二进制机器码，并执行机器码，也就是图里的Optimize流程。</p>
<p>等后面V8再次执行这段代码，则会跳过解释器，直接运行优化后的机器码，从而提升这段代码的运行效率。</p>
<p>但是我们发现，图里面除了Optimize外，还有一个Deoptimize，<strong>反优化</strong>，也就是说被优化成机器码的代码逻辑，可能还会被反优化回字节码，这是为什么呢？</p>
<p>其实原因就是上面提到的“JS变量类型在运行时可能改变”，我们来看一个例子：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/type_change_in_js.png" alt="JS变量类型在运行时可能改变"></p>
<p>比如一个<code>add</code>函数，因为JS没有类型信息，底层编译成字节码后伪代码逻辑大概如这张图所示。会判断<code>x</code>和<code>y</code>的各种类型，逻辑比较复杂。</p>
<p>在Ignition解释器执行<code>add(1, 2)</code>时，已经知道<code>add</code>函数的两个参数都是整数，那么TurboFan在进一步编译字节码时，就可以假定<code>add</code>函数的参数是整数，这样可以极大地简化生成的汇编代码，不再判断各种类型，伪代码如第三张图里所示。</p>
<p>接下来的<code>add(3, 4)</code>与<code>add(5, 6)</code>由于入参也是整数，可以直接执行之前编译的机器码，但是<code>add(&quot;7&quot;, &quot;8&quot;)</code>时，发现并不是整数，这时候就只能将这段逻辑Deoptimize为字节码，然后解释执行字节码。</p>
<p>这就是所谓的Deoptimize，<strong>反优化</strong>。可以看出，如果我们的JS代码中变量的类型变来变去，是会给V8引擎增加不少麻烦，为了提高性能，我们可以尽量不要去改变变量的类型。</p>
<p>虽然说使用TS可以部分缓解这个问题，但是TS只能约束<strong>开发时</strong>的类型，运行的时候TS的类型信息是会被丢弃的，也无法约束，V8还是要做上面的一些假定类型的优化，无法一开始就编译为机器码。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/type_info_discarded.png" alt="TS类型信息运行时被丢弃"></p>
<p>可以说TS的类型信息被浪费了，没有给运行时代码特别大的好处。</p>
<h5 id="b-JS编译为字节码将导致体积增大"><a href="#b-JS编译为字节码将导致体积增大" class="headerlink" title="b. JS编译为字节码将导致体积增大"></a>b. JS编译为字节码将导致体积增大</h5><p>上面说到JS主要用于Web应用，Web应用如果提前编译为字节码将导致体积增大很多，对网络资源的消耗会更大。那么对于非Web应用，其实是可以做到提前编译为字节码的，比如Hermes引擎。</p>
<p>Hermes作为React Native的运行时，是作为App预装到用户的设备上，除了热更新这种场景外，绝大部分情况下是不需要打开App时动态下载代码资源的，所以体积增大的问题影响不是很大，但是预编译带来的运行时效率提升的好处却比较明显。</p>
<p>所以相对于V8，Hermes<a target="_blank" rel="noopener" href="https://supercodepower.com/mobile-javascript-engines#3hermes">去掉了JIT，支持了生成字节码</a>，在构建App的时候，就把JS代码进行了预编译，预编译为了Hermes运行时可以直接处理的字节码，省去了在运行阶段解析AST语法树、编译为字节码的工作。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/optimize_in_hermes.png" alt="Hermes对JS编译和执行流程的改进"></p>
<blockquote>
<p>一句题外话，Hermes去除了对JIT的支持，除了因为JIT会导致JS引擎启动时间变长、内存占用增大外，还有一部分可能的原因是，在iOS上，苹果为了<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21320960/answer/18628710">安全考虑</a>，不允许除了Safari和WebView（只有WKWebView支持JIT，UIWebView不支持）之外的第三方应用里直接使用JSC的JIT能力，也不允许第三方JS运行时支持JIT（<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/429797868">相关问题</a>）。</p>
<p>甚至V8专门出了一个去掉JIT的<a target="_blank" rel="noopener" href="https://supercodepower.com/mobile-javascript-engines#2v8">JIT-less V8</a>版本来在iOS上集成，Hermes似乎也不太可能完全没考虑到这一点。</p>
</blockquote>
<h5 id="c-取长补短"><a href="#c-取长补短" class="headerlink" title="c. 取长补短"></a>c. 取长补短</h5><p>在讨论了V8的JIT和Hermes的预编译之后，我们再来看看ArkCompiler，截取一段<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">官方博客里的描述</a>：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/blog_desc_of_arkcompiler.png" alt="博客描述"></p>
<p>还记得上面说的“TS的类型信息被浪费了”吗？TS的类型信息只在开发时有用，在编译阶段就被丢弃了，而ArkCompiler就是利用了这一点，直接在App构建阶段，利用TS的类型信息直接预编译为字节码以及优化机器码。</p>
<p>即在ArkCompiler中，不存在TS-&gt;JS的这一步转译，而是直接从TS编译为了字节码和优化机器码（这里存疑，官网文档没有找到很明确的说法，不是特别确定是否有TS-&gt;JS的转译）。</p>
<p>同时由于鸿蒙应用也是一个App而不是Web应用，所以ArkCompiler和Hermes一样，也是在构建App时就进行了预编译，而不是在运行阶段做这个事情。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/optimize_in_arkcompiler.png" alt="ArkCompiler对JS/TS编译和执行流程的改进"></p>
<p>简单总结下来，ArkCompiler像Hermes一样支持生成字节码，同时又将V8引擎JIT生成机器码的工作也提前在预编译阶段做了。是比Hermes只生成字节码的AOT更进一步的AOT（同时生成字节码和部分优化后的机器码）。</p>
<h4 id="LiteActor轻量化并发"><a href="#LiteActor轻量化并发" class="headerlink" title="LiteActor轻量化并发"></a>LiteActor轻量化并发</h4><p>到这里其实已经可以回答上面讲到的第二个问题了，ArkTS还是单线程语言吗？</p>
<p>答案是：是的，还是单线程语言。但是ArkTS里通过<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/taskpool-vs-worker-0000001632849934-V2">Worker和TaskTool</a>这两种方式支持并发。</p>
<p>同时ArkCompiler对现有的Worker进行了一些优化，直接看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">官网博客</a>：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/lite_actor.png" alt="LiteActor轻量化并发"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/blog_desc_of_lite_actor.png" alt="LiteActor轻量化并发博客描述"></p>
<p>这里的Actor是什么呢？Actor是一种并发编程里的线程模型。</p>
<p>线程模型比较常见的就是共享内存模型，多个线程之间共享内存，比如Java里多个线程共享内存数据，需要通过<code>synchronized</code>同步锁之类的来防止数据一致性的问题。</p>
<p>Actor模型是另一种线程模型，“Actor”是处理并发计算的基本单位，每个Actor都有自己的状态，并且可以接收和发送消息。当一个Actor接收到消息时，它可以改变自己的状态，发送消息给其他Actor，或者创建新的Actor。</p>
<p>这种模型可以帮助开发者更好地管理复杂的状态和并发问题，因为每个Actor都是独立的，它们之间不会共享状态，这可以避免很多并发问题。同时，Actor模型也使得代码更易于理解和维护，因为每个Actor都是独立的，它们的行为可以被清晰地定义和隔离。</p>
<p>到这里大家应该已经比较明白了，前端里的Web Worker就是这种线程模型的一种体现，通过Worker来开启不同的线程。</p>
<h4 id="源码安全"><a href="#源码安全" class="headerlink" title="源码安全"></a>源码安全</h4><p>按照<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">官网</a>的说法，ArkCompiler会把ArkTS编译为字节码，并且ArkCompiler使用多种混淆技术提供更高强度的混淆与保护，使得HarmonyOS应用包中装载的是多重混淆后的字节码，有效提高了应用代码安全的强度。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/source_code_security.gif" alt="源码安全"></p>
<h3 id="2-Question2-ArkTS还是单线程语言吗"><a href="#2-Question2-ArkTS还是单线程语言吗" class="headerlink" title="2. Question2 - ArkTS还是单线程语言吗"></a>2. Question2 - ArkTS还是单线程语言吗</h3><p>这个刚刚已经回答了，还是单线程语言，借用官网的描述：</p>
<blockquote>
<p>HarmonyOS应用中每个进程都会有一个主线程，主线程有如下职责：</p>
<ol>
<li>执行UI绘制；</li>
<li>管理主线程的ArkTS引擎实例，使多个UIAbility组件能够运行在其之上；</li>
<li>管理其他线程（例如Worker线程）的ArkTS引擎实例，例如启动和终止其他线程；</li>
<li>分发交互事件；</li>
<li>处理应用代码的回调，包括事件处理和生命周期管理；</li>
<li>接收Worker线程发送的消息；</li>
</ol>
<p>除主线程外，还有一类与主线程并行的独立线程Worker，主要用于执行耗时操作，但不可以直接操作UI。Worker线程在主线程中创建，与主线程相互独立。最多可以创建8个Worker。</p>
</blockquote>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/threading_model.png" alt="ArkTS线程模型"></p>
<h3 id="3-Question3-基于TS拓展了什么"><a href="#3-Question3-基于TS拓展了什么" class="headerlink" title="3. Question3 - 基于TS拓展了什么"></a>3. Question3 - 基于TS拓展了什么</h3><p>当前，ArkTS在TS的基础上主要扩展了如下能力：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-basic-syntax-overview-0000001531611153-V2">基本语法</a>：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-management-overview-0000001524537145-V2">状态管理</a>：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。</li>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-rendering-control-overview-0000001543911149-V2">渲染控制</a>：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li>
</ul>
<p>而上面这些，也就是我们接下来要介绍的ArkTS+ArkUI的语法。</p>
<h2 id="四、-ArkTS-amp-ArkUI"><a href="#四、-ArkTS-amp-ArkUI" class="headerlink" title="四、 ArkTS &amp; ArkUI"></a>四、 ArkTS &amp; ArkUI</h2><p>首先，在聊ArkUI之前，还有一个问题大家可能比较感兴趣：ArkUI是怎么渲染我们写的UI呢？</p>
<p>答案是<strong>自绘</strong>，类似于Flutter，使用自己的渲染引擎（应该是发展于Skia），而不是像RN那样将UI转为不同平台上的底层UI。</p>
<p>不管是从官网的描述[<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkui/">1</a>]、[<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-ui-development-overview-0000001438467628-V2">2</a>]来看，还是社区里的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7280006531922673719#heading-0">讨论</a>来看，ArkUI的渲染无疑是自绘制的，并且ArkUI和Flutter之间的联系很密切：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/discuss_of_arkui.png" alt="社区里的一些讨论"></p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><p>从前端的角度来看，ArkTS和ArkUI的定位其实就是类似于前端中TS+React+配套状态管理工具（如Redux），可以用TS写声明式UI（有点像写jsx），下面是基本语法：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/basic_grammar.png" alt="基本语法"></p>
<ul>
<li>装饰器<br>用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2#section1430055924816">@Component</a>表示自定义组件，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2#section1430055924816">@Entry</a>表示该自定义组件为入口组件，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-0000001474017162-V2">@State</a>表示组件中的状态变量，状态变量变化会触发UI刷新</li>
<li>自定义组件<br>可复用的UI单元，可组合其他组件，如上述被@Component装饰的<code>struct Hello</code></li>
<li>UI描述<br>以声明式的方式来描述UI的结构，例如<code>build()</code>方法中的代码块</li>
<li>系统组件<br>ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的<code>Column</code>、<code>Text</code>、<code>Divider</code>、<code>Button</code></li>
<li>事件方法<br>组件可以通过链式调用设置多个事件的响应逻辑，如跟随在<code>Button</code>后面的<code>onClick()</code></li>
<li>属性方法<br>组件可以通过链式调用配置多项属性，如<code>fontSize()</code>、<code>width()</code>、<code>height()</code>、<code>backgroundColor()</code>等</li>
</ul>
<h3 id="2-数据驱动UI"><a href="#2-数据驱动UI" class="headerlink" title="2. 数据驱动UI"></a>2. 数据驱动UI</h3><p>作为一个声明式的UI框架，ArkUI和其他众多UI框架（比如React、Vue）一样，都是通过数据来驱动UI变化的，即<code>UI = f(State)</code>。我们这里引用一下官网的描述：</p>
<blockquote>
<p>在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。</p>
<p>自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。</p>
</blockquote>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/state_and_ui.png" alt="State和UI"></p>
<blockquote>
<p>View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。<br>State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。</p>
</blockquote>
<p>在ArkUI中，提供了大量的状态管理相关的装饰器，比如<code>@State</code>、<code>@Prop</code>、<code>@Link</code>等。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/overview_of_state.png" alt="ArkTS &amp; ArkUI的状态管理总览"></p>
<p>更多细节详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-management-0000001524177629-V2">状态管理</a>。</p>
<h3 id="3-渲染控制"><a href="#3-渲染控制" class="headerlink" title="3. 渲染控制"></a>3. 渲染控制</h3><p>在ArkUI中，可以像React那样，通过<code>if else</code>，<code>for each</code>等进行跳转渲染、列表渲染等，更多细节详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-rendering-control-0000001504769325-V2">渲染控制</a>。</p>
<blockquote>
<p>ArkUI通过<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2">自定义组件</a>的<code>build()</code>函数和<code>@builder</code><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-builder-0000001524176981-V2">装饰器</a>中的声明式UI描述语句构建相应的UI。在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助UI的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句以及针对大数据量场景的数据懒加载语句。</p>
</blockquote>
<h3 id="4-更多语法"><a href="#4-更多语法" class="headerlink" title="4. 更多语法"></a>4. 更多语法</h3><p>语法其实不是我们这篇文章的重点，上面是一些大概的介绍，更多语法可以详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-basic-syntax-0000001504650057-V2">官网</a>，或者我的另外一篇专门讲解语法的笔记《前端视角下的ArkTS语法》(先留个占位符，有时间了补充一下)。</p>
<h3 id="5-ArkTS-amp-ArkUI小结"><a href="#5-ArkTS-amp-ArkUI小结" class="headerlink" title="5. ArkTS &amp; ArkUI小结"></a>5. ArkTS &amp; ArkUI小结</h3><p>从前面的内容其实可以看到，ArkUI和RN相似点还挺多的：</p>
<ol>
<li>都是使用JS/TS作为语言（ArkTS）</li>
<li>都有自己的JS引擎/运行时（ArkCompiler，方舟运行时）</li>
<li>引擎还都支持直接AOT编译成字节码</li>
</ol>
<p>不同的是RN是将JS声明的UI，转换成iOS、Android原生的组件来渲染，而ArkUI则是采用自绘制的渲染引擎来自绘UI。</p>
<p>从这点来看，鸿蒙更像是Flutter，只不过把开发语言从Dart换成了JS/TS（ArkTS），和Flutter同样是自绘制的渲染引擎。</p>
<p>社区里其实也有类似的思考：<a target="_blank" rel="noopener" href="https://supercodepower.com/cross-platform-tech#6%E5%85%B6%E5%AE%83%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2js-engine--flutter-rnderpipeline">其它方向的探索：JS Engine + Flutter RenderPipeLine</a>。而ArkUI则是对这种思路的实现。</p>
<p>感觉这也可以从侧面解释为什么ArkUI的语法和Flutter比较像，应该参考了不少Flutter的实现（比如渲染引擎）。</p>
<p>而华为宣称鸿蒙可以反向兼容Flutter甚至是RN也就没有那么难以理解了，毕竟ArkUI里Flutter和RN的影子确实不少。</p>
<p>另外,除了ArkUI以外，华为还提供了一个跨平台的开发框架<a target="_blank" rel="noopener" href="https://gitee.com/arkui-x">ArkUI-X</a>，可以像Flutter那样，跨HarmonyOS、Android、iOS三个平台。</p>
<p>这么看来，ArkTS&amp;ArkUI从开发语言、声明式UI的语法、设计思想来看，不管是前端、iOS、安卓、或者Flutter、RN，鸿蒙应用开发都是比较入门友好的。</p>
<h2 id="五、-其他"><a href="#五、-其他" class="headerlink" title="五、 其他"></a>五、 其他</h2><h3 id="1-包管理工具"><a href="#1-包管理工具" class="headerlink" title="1. 包管理工具"></a>1. 包管理工具</h3><p>HarmonyOS开发中，使用的包管理工具是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ide-command-line-ohpm-0000001490235312-V2">ohpm</a>，目前看来像是一个借鉴<a target="_blank" rel="noopener" href="https://pnpm.io/">pnpm</a>的三方包管理工具，详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ide-command-line-ohpm-0000001490235312-V2">官方文档</a>。</p>
<p>另外，鸿蒙也提供了第三方包发布的仓库：<a target="_blank" rel="noopener" href="https://ohpm.openharmony.cn/">https://ohpm.openharmony.cn</a>。</p>
<h3 id="2-应用程序结构"><a href="#2-应用程序结构" class="headerlink" title="2. 应用程序结构"></a>2. 应用程序结构</h3><p>在鸿蒙系统中，一个应用包含一个或者多个Module，每一个Module都可以独立进行编译和运行。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/architecture_of_app.png" alt="应用程序结构"></p>
<p>发布时，每个Module编译为一个<code>.hap</code>后缀的文件，即HAP。每个HarmonyOS应用可以包含多个<code>.hap</code>文件。</p>
<p>在应用上架到应用市场时，需要把应用包含的所有<code>.hap</code>文件打包为一个<code>.app</code>后缀的文件用于上架。</p>
<p>但是<code>.app</code>包不能直接安装到设备上，只是上架应用市场的单元，安装到设备上的是<code>.hap</code>。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/architecture_of_build.png" alt="打包结构"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/architecture_of_dev_build.png" alt="开发态和打包后视图"></p>
<p>鸿蒙应用的整体开发调试与发布部署流程大概是这样的：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/harmony_os_getting_started/dev-debug-release-deploy.png" alt="开发-调试-发布-部署"></p>
<p>HAP可分为Entry和Feature两种类型：</p>
<ul>
<li><strong>Entry类型的HAP</strong>：是应用的主模块<br>在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。</li>
<li><strong>Feature类型的HAP</strong>：是应用的动态特性模块<br>一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含；Feature类型的HAP通常用于实现应用的特性功能，可按需下载安装</li>
</ul>
<p>而设计成多hap，主要是有3个目标：</p>
<ol>
<li>为了解耦应用的各个模块，比如一个支付类型的App，Entry类型的hap可以是首页主界面，上面的扫一扫、消息、理财等可以的feature类型的HAP</li>
<li>方便开发者将多HAP合理地组合并部署到不同的设备上，比如有三个HAP，Entry、Feature1和Feature2，其中A类型的设备只能部署Entry和Feature1。B类型的设备只能部署Entry和Feature2</li>
<li>方便应用资源共享，减少程序包大小。多个HAP都需要用到的资源文件可以放到单独的HAP中</li>
</ol>
<blockquote>
<p>多说一句：从这些描述来看，给我的感觉是每个.hap有点类似于前端项目中Mono-repo仓库中的一个package，各个package之间有一定的依赖，同时每个package可以独立发布。</p>
</blockquote>
<p>另外，HarmonyOS也支持类似RN热更新的功能，叫做<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/quickfix-principles-0000001493743976-V2">快速修复（quick fix）</a>。</p>
<h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>现在再回到最开始那个问题：什么是鸿蒙？从前端视角来看，它是这样一个系统：</p>
<ul>
<li>ArkTS作为应用开发语言</li>
<li>类Flutter、Compose、Swift的声明式UI语法</li>
<li>和React有些相似的数组驱动UI的设计思想</li>
<li>ArkCompiler进行字节码和机器码的AOT编译 + 方舟运行时</li>
<li>类似Flutter Skia渲染引擎的自绘制渲染引擎</li>
<li>通过提供一系列ohos.xxx的系统内置包来提供TS访问系统底层的能力（比如网络、媒体、文件、USB等）</li>
</ul>
<p>所以关于HarmonyOS是不是安卓套壳，个人感觉其实已经比较明了了：以前应该是，但快要发布的HarmonyOS NEXT大概率不再是了。</p>
<h3 id="其他一些讨论"><a href="#其他一些讨论" class="headerlink" title="其他一些讨论"></a>其他一些讨论</h3><p>其实在华为宣布了HarmonyOS NEXT不再兼容安卓后，安卓套壳的声音越来越少了，但现在网上另外一种声音越来越多了：</p>
<blockquote>
<ol>
<li>HarmonyOS NEXT是一个大号的小程序底座，上面的应用都是网页应用，应用可以直接右键查看源码，没有安全性可言</li>
<li>HarmonyOS NEXT上的微信小程序就是在小程序里运行小程序</li>
<li>因为使用的是ArkTS开发，所以的HarmonyOS NEXT上的应用性能必然很差</li>
</ol>
</blockquote>
<p>这种说法往往来自于只知道鸿蒙系统应用开发语言是TS，但是没有去进一步了解的人，而且这种说法还有很多人信。其实只要稍微看下文档，就知道这种说法是<strong>完全错误的</strong>。</p>
<p>首先它的View层不是DOM，而是类似Flutter的自绘制的渲染引擎，不能因为使用了TS就说是网页，就像可以说React Web是网页应用，但不能说React Native是网页应用，同样也不是说Flutter是网页应用。</p>
<p>另外开发语言本身并不能决定最终运行性能，还是要看编译器和运行时的优化。同样是JS，从完全的解释执行（JS-&gt;AST-&gt;字节码-&gt;执行），到开启JIT的V8，性能都会有质的飞跃。从一些<a target="_blank" rel="noopener" href="https://github.com/GoodManWEN/Programming-Language-Benchmarks-Visualization">编程语言性能测试</a>中可以看到，开启JIT的NodeJs的性能，甚至和Flutter所使用的Dart差不多。</p>
<p>而ArkCompiler是结合了Hermes和V8 JIT的特点，AOT编译为字节码和机器码，所以理论上讲性能应该相当不错。</p>
<p>（当然我也没有实机可以测试，只能根据文档来分析）。</p>
<p>上面这种HarmonyOS NEXT是网页应用的说法还有可能是由于，最早鸿蒙应用支持使用HTML、CSS、JS三件套进行<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ui-js-overview-0000001428061548-V2">兼容Web的开发</a>，导致了刻板印象。这种开发方式使用的是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-with-js-fa-0000001428061452-V2">FA模型</a>，而目前这种方式已经<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/application-model-description-0000001493584092-V2">不是鸿蒙主推的开发方式了</a>。</p>
<p>到这里这篇文章就结束了，整体上是站在一个前端开发的视角下来认识和了解鸿蒙开发的，希望能帮助一些像我一样对鸿蒙开发感兴趣的前端开发入门。大家如果感兴趣可以到<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">鸿蒙官网</a>查看更多的了解。</p>
<p>如果感觉对你有帮助，可以点个赞哦~</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">华为开发者联盟-HarmonyOS开发者官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.openharmony.cn/">OpenHarmony</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/arkui-x">ArkUI-X</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">不同设备如何统一语言编程平台高效开发？本文为你揭秘</a></li>
<li><a target="_blank" rel="noopener" href="https://supercodepower.com/mobile-javascript-engines">🤔 移动端 JS 引擎哪家强？美国硅谷找…… | 卤代烃实验室</a></li>
<li><a target="_blank" rel="noopener" href="https://supercodepower.com/cross-platform-tech">🎯【深入解析】跨端框架的核心技术到底是什么？ | 卤代烃实验室</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21320960/answer/18628710">苹果为何又如何在 iOS 上禁止 Safari 之外的应用使用 Nitro JIT 编译？ - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7179130165262286885">一次看懂V8引擎与JIT原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7280006531922673719">Harmony 开始支持 Flutter ，聊聊 Harmony 和 Flutter 之间的因果</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2024/01/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84void%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84void%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">你不知道的 void 运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-27 18:26:00" itemprop="dateCreated datePublished" datetime="2024-01-27T18:26:00+08:00">2024-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>void</code>运算符，一个在 JavaScript 中很常见，但你却不一定很熟悉的运算符。它出现在各个地方，你可能在下面这些地方见到过：</p>
<ul>
<li><p>HTML的<code>a</code>标签里</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span>&gt;</span>This is a link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JS表达式（尤其是 tsc 或者 babel 编译后的代码里）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = foo === <span class="literal">null</span> || foo === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : foo.bar;</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> <span class="keyword">void</span> doSomething();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>那么<code>void</code>运算符的作用究竟是什么呢？</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之所以突然聊这个，是因为在某次代码CR里讨论到了TypeScript的<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">可选链（Optional Chaining）</a>语法（当然从<a target="_blank" rel="noopener" href="https://262.ecma-international.org/11.0/#sec-optional-chains">ES2020</a>开始，JS中也支持了这个语法）。</p>
<p>可选链大家应该都不陌生，在获取深层次对象属性的时候极其方便，比如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = foo?.bar;</span><br></pre></td></tr></table></figure>

<p>上面这行代码作用类似于下面这种写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = foo === <span class="literal">null</span> || foo === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : foo.bar;</span><br><span class="line"><span class="keyword">const</span> result = temp;</span><br></pre></td></tr></table></figure>

<p>虽然是这样说，但是作为一个凡事都要试一试的人来说，还是自己编译一下看看比较好，在用 tsc 试了一下之后，发现编译后的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = foo === <span class="literal">null</span> || foo === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : foo.bar;</span><br></pre></td></tr></table></figure>

<p>好像和上面的有点不一样，这里的代码里所有的<code>undefined</code>全部换成了<code>void 0</code>，这是为什么呢？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实从MDN上，我们很容易知道<code>void</code>运算符的作用：</p>
<blockquote>
<p><code>void</code>运算符对给定的表达式进行求值，然后返回<code>undefined</code>。</p>
</blockquote>
<p>即不论<code>void</code>运算符后面跟的是什么，这个运算符总是返回<code>undefined</code>。比如下面这些写法都会返回<code>undefine</code>：</p>
<ul>
<li><code>void 0</code></li>
<li><code>void(0)</code></li>
<li><code>void &#39;hello&#39;</code></li>
<li><code>void (1+2)</code></li>
<li><code>void(console.log(&#39;Hello world&#39;));</code></li>
</ul>
<p>也就是说上面 tsc 编辑后的语法中<code>void 0</code>和<code>undefined</code>是等价的。</p>
<p>而之所以不直接使用<code>undefined</code>，是因为在早期的 JavaScript 版本中，<code>undefined</code>是可以被重新赋值的，而使用<code>void 0</code>，则可以获取到**<code>undefined</code>的原始值**。</p>
<p>我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="keyword">void</span> <span class="number">0</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码运行后，第一个<code>console</code>将会打印<code>false</code>，第二个将会打印<code>true</code>，这就是因为<code>undefined</code>被重新赋值为了<code>1</code>，不再是原始的值，而为了保证编译后代码的正确性和稳定性，一般都会使用<code>void 0</code>来获取原始的<code>undefined</code>值。</p>
<p>到这里我们就搞明白刚刚那个问题了，那除了这个场景，<code>void</code>运算符还有哪些作用呢？</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="1-获取undefined的原始值"><a href="#1-获取undefined的原始值" class="headerlink" title="1. 获取undefined的原始值"></a>1. 获取undefined的原始值</h3><p>这个上面的例子中已经说到了，这里就不再赘述。</p>
<h3 id="2-用在-JavaScript-URI-中，以及阻止a标签的默认行为"><a href="#2-用在-JavaScript-URI-中，以及阻止a标签的默认行为" class="headerlink" title="2. 用在 JavaScript URI 中，以及阻止a标签的默认行为"></a>2. 用在 JavaScript URI 中，以及阻止<code>a</code>标签的默认行为</h3><p>当用户点击一个以<code>javascript:</code>开头的 URI 时，它会执行 URI 中的代码，然后<strong>用返回的值替换页面内容</strong>，除非返回的值是<code>undefined</code>。这个时候<code>void</code>运算符就派上了用场，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:&#x27;zzzzz&#x27;&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子里，点击<code>a</code>标签后，整个页面的内容，包括下面的<code>12345</code>，都会被替换为<code>zzzzz</code>。</p>
<p>如果使用了<code>void</code>，则不会这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(&#x27;zzzzz&#x27;);&quot;</span>&gt;</span>这个链接点击之后不会做任何事情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(document.body.style.backgroundColor=&#x27;green&#x27;);&quot;</span>&gt;</span></span><br><span class="line">  点击这个链接会让页面背景变成绿色。</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，很多地方的<code>a</code>标签都会添加一个简单的<code>href=&quot;javascript:void(0)</code>来阻止<code>a</code>标签的默认行为，达到类似<code>preventDefault</code>的效果。</p>
<p>可能有小伙伴有疑问，直接不写<code>href</code>属性或者<code>href</code>设为空字符串不就行了吗？其实还是有差别的,可以看下面的示例，从上到下三个<code>a</code>标签分别为：</p>
<ol>
<li>没有<code>href</code>属性</li>
<li><code>href</code>值为空</li>
<li><code>href</code>值为<code>javascript: void(0);</code></li>
</ol>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/void_operator/different_a_link.png" alt="image.png"></p>
<p>可以看到还是有一些区别的。</p>
<p>不过，目前除了<code>javascript: void(0);</code>比较常见之外，其他利用<code>javascript:</code>伪协议来执行 JavaScript 代码已经十分少见了，同时这种行为也是不太推荐的做法，推荐的做法是给对应的元素绑定事件处理器。</p>
<p><em><strong>PS：</strong></em></p>
<p>这里有一些历史背景在里面，在早期，各个浏览器有着不同的 DOM2 事件处理接口，对于阻止默认行为也有不同的实现，比如</p>
<ul>
<li><p>在支持W3C标准的浏览器中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault(); <span class="comment">// 阻止默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>而在IE中则是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="literal">false</span>; <span class="comment">// 阻止默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以很多开发者为了省事，不想写两套兼容代码，就直接省事在<code>a</code>标签的<code>href</code>属性中添加<code>javascript: void(0);</code>来阻止默认行为了，之后点击行为的自定义处理再通过 DOM0 支持的事件处理器来处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法流传很广，所以即便是在现代浏览器对 W3C 标准支持的比较好的今天，我们还是能在很多地方看到<code>javascript: void(0);</code>。</p>
<h3 id="3-用于立即执行函数表达式（IIFE）"><a href="#3-用于立即执行函数表达式（IIFE）" class="headerlink" title="3. 用于立即执行函数表达式（IIFE）"></a>3. 用于立即执行函数表达式（IIFE）</h3><p>在使用立即执行函数表达式时，如果像下面这样写，会得到一个报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，有两种方式：</p>
<ul>
<li><p>给函数体包一层圆括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>或者使用void运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>不过话说回来，IIFE 多用于 ES6 之前实现模块化，在 ES6 引入了<code>import</code>、<code>export</code>之后，IIFE 在实际的开发中用到的场景越来越少了，是一种过时的技术，这里是为了讲解<code>void</code>运算符才使用的，大家可以只做了解即可。</p>
<h3 id="4-强制返回undefined（常见于箭头函数中）"><a href="#4-强制返回undefined（常见于箭头函数中）" class="headerlink" title="4. 强制返回undefined（常见于箭头函数中）"></a>4. 强制返回<code>undefined</code>（常见于箭头函数中）</h3><p>在箭头函数中，允许在函数体不使用花括号来直接返回值，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> doSomething();</span><br></pre></td></tr></table></figure>

<p>但是这样做会把<code>doSomething</code>函数的执行结果作为返回值来返回给调用方，而如果<code>doSomething</code>函数的返回值从<code>undefined</code>变成了其他值，可能会造成预料之外的结果。</p>
<p>所以如果明确<code>onclick</code>不需要返回值时，可以通过增加<code>void</code>运算符来强制返回<code>undefined</code>，防止因为<code>doSomething</code>返回值的变化带来其他副作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> <span class="keyword">void</span> doSomething();</span><br></pre></td></tr></table></figure>

<p>当然了，这里除了这种方式外，也可以通过给箭头函数增加一对花括号来解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面这些就是<code>void</code>运算符用的比较多的场景了，如果还有需要补充的，欢迎在评论区留言~</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">一起从零实现React SSR服务端渲染</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-21 17:25:00" itemprop="dateCreated datePublished" datetime="2023-12-21T17:25:00+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Next.js 14 发布了，很多地方都在讨论，虽然之前也有用过 Next.js，也看过一些关于 SSR 的文章，了解了一些 SSR 的原理，但是一直没有动手实现过。这次正好趁着这个机会，从零开始手动实现一个 React SSR 服务端渲染的项目，来加深一下对 SSR 的理解。</p>
<h2 id="一、-什么是SSR"><a href="#一、-什么是SSR" class="headerlink" title="一、 什么是SSR"></a>一、 什么是SSR</h2><p>SSR，即Server Side Render，服务端渲染。和服务端渲染相对的，就是CSR，Client Side Render，客户端渲染。</p>
<p>从字面意思上就有看出，这两种渲染方式的差别就在于页面渲染的时机：</p>
<ul>
<li>服务端渲染是页面在服务端的时候就渲染完成了</li>
<li>而客户端渲染是页面在客户端（浏览器或者WebView之类的）进行渲染，服务端只会返回空页面（下面例子中会讲到）</li>
</ul>
<h2 id="二、-为什么需要SSR"><a href="#二、-为什么需要SSR" class="headerlink" title="二、 为什么需要SSR"></a>二、 为什么需要SSR</h2><p>在讨论为什么需要SSR之前，我们先来看看常见的CSR，比如下面这个很简单的React渲染的页面：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/page_overview.png" alt="page_overview.png"></p>
<p>页面包含一个count计数，点击“Increment”、“Decrement”和“Reset”按钮，分别可以增加计数，减小计数以及重设计数。</p>
<p>现在我们打开DevTool，看看访问这个地址的时候服务端返回的内容：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/csr_html_content.png" alt="csr_html_content.png"></p>
<p>从DevTool可以看到，服务端一共返回了两个文件，一个HTML一个JS。</p>
<p><strong>我们发现HTML里没有任何页面上的元素，是空的</strong>，只有一个root节点和一个main.js脚本。而所有的这些count计数以及下面这些按钮，都是在HTML页面以及main.js下载完成后，浏览器通过执行main.js来进行渲染生成的，这也就是所谓的客户端渲染。</p>
<p>通过这个我们可以发现，CSR的应用有两个比较明显的问题：</p>
<h3 id="1-CSR应用十分不利于SEO"><a href="#1-CSR应用十分不利于SEO" class="headerlink" title="1. CSR应用十分不利于SEO"></a>1. CSR应用十分不利于SEO</h3><p>SEO，也就是Search Engine Optimization，搜索引擎优化。CSR应用从服务端返回的HTML是一个空的页面，页面内容元素完全依赖JS代码来生成，导致搜索引擎爬虫在抓取和解析网页时，无法获取到完整的网页内容，从而不利于搜索引擎优化搜索结果和搜索排名。</p>
<blockquote>
<p>题外话：现在的一些搜索引擎（比如Google）已经可以解析CSR应用里的JS，所以CSR目前对SEO的影响可能没有以前那么大了，但是如果SEO对你来说很重要，那么最好还是做一些SSR服务端渲染</p>
</blockquote>
<h3 id="2-首屏加载时间可能较长"><a href="#2-首屏加载时间可能较长" class="headerlink" title="2. 首屏加载时间可能较长"></a>2. 首屏加载时间可能较长</h3><p>由于CSR应用页面里所有的内容，都是通过JS动态生成的，那么在访问页面的时候，除了下载HTML外，还需要额外下载JS脚本才可以展示出页面。</p>
<p>衡量首屏加载性能的指标有很多，我们这里用常用的<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint?utm_source=devtools">FCP（First Contentful Paint）</a>，即“首次内容渲染”时间来看下这个页面的表现。由于我们这个页面太过简单，而且是在本地<code>127.0.0.1</code>启动的服务，所以直接感受可能不明显，我们可以在DevTool里设置网络状态，改成“低速3G”来模拟：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/csr_network_panel.png" alt="csr_network_panel.png"></p>
<p>而FCP除了可以用<code>performance</code> API获取到之外，也可以直接在Chrome DevTool的“性能”面板，通过点击面板里的“重新加载”按钮录制得到：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/csr_perf_panel.png" alt="csr_perf_panel.png"></p>
<p>从上面的网络瀑布和性能面板可以看到，在“低速3G”的网络状态下，页面在获取到2.01s获取到HTML后，并没有渲染任何内容，而是在又等了4.76s等到JS下载完成之后，才渲染出内容，页面的FCP总计是6822.2ms。</p>
<p>也就是说，在2.01s的时候，HTML已经下载好的情况下，用户还是无法看到内容，额外等待了4.76s等待JS的下载，首屏加载时间较长。</p>
<p>下面我们就来尝试把上面这个项目改成支持服务端渲染，来改善这两个CSR的弊端。</p>
<h2 id="三、-准备好一个项目"><a href="#三、-准备好一个项目" class="headerlink" title="三、 准备好一个项目"></a>三、 准备好一个项目</h2><p>首先我们先准备好上面这个项目的代码，这是项目的GitHub地址，大家可自取：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></p>
<p>项目的目录结构长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── Button</span><br><span class="line">│   │       ├── index.module.css</span><br><span class="line">│   │       └── index.tsx</span><br><span class="line">│   ├── Home.module.css</span><br><span class="line">│   ├── Home.tsx</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── index.tsx</span><br><span class="line">├── webpack</span><br><span class="line">│   └── client.config.js</span><br><span class="line">├── .babelrc</span><br><span class="line">├── .eslintignore</span><br><span class="line">├── .eslintrc.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .prettierignore</span><br><span class="line">├── .prettierrc.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── types.d.ts</span><br></pre></td></tr></table></figure>

<p>关键的几个文件内容如下：</p>
<ol>
<li><code>src/components/Button/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IButtonProps &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span>;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Button: React.FC&lt;IButtonProps&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  text,</span></span></span><br><span class="line"><span class="params"><span class="function">  className,</span></span></span><br><span class="line"><span class="params"><span class="function">  onClick,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">className</span>=<span class="string">&#123;classNames(styles.btn,</span> <span class="attr">className</span>)&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;text&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>src/Home.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;@/components/Button&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Home.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Home: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.btnWrapper&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Increment&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prev =&gt; prev + 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Decrement&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prev =&gt; prev - 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Reset&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(0)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>src/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>webpack/client.config.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ForkTsCheckerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;fork-ts-checker-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist/client&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>, path.resolve(rootDir, <span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">      <span class="attr">scriptLoading</span>: <span class="string">&#x27;defer&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;&#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">performance</span>: &#123;</span><br><span class="line">    <span class="attr">hints</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">maxEntrypointSize</span>: <span class="number">512000</span>,</span><br><span class="line">    <span class="attr">maxAssetSize</span>: <span class="number">512000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>package.json</code></li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之前，其他一些都是代码规范化相关的配置，比如eslint、prettier之类的，不是这次重点讨论的范围，感兴趣的可以看我之前这篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/7314365567376162853">《前端代码规范化配置最佳实践 - 掘金》</a>。</p>
<p>通过在本地执行<code>npm run dev</code>或者<code>npm run build</code>，就可以编译项目，这里我没有使用webpack dev server，而是起了一个Nginx服务，简单改了一下Nginx配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">3006</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   /your-project-location/react-<span class="literal">no</span>-ssr-demo/dist/client;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样直接在浏览器访问<code>127.0.0.1:3006</code>或者<code>localhost:3006</code>就可以了。</p>
<h2 id="四、-使用服务端渲染"><a href="#四、-使用服务端渲染" class="headerlink" title="四、 使用服务端渲染"></a>四、 使用服务端渲染</h2><p>现在让我们开始给项目添加服务端渲染，既然要服务端渲染，就必须在服务端使用React的<a target="_blank" rel="noopener" href="https://react.docschina.org/reference/react-dom/server/renderToString">renderToString</a>来渲染好HTML再返回给客户端，既然要求在服务端跑JS代码，那么服务端就必须要引入Node了，也就是说做服务端渲染，必须要有一个Node做中间层（Next.js的<a target="_blank" rel="noopener" href="https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation">SSG</a>不算是严格意义上的服务端渲染，不在讨论范围内）。</p>
<h3 id="1-添加Node服务"><a href="#1-添加Node服务" class="headerlink" title="1. 添加Node服务"></a>1. 添加Node服务</h3><p>现在让我们先加一个基础的Node服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br><span class="line">npm install --save-dev @types/express</span><br></pre></td></tr></table></figure>

<p>添加一个<code>src/server.tsx</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;React SSR&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我们换了一个<code>3007</code>端口，为了和刚刚的CSR项目的<code>3006</code>端口区分开来（另外使用了Node服务之后，也就不需要Nginx了）。</p>
<p>从上面的代码可以看到，<code>src/server.tsx</code>中，先创建了一个express服务，然后监听了<code>3007</code>端口，在访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>的时候，服务端调用ReactDOMServer的<code>renderToString</code>方法，将我们的<code>Home</code>组件渲染为了HTML字符串，并且拼接到了一个HTML模板中，返回给了客户端。</p>
<h3 id="2-添加src-server-tsx的编译配置"><a href="#2-添加src-server-tsx的编译配置" class="headerlink" title="2. 添加src/server.tsx的编译配置"></a>2. 添加<code>src/server.tsx</code>的编译配置</h3><p>由于<code>src/server.tsx</code>使用了TS和JSX的语法，那么这个文件也需要使用webpack和babel进行编译，让我们添加一下这个server文件的编译配置，<code>webpack/server.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/server.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;server.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在<code>package.json</code>中添加一下编译服务端的scripts命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run dev:server</code>以及<code>npm start</code>之后，打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_no_js.gif" alt="ssr_no_js.gif"></p>
<p>果然，这次服务端返回的HTML不再是空的了，页面上的元素直接就可以在HTML中看到。</p>
<p>但是这里奇怪的是，页面的样式没有了，点击这些按钮也不再生效了，同时从网络请求里看到，服务端也只返回了一个HTML，没有JS，这是为什么呢？</p>
<h2 id="五、-同构-amp-hydrate"><a href="#五、-同构-amp-hydrate" class="headerlink" title="五、 同构 &amp; hydrate"></a>五、 同构 &amp; hydrate</h2><p>其实，这是因为我们上面实现的SSR还不是一个完整的React SSR项目。<code>renderToString</code>虽然可以在服务端把组件渲染为HTML，但是却无法实现事件监听器的挂载或者绑定（毕竟事件绑定是要绑定到浏览器上真实的DOM上，而不是HTML字符串上），所以在<code>renderToString</code>的时候会把事件处理器给过滤掉。</p>
<h3 id="1-同构"><a href="#1-同构" class="headerlink" title="1. 同构"></a>1. 同构</h3><p>那么为了实现完整的SSR，就需要引入“同构渲染”的概念了。这个词相信大家之前都或多或少听过，其实很简单，同构渲染就是同一份代码，既在服务端运行（SSR），又在客户端运行（CSR）。</p>
<p>最开始我们提到的那个CSR代码，只是在客户端运行，后来加上的服务端渲染的能力，只是在服务端运行（客户端只是接收了一个HTML，并没有运行什么JS代码）。现在需要将两者结合起来，接下来让我们开始改造一下：</p>
<p>首先，<code>src/server.tsx</code>中，我们不再直接返回一个模板HTML，而是在上面CSR项目编译出来的HTML中直接加上服务端渲染的内容，同时在服务端提供静态资源访问服务：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientDistDir = path.resolve(__dirname, <span class="string">&#x27;../dist/client&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlPath = path.resolve(clientDistDir, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 读取 dist/client/index.html 文件</span></span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(htmlPath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 将渲染后的 React HTML 插入到 div#root 中</span></span><br><span class="line">  <span class="keyword">const</span> finalHtml = html.replace(</span><br><span class="line">    <span class="string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">`&lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;`</span></span><br><span class="line">  );</span><br><span class="line">  res.send(finalHtml);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供静态资源访问服务</span></span><br><span class="line">app.use(express.static(clientDistDir));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接在命令行执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm run dev:server</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_render.gif" alt="ssr_render.gif"></p>
<p>看起来好像OK了，既有服务端渲染（返回的HTML不为空，直接就有页面上的元素），又有客户端渲染（事件绑定成功，有页面交互）。但是如果这个时候你查看一下控制台的话，会发现会有一个Waring：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_render_warn.png" alt="ssr_render_warn.png"></p>
<p>说是调用<code>ReactDOM.render()</code>去渲染（水合，或者说注水）一个服务端渲染的页面的行为会在React 18停止支持。</p>
<h3 id="2-hydrate"><a href="#2-hydrate" class="headerlink" title="2. hydrate"></a>2. hydrate</h3><p>其实这个从<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/server/renderToString#reference">React官网</a>也可以看到，在服务端使用<code>renderToString</code>外进行服务端渲染后，还需要在客户端使用<code>hydrate</code>（或者<code>hydrateRoot</code>，后者是React 18中的写法），来完成事件绑定和页面的交互性逻辑。</p>
<p>来改下代码，在<code>src/index.tsx</code>中，改为如下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.hydrate(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>同时为了方便调试，安装一下两个依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save nodemon</span><br><span class="line">npm install --save-dev npm-run-all</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;npm-run-all --parallel dev:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:client&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npm-run-all build:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:client&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>nodemon</code>用于监听<code>dist/server.js</code>的变化，一旦修改了<code>src/server.tsx</code> webpack会重新编译，生成新的<code>dist/server.js</code>，这个时候nodemon会重新运行新的<code>dist/server.js</code>。</p>
<p><code>npm-run-all</code>则用于同时运行多个npm命令。</p>
<p>这个时候再运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>，发现已经没有Waring了：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_hydrate_no_warn.png" alt="ssr_hydrate_no_warn.png"></p>
<h3 id="3-hydrate和render的区别"><a href="#3-hydrate和render的区别" class="headerlink" title="3. hydrate和render的区别"></a>3. hydrate和render的区别</h3><p><code>render()</code>和<code>hydrate()</code>在大部分情况下的行为是相似的，这两个都会将React元素渲染到指定的DOM节点中，但是在处理服务端渲染返回的HTML是有一些区别。</p>
<p>服务端渲染的时候，服务端会渲染React元素并且生成一个HTML字符串返回给客户端（也就是浏览器），之后客户端会用这个HTML来生成DOM。在同构渲染的时候，客户端还会重新执行一遍JS代码，重新生成一个React组件树和相应的DOM节点。而<code>render()</code>和<code>hydrate()</code>的区别就在这里。</p>
<p><code>render()</code>会直接创建一个新的React组件数和相应的DOM节点，而<code>hydrate()</code>则是在生成的时候，会判断这个节点是否已经在服务端渲染好，<strong>会尽可能地保留现有的DOM，只更新必要的部分</strong>。</p>
<p>这也就是React官网所说的：</p>
<blockquote>
<p>Call hydrate in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.</p>
<p>React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it.</p>
</blockquote>
<p>在React 17及以下版本中调用<code>hydrate</code>，可以将React“附加”到在服务器环境中已经由React渲染的现有HTML上。</p>
<p>React将会附加到<code>domNode</code>内部现有的HTML，并接管有关的DOM的管理。</p>
<h2 id="六、-再来看下CSR的两个痛点"><a href="#六、-再来看下CSR的两个痛点" class="headerlink" title="六、 再来看下CSR的两个痛点"></a>六、 再来看下CSR的两个痛点</h2><p>到这里就算是完成了一个最基本的React服务端渲染，现在我们回头来看一下，是否解决了上面CSR项目的两个痛点。</p>
<h3 id="1-SEO"><a href="#1-SEO" class="headerlink" title="1. SEO"></a>1. SEO</h3><p>首先是之前SEO不友好的问题。</p>
<p>在做了SSR渲染后，从服务端返回的HTML里就已经包含了页面上的元素，搜索引擎爬虫在抓取和解析网页时，可以获取到完整的网页内容，显然SSR渲染可以解决这个问题（当前想要更好的SEO效果，还有其他可以优化的地方，不过这些就和CSR/SSR无关了）。</p>
<h3 id="2-FCP"><a href="#2-FCP" class="headerlink" title="2. FCP"></a>2. FCP</h3><p>其次，我们来看一下首屏的加载时间，还是通过设置DevTool里设置网络状态，改成“低速3G”来看一下FCP：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_network_panel.png" alt="ssr_network_panel.png"></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/react_ssr_from_scratch/ssr_perf_panel.png" alt="ssr_perf_panel.png"></p>
<p>从上面可以看到，虽然网络面板内的HTML和JS整体的加载时间和之前几乎一样（都是6.8s左右），但是从性能面板里可以看到，页面的FCP是2043.2ms，比之前的6822.2ms少了将近70%。</p>
<p>从时间轴的截图上也可以发现，页面在HTML下载成功之后（2.02s），就立刻可以看到页面内容，虽然页面的交互还是需要等到6.8s JS下载完成，但是从用户体验上来讲，缩短页面的白屏时间，用户可以更快的看到页面内容，对于用户体验是一个很大的提升。</p>
<p>也就是说，SSR确实解决了CSR的两个痛点。</p>
<h2 id="七、-服务端渲染一些主要注意的事情"><a href="#七、-服务端渲染一些主要注意的事情" class="headerlink" title="七、 服务端渲染一些主要注意的事情"></a>七、 服务端渲染一些主要注意的事情</h2><p>下面是一些做服务端渲染时需要注意的点：</p>
<h3 id="1-React的生命周期和一些Hooks"><a href="#1-React的生命周期和一些Hooks" class="headerlink" title="1. React的生命周期和一些Hooks"></a>1. React的生命周期和一些Hooks</h3><p>React的一些生命周期函数，比如类组件的<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以及函数组件的<code>useEffect</code>和<code>useLayoutEffect</code>，都不会在服务端渲染的时候执行。</p>
<h3 id="2-浏览器专属的API"><a href="#2-浏览器专属的API" class="headerlink" title="2. 浏览器专属的API"></a>2. 浏览器专属的API</h3><p>浏览器专属的API，比如<code>window</code>，<code>document</code>，<code>localStorage</code>等，都不能在服务器端运行，需要判断只有在当前环境是客户端才可以执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="3-事件处理函数"><a href="#3-事件处理函数" class="headerlink" title="3. 事件处理函数"></a>3. 事件处理函数</h3><p>如上面提到的那样，服务端渲染的时候，不会执行事件处理函数，也不会触发任何事件，需要在客户端处理。</p>
<h3 id="4-服务端渲染和客户端渲染时的差异"><a href="#4-服务端渲染和客户端渲染时的差异" class="headerlink" title="4. 服务端渲染和客户端渲染时的差异"></a>4. 服务端渲染和客户端渲染时的差异</h3><p>在进行同构渲染的时候，<strong>请务必保证</strong>客户端渲染出来的内容和服务端渲染的内容完全相同。如果客户端和服务端渲染出来的内容不一致，React会尝试对不一致的地方进行修复，而这些修复是<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/hydrate#caveats">非常耗时的</a>。如果差异过大甚至会重新渲染整个应用（类似于<code>ReactDOM.render</code>）。</p>
<p>所以应尽量避免客户端渲染出来的内容和服务端渲染出来的内容不一致。</p>
<h2 id="八、-小结"><a href="#八、-小结" class="headerlink" title="八、 小结"></a>八、 小结</h2><p>通过上面的内容，我们从零手动完成了一个React服务端渲染的Demo项目，这只是一个最基础的项目，还有更多的比如React路由服务端渲染、服务端渲染时的数据脱水和注水等等，都需要添加更加复杂的配置，有时间了再单独写一篇聊一下。</p>
<p>这里附上文章里提到的两个Demo项目地址：</p>
<ul>
<li>CSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></li>
<li>SSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-ssr-demo">react-ssr-demo</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://react.dev/">https://react.dev</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文) - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0">http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/325952676">什么是前端的同构渲染？</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc">https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/15/DockerNginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/15/DockerNginx/" class="post-title-link" itemprop="url">使用 Docker 安装 Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-15 19:37:06" itemprop="dateCreated datePublished" datetime="2023-12-15T19:37:06+08:00">2023-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx bash</span><br><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/docker/nginx/conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx:/etc/nginx/nginx.conf /opt/docker/nginx/conf/nginx.conf</span><br><span class="line">docker cp nginx:/etc/nginx/conf.d/ /opt/docker/nginx/conf/conf.d</span><br><span class="line">docker cp nginx:/var/<span class="built_in">log</span>/nginx/ /opt/docker/nginx/logs</span><br><span class="line">docker cp nginx:/usr/share/nginx/html/ /opt/docker/nginx/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 80:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个是有问题的，这样设置里之后，访问 `http://localhost:80` 依然可以访问到 nginx 的默认页面</span></span><br><span class="line"><span class="comment"># 因为这个命名使用了 `--net host` 选项，这个选项会让容器使用宿主机的网络，所以 Docker 中的 Nginx 依然会监听宿主机的 80 端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是在云服务器上使用 Docker 安装 Nginx，那么下面的命令会导致，使用 8080 端口也可能访问呢不到 Nginx 的默认页面，因为一般情况下云服务器默认的防火墙会关闭 8080 端口。</span></span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">--net host \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7176299143659257893">完整详细使用Docker安装Nginx教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/15932500.html">docker+nginx 安装部署修改资源目录配置文件和容器端口信息</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44248903/article/details/134803724">2023 docker nginx安装教程(含portainer教程)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49194578/article/details/117341481">Docker 安装 nginx 并且配置反向代理遇到的坑</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/" class="post-title-link" itemprop="url">Sentry治理之Issue分组（Issue Grouping）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-11 13:05:23" itemprop="dateCreated datePublished" datetime="2023-12-11T13:05:23+08:00">2023-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Sentry大家应该都不陌生，即便没有使用过，也应该听过Sentry的大名。</p>
<p>作为一个实时事件日志监控平台，Sentry可以记录和聚合我们应用中的报错、打点等，不管是Sentry自动捕获的错误，还是我们主动上报的错误，都可以在Sentry提供的可视化平台看到，方便开发者及时发现、分析和排查应用中存在的问题。</p>
<p>但是在使用Sentry的过程中，我们发现了一些使用起来不那么方便的地方，这个就是我们今天要一起讨论的问题——Sentry Issue的分组（Issue Grouping）。</p>
<h2 id="二、先看看什么是Sentry-Issue"><a href="#二、先看看什么是Sentry-Issue" class="headerlink" title="二、先看看什么是Sentry Issue"></a>二、先看看什么是Sentry Issue</h2><p>在Sentry中，每一条日志上报都是一个事件（Event）,在Sentry的Discover面板中，我们可以看到所有上报的Event，比如我这个项目：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/discover.png" alt="Discover面板"></p>
<p>Event分为两种类型，Transaction和Error。</p>
<p>Transaction事件主要用于性能监控。它记录了一个请求或任务从开始到结束的完整生命周期，包括各种详细的性能数据，如请求的开始时间、结束时间、总耗时、各个阶段的耗时等。</p>
<p>Error事件主要用于错误跟踪。它记录了应用运行过程中发生的错误或异常，包括错误的类型、位置、堆栈跟踪等信息。</p>
<p>而<strong>Issue就是Error类型的Event的聚合</strong>，Sentry会把一些相似的Error进行聚合，合并成一个Issue，这样我们就可以看到某个特定Error发生的频率和趋势，而不仅仅是只能看到单个Error Event。</p>
<p>Sentry的Issue可以在Issues面板中看到，如下图所示：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/issues.png" alt="Issue面板"></p>
<p>从这个面板可以看到某个Issue（即某个类型的Error），上报了几次，有多少用户遇到了这个Error，以及这个Error数量变化的趋势，帮助我们快速确认问题的严重程度和影响范围。</p>
<h2 id="三、我们遇到啥问题了？"><a href="#三、我们遇到啥问题了？" class="headerlink" title="三、我们遇到啥问题了？"></a>三、我们遇到啥问题了？</h2><p>从上面的描述可以看到，Sentry把Error进行聚合，合并成一个个Issue，帮助我们查看某个类型Error的一些信息，看起来是挺好的。</p>
<p>但是在我们的项目里，Sentry好像并不是这么做的，比如下图：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/repeat_issues.png" alt="重复的Issue"></p>
<p>说好的自动聚合分组呢？</p>
<p>同样的一个Error（或者是极其相似的Error）,并没有被聚合为同一个Issue，而是分到了不同的几个Issue里，并且这些Issue的名字几乎一摸一样，每个Issue还各自展示一个Event次数。</p>
<p>而且这个问题不止出现在某一种类型的Error上，几乎所有的Error上报都或多或少地存在这种问题，导致不能很好地分析某种Error的影响或者变化趋势。</p>
<p>而且有时候即便我们手动Ignore某个Issue，未来还是会不断地有新的这个Issue出现，或者我们像下面这样手动Merge两个Issue，也还是会源源不断地产生新的、没有被Merge进手动Merge的分组内的Issue。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<h2 id="四、研究下Sentry是怎么对Error分组的"><a href="#四、研究下Sentry是怎么对Error分组的" class="headerlink" title="四、研究下Sentry是怎么对Error分组的"></a>四、研究下Sentry是怎么对Error分组的</h2><p>在解决我们遇到的问题之前，还是要先了解下Sentry是怎么对Error进行分组的，知道原理才能着手解决。</p>
<p>看了下官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>，这才揭开了Sentry分组的面纱。</p>
<h3 id="1-Sentry-Issue的Fingerprint和分组"><a href="#1-Sentry-Issue的Fingerprint和分组" class="headerlink" title="1. Sentry Issue的Fingerprint和分组"></a>1. Sentry Issue的Fingerprint和分组</h3><p>在Sentry中，有一个“指纹”的概念，Fingerprint，Fingerprint是标识Event的一种方式，每个Event（包括Error和Transaction）都有一个Fingerprint。</p>
<p>Sentry会根据某种规则，来给每一个Event生成Fingerprint，具有相同Fingerprint的Event会被Sentry分为一组，这就是Sentry分组的基本原则。</p>
<h4 id="1-1-如何在Sentry上查看一个Event的Fingerprint呢？"><a href="#1-1-如何在Sentry上查看一个Event的Fingerprint呢？" class="headerlink" title="1.1 如何在Sentry上查看一个Event的Fingerprint呢？"></a>1.1 如何在Sentry上查看一个Event的Fingerprint呢？</h4><p>从Discover或者Issues列表中，随便点击一个进入Error详情（Transaction不行，下面会讲原因），点击查看这个Error对应原始JSON数据：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/issue_detail_json.png" alt="查看原始JSON"></p>
<p>在原始JSON中搜索fingerprint字段，可以看到如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;fingerprint&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个<code>&#123;&#123; default &#125;&#125;</code>，这说明使用的是Sentry默认规则生成的Fingerprint。如果是其他的规则，则会展示为其他的值。</p>
<h4 id="1-2-Event默认的Fingerprint生成规则"><a href="#1-2-Event默认的Fingerprint生成规则" class="headerlink" title="1.2 Event默认的Fingerprint生成规则"></a>1.2 Event默认的Fingerprint生成规则</h4><p>不同类型的Event，有不同的Fingerprint生成规则：</p>
<ul>
<li>Error类型：Error类型会基于这个Error的调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>，从这三个方面来生成Fingerprint</li>
<li>Transaction类型：通过这个类型的Spans来生成，可以查看原始JSON数据中的<code>spans</code>字段</li>
</ul>
<p>我们这次只讨论Error类型的Event Fingerprint生成规则。</p>
<p>首先，Sentry每个版本生成Fingerprint的默认规则可能会有一些差异，每次Sentry默认的Fingerprint生成规则变化了之后，Sentry都会发布一个新版本，所以Fingerprint生成规则变化了之后，不会影响已有的Event。</p>
<p>每次新建一个Project，都会自动使用目前最新版本的Fingerprint生成规则，如果想要现有的Project升级到最新的Fingerprint生成规则，需要在设置里手动修改，具体位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Upgrade Grouping</strong>.如下图：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/upgrade_grouping.png" alt="升级分组"></p>
<p>所有版本的Fingerprint生成规则都是最先考虑<code>Stack Trace</code>，然后是<code>Exception</code>, 最后是<code>message</code>。</p>
<h5 id="a-按照Stack-Trace分组"><a href="#a-按照Stack-Trace分组" class="headerlink" title="a. 按照Stack Trace分组"></a>a. 按照Stack Trace分组</h5><p>对于一个上报的Error Event，如果他的原始数据中有调用堆栈信息，就会完全根据调用堆栈来进行分组（即不考虑其他的），主要会使用下列信息：</p>
<ul>
<li>模块名module</li>
<li>文件名（去除哈希值等之后的名字）filename</li>
<li>上下文，行号列号等信息</li>
</ul>
<p>这里的堆栈信息只包括和当前Project有关的堆栈，和当前项目无关的堆栈信息不会用于分组。</p>
<p>堆栈信息可以在原始的JSON数据中的<code>exception.values</code>的<code>stacktrace</code>字段中看到，如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;exception&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;xxx err&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;stacktrace&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;frames&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;rrr&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;uuu&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///ddd/eee/fff.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">20</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">57</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>stacktrace</code>字段中有个<code>frames</code>，是一个数据，记录的是当前Error发生时的调用堆栈帧列表，数组中的每一项就是一个调用帧（frame），每一帧中都有如下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Sentry就是根据这些调用栈的帧列表，来生成Fingerprint。即相同调用堆栈的错误，被认为是同一种类Error，会被归为同一组。</p>
<p>用这个方法来分组，一般来说效果都挺不错，但是如果出现下面这些情况，就会导致这个分组方法或者说分组规则，效果不那么好：</p>
<ol>
<li><p>代码经过混淆或者压缩（比如TS/JS代码经过Babel编译）<br>由于混淆或者压缩之后，代码的变量名、函数名、代码结构等都会发生变化，即便对于同一个Error，不同版本的代码（比如两个release版本之间，或者两次不同的构建之间）的调用堆栈信息也会发生变化，导致Sentry认为这些是不同的Error，从而没有进行聚合分组。<br>如果代码有混淆或者压缩，就需要上传Source Maps到Sentry，让Sentry通过原始的堆栈信息生成Fingerprint，来避免分组混乱。</p>
</li>
<li><p>代码通过装饰器等引入了新的堆栈层级，也会导致调用堆栈发生变化。比如</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> decoratorFn = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Before function execution&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;After function execution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @decoratorFn</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，<code>myFunction</code>被<code>decoratorFn</code>装饰。当调用<code>myFunction</code>时，实际上是在调用<code>decoratorFn</code>返回的函数。因此，如果在这个过程中发生错误并生成堆栈信息，堆栈信息中将会包含<code>decoratorFn</code>返回的函数的调用，这就是通过引入新的堆栈层级来修改堆栈信息。</p>
<p>可以通过自定义的<code>beforeSend</code>来自定义删除或者修改这些堆栈信息（下面会讲到）。</p>
<h5 id="b-按照Exception分组"><a href="#b-按照Exception分组" class="headerlink" title="b.按照Exception分组"></a>b.按照Exception分组</h5><p>如果上报的Error Event的数据中没有堆栈调用信息，但是有完整的<code>Exception</code>信息（这里的完整指的是<code>Exception</code>的type和value同时存在），就会按照<code>Exception</code>的type和value进行分组，但是这种分组可靠性比较低，因为错误的信息可能会改变。</p>
<p>这里的<code>Exception</code>指的就是各种Error，JS里的<code>Exception</code>就是各种类型的<code>Error</code>，比如<code>ReferenceError</code>、<code>TypeError</code>、<code>RangeError</code>、<code>SyntaxError</code>等。</p>
<ul>
<li><code>Exception</code>的type就是Error的name，如果有自定义的name就是自定义的name，比如<code>DownloadFileError</code>，没有自定义的话默认就是各个类型名</li>
<li>Exception的value指的就是err.message</li>
</ul>
<p>比如访问一个未定义的变量，JS会抛出一个<code>ReferenceError</code>，type就是“ReferenceError”，value可能是“x is not defined”。</p>
<p>如果是下面的自定义name的Error：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;This is a mock err msg&#x27;</span>);</span><br><span class="line">err.name = <span class="string">&#x27;MyMockError&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个Error的type就是“MyMockError”，value就是“This is a mock err msg”。</p>
<p>这里的type和value也可以直接在Sentry上任意一个Error原始的JSON数据中看到，JSON中的<code>metadata</code>字段，记录了这个Error的type和value：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;display_title_with_tree_label&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;MyMockError: This is a mock err msg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;MyMockError&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;This is a mock err msg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>问：</strong></em><br>什么情况下会出现存在Exception但是不包含堆栈信息？</p>
<p><em><strong>ChatGPT:</strong></em><br>在大多数情况下，当JavaScript抛出一个异常时，这个异常都会包含一个堆栈跟踪。堆栈跟踪记录了错误发生时的函数调用序列，这对于理解和调试错误是非常有用的。<br>然而，在某些情况下，异常可能不包含堆栈跟踪。例如：</p>
<ol>
<li><p>如果你手动创建并抛出一个错误，但没有提供堆栈跟踪，那么这个错误就不会有堆栈跟踪。例如，throw new Error()会创建一个包含堆栈跟踪的错误，但throw { message: ‘error’ }则不会。</p>
</li>
<li><p>在某些JavaScript环境中，例如某些旧版本的浏览器或某些JavaScript引擎，可能不支持堆栈跟踪，或者支持的方式与标准不同。</p>
</li>
<li><p>如果错误发生在异步代码中，并且这个错误没有被正确地捕获和处理，那么可能只有错误信息，没有堆栈跟踪。</p>
</li>
<li><p>如果你的代码中有捕获错误并处理的逻辑，可能会修改或移除堆栈跟踪。</p>
</li>
</ol>
</blockquote>
<h5 id="c-兜底的分组"><a href="#c-兜底的分组" class="headerlink" title="c. 兜底的分组"></a>c. 兜底的分组</h5><p>如果上面两种情况都没办法对Event进行分组，那么就会使用兜底的分组，即直接使用上报的时候收到的Event消息来分组。</p>
<h4 id="1-3-分析一下"><a href="#1-3-分析一下" class="headerlink" title="1.3 分析一下"></a>1.3 分析一下</h4><p>到这里我们可以先分析一下，为什么我们的项目会出现上面说的问题了。</p>
<p>首先，我们的项目没有修改过任何和Event Fingerprint有关的设置，使用的是默认分组规则，即使用调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>来进行分组。而绝大部分都是使用调用堆栈进行分组。</p>
<p>我们的JS项目由于某种原因，在编译后没有把Source Maps上传到Sentry，导致代码的变量名、函数名、代码结构等在不同版本或者不同的构建记录后，都会发生变化，所以即便某个Issue被Ignore或者被手动Merge，到下一个版本，由于同一个Error的调用栈变化了，生成了完全不同的Fingerprint，导致没有被分为一组。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/mixed_call_stack.png" alt="混淆压缩后的代码的调用栈"></p>
<blockquote>
<p><strong>💡注意：</strong><br>代码混淆之后并不是会让Sentry没办法对Error生成Fingerprint以及分组，即使代码被混淆和压缩，只要所有用户都使用的是同一份混淆和压缩后的代码，那么同一个地方的Error应该会生成相同的堆栈跟踪，Sentry应该能够正确地将这些错误分到同一组。</p>
<p>真正的问题在于多个版本或者多个构建之间，每次压缩混淆后的代码都不一样，从而导致不同版本直接Error分组混乱。</p>
</blockquote>
<p>看来使用默认的Fingerprint生成规则不行了，至少在我们项目上传Source Maps之前不行。需要看下怎么自定义分组。</p>
<h4 id="1-4-自定义分组"><a href="#1-4-自定义分组" class="headerlink" title="1.4 自定义分组"></a>1.4 自定义分组</h4><p>首先，只有Error类型的Event支持自定义分组，Transaction类型的暂时无法自定义。这也是为什么上面说Transaction类型的Event，无法在原始JSON数据中看到fingerprint字段的原因，因为Transaction Event无法自定义，所以也就不会展示在JSON数据里。</p>
<p>对于Error类型的Event，从简单到复杂有以下4种方式来自定义分组：</p>
<ol>
<li><p>在Sentry Admin对应的项目Issues列表中，手动Merge<br>手动合并（你认为是）相同的Issues，最简单，不需要修改任何设置和配置项。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Fingerprint Rules<br>设置Fingerprint Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Stack Trace Rules<br>设置Stack Trace Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在使用Sentry SDK的本地项目里，使用SDK Fingerprinting<br>在本地项目中，使用SDK上报之前，设置Event的Fingerprint。</p>
</li>
</ol>
<p>下面我们一个个来看。</p>
<h3 id="2-手动合并Issue"><a href="#2-手动合并Issue" class="headerlink" title="2. 手动合并Issue"></a>2. 手动合并Issue</h3><p>在Sentry项目的Issues列表中，手动选择2或者更多个Issue，然后点击Merge，即可合并为一个分组。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<p>需要注意的是，Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则，新产生的Issue还是会按照之前的规则来分组，然后根据放到我们手动Merge的Issue集合中。</p>
<p>这也解释了为什么我们项目中，每次手动Merge之后，还是会产生新的没有被进入Merge后的分组，因为“Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则”。</p>
<h3 id="3-Stack-Trace-Rules"><a href="#3-Stack-Trace-Rules" class="headerlink" title="3. Stack Trace Rules"></a>3. Stack Trace Rules</h3><p>虽然按照Sentry官网的文档的说法，Stack Trace Rules要比Fingerprint Rules复杂一些，我们还是先来讲下Stack Trace Rules。</p>
<p>在比较旧的Sentry版本中，Stack Trace Rules也叫作Grouping Enhancements或者Custom Grouping Enhancements。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Stack Trace Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Custom Grouping Enhancements</strong>。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/stack_trace_rules.png" alt="Stack Trace Rules"></p>
<p>修改Stack Trace Rules会影响<strong>输入到Stack Trace分组算法中的数据</strong>。我们可以通过规则来改变哪些stack trace frames被视为”in-app”，这会影响Sentry如何将Issue分组。例如，我们可以将某些通常被视为”not in-app”的frames标记为”in-app”，这样它们就会被包含在分组算法中。</p>
<p>在自定义的Stack Trace Rules中，每一行都是一条规则。每条规则有匹配项（matcher）、表达式（expression），以及跟在后面的操作（action）组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matcher-name:expression other-matcher:expression ... action1 action2 ...</span><br></pre></td></tr></table></figure>

<p>一条规则里可以有多个匹配表达式，后面也可以有多个action。这些action会在前面所有匹配表达式匹配的时候执行。</p>
<p>所有的规则会从上到下，对调用堆栈信息里的所有帧（Frames）执行。</p>
<p>如果要表达否定，那么就在matcher前加上一个感叹号<code>!</code>，某一行以<code>#</code>开头则表达这一行是注释。</p>
<p>下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mark all functions in the std namespace to be outside the app</span><br><span class="line">family:native stack.function:std::*       -app</span><br><span class="line"></span><br><span class="line"># mark all code in node modules not to be in app</span><br><span class="line">stack.abs_path:**/node_modules/**         -app</span><br><span class="line"></span><br><span class="line"># remove all generated javascript code from all grouping</span><br><span class="line">stack.abs_path:**/generated/**.js         -group</span><br></pre></td></tr></table></figure>

<p>由于Stack Trace Rules不是我们这次讨论的重点，这里就不太说太多了，更多详细的关于Matchers和Actions的信息，详见官方文档：<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#matchers">Matchers</a>，<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#actions">Actions</a>。</p>
<h3 id="4-Fingerprint-Rules"><a href="#4-Fingerprint-Rules" class="headerlink" title="4. Fingerprint Rules"></a>4. Fingerprint Rules</h3><p>在比较旧的Sentry版本中，也叫作Server Side Fingerprinting（叫这个名字是为了和SDK Fingerprinting对应）。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Fingerprint Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Server Side Fingerprinting</strong>。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/fingerprint_rules.png" alt="Fingerprint Rules"></p>
<p>Fingerprint Rules的配置方式和Stack Trace Rules类似，只有语法上不同。但是和Stack Trace Rules不同的是，Fingerprint Rules允许我们直接指定一个Issue的Fingerprint，它会完全覆盖默认的分组规则。</p>
<p>可以理解为，<strong>Stack Trace Rules更关注如何改变分组算法的输入数据</strong>（比如翻转一些标志位，或者对调用栈做一些裁剪），而<strong>Fingerprint Rules则直接指定了分组的结果</strong>。</p>
<p>首先，Fingerprint Rules同样是每一行是一条规则。每一条规则的Matcher和Stack Trace Rules的语法规则也是一样的，并且都可以设置<code>!</code>来表示取反，以及设置<code>#</code>来注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># You can use comments to explain the rules.  Rules themselves follow the</span><br><span class="line"># following syntax:</span><br><span class="line">matcher:expression -&gt; list of values</span><br><span class="line"># The list of values can be hardcoded or substituted values.</span><br></pre></td></tr></table></figure>

<p>Fingerprint Rules也是把一个Event从上到下进行匹配，每条规则都是对调用堆栈信息里的所有帧（Frames）执行，并且会把匹配到的第一条规则作为Event的Fingerprint。</p>
<p>不同的是，Stack Trace Rules的Matcher右侧是对Stack Trace Frames数据进行的一些操作，Fingerprint Rules的Matcher右侧直接就是需要指定的Fingerprint的值，可以是一些写死的<strong>常量</strong>，也可以是一些<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">内置的变量（Variables）</a>。</p>
<p>下面的例子就是把Error类型的Event根据type和value进行分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把 DatabaseUnavailable 和 ConnectionError 这两种类型的 Error，都标记为 system-down</span><br><span class="line">error.type:DatabaseUnavailable -&gt; system-down</span><br><span class="line">error.type:ConnectionError -&gt; system-down</span><br><span class="line"></span><br><span class="line"># 把 Error message 中，包含“connection error: ”的，都标记为 connection-error，同时把当时 Error 的 transaction 字段也拼接到 Fingerprint 中</span><br><span class="line">error.value:&quot;connection error: *&quot; -&gt; connection-error, &#123;&#123; transaction &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-Matchers"><a href="#4-1-Matchers" class="headerlink" title="4.1 Matchers"></a>4.1 Matchers</h4><p>对于Matchers，Sentry允许使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Glob_(programming)">glob patterns</a>语法。Sentry包含了以下的这些Matcher：</p>
<ul>
<li>error.type<br>匹配Error的type（name），对应的是JSON中的<code>metadata.type</code>，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.type:ZeroDivisionError -&gt; zero-division</span><br><span class="line">error.type:ConnectionError -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>error.value<br>匹配Error的value（message），对应的是JSON中的<code>metadata.value</code>，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.value:&quot;connection error (code: *)&quot; -&gt; connection-error</span><br><span class="line">error.value:&quot;could not connect (*)&quot; -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>message<br>匹配日志消息，对应的是JSON中的<code>message</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message:&quot;system encountered a fatal problem: *&quot; -&gt; fatal-log</span><br></pre></td></tr></table></figure>

<ul>
<li>logger<br>匹配当前的logger的名称，对应的是JSON中的<code>logger</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.mypackage.*&quot; -&gt; mypackage-logger</span><br></pre></td></tr></table></figure>

<ul>
<li>level<br>匹配当前Event的日志级别，对应的是JSON中的<code>level</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.FooLogger&quot; level:&quot;error&quot; -&gt; mylogger-error</span><br></pre></td></tr></table></figure>

<ul>
<li>tags.tag_name<br>匹配某个tag，某个标签名，允许使用通配符。<br>这里的tag_name，对应的是JSON中的<code>tags</code>字段中，每一项的名字。tags是一个数字，代表多个标签，每一项是一个标签，每个标签也是一个数字，数组有两个元素，第一个元素是标签名，即tag_name，第二个是标签值。例如下面这样：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iPhone10,2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device.family&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS 16.1.2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os.name&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;environment&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;release&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev-v3.24&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">      <span class="string">&quot;3.24.1023&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags.release:&quot;dev-v3.x&quot; -&gt; dev-v3-error</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.abs_path<br>匹配调用栈帧的绝对路径，对应的是每一帧中的<code>abs_path</code>字段，允许使用通配符，且大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.abs_path:&quot;**/my-utils/*.js&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.module<br>匹配调用栈帧的模块名，对应的是每一帧中的<code>module</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.module:&quot;*/my-utils/*&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.function<br>匹配调用栈帧的方法名，对应的是每一帧中的<code>function</code>字段，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;my_assertion_failed&quot; -&gt; my-assertion-failed</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.package<br>匹配当前帧所在的<code>package</code>，允许使用通配符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.package:&quot;**/libcurl.dylib&quot; -&gt; libcurl</span><br><span class="line">stack.package:&quot;**/libcurl.so&quot; -&gt; libcurl</span><br></pre></td></tr></table></figure>

<ul>
<li>family<br>通常用来缩小匹配范围，且通常和其他Matcher一起使用，目前包含以下值：<ul>
<li>javascript，任何来自于JavaScript的Event</li>
<li>native，任何来自于Native的Event</li>
<li>other，其他任何Event</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family:native !stack.module:&quot;myproject::*&quot; -&gt; not-from-my-project</span><br></pre></td></tr></table></figure>

<ul>
<li>app<br>匹配当前帧是否是在app内，通常和其他Matcher一起使用，包含yes和no两个值，对应的是每一帧中的in_app字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:yes stack.function:&quot;assert&quot; -&gt; assert</span><br></pre></td></tr></table></figure>

<p>更多关于Matchers的信息，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#matchers">Matchers</a>。</p>
<h4 id="4-2-Variables"><a href="#4-2-Variables" class="headerlink" title="4.2 Variables"></a>4.2 Variables</h4><p>在一条Fingerprint Rule的右侧，就是Variables，这里其实不只可以是变量，也可以是一些写死的常量。</p>
<p>对于变量来说，它们和Matchers的名字一样，并且会自动把变量对应的原始的值填入，用于生成Fingerprint。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;evaluate_script&quot; -&gt; script-evaluation, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这条规则会匹配调用栈中方法名为<code>evaluate_script</code>的Error，并且会把常量<code>script-evaluation</code>和当前Error的type（name）作为一部分，一起生成Fingerprint。</p>
<p>例如，<code>[&quot;script-evaluation&quot;, &quot;ReferenceError&quot;]</code></p>
<p>或者，<code>[&quot;script-evaluation&quot;, &quot;TypeError&quot;]</code></p>
<p>其他的变量和Matchers的名字一样，都是使用<code>&#123;&#123; &#125;&#125;</code>包裹起来的，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">Variables</a>。</p>
<h4 id="4-3-自定义标题"><a href="#4-3-自定义标题" class="headerlink" title="4.3 自定义标题"></a>4.3 自定义标题</h4><p>在设置Fingerprint Rules时，我们往往是想要按照自己的规则对Event进行分组，但是Event通常都是使用type和value来作为标题展示在Sentry中的，如果只改了Fingerprint Rules，那么原始的Event标题可能不那么友好，或者具有一定的误导性。</p>
<p>这个时候，我们可以在添加Fingerprint Rules的时候，额外添加title字段，即可设置这个分组的标题。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:my.package.* level:error -&gt; error-logger, &#123;&#123; logger &#125;&#125; title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>自定义标题前：</strong></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/issue_before_rename.png" alt="自定义标题前"></p>
<p><strong>自定义标题后：</strong></p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/issue_after_rename.png" alt="自定义标题后"></p>
<p>在设置了自定义标题后，就可以在Error的原始JSON数据中看到title发生了变化：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/title_changed_in_json.png" alt="自定义标题后的JSON"></p>
<blockquote>
<p><strong>🔔 注意：</strong></p>
<p>只有比较新的版本（比如Sentry 23.x）才支持设置自定义的title在旧版本的Sentry中（比如Sentry 20.x），上面的写法会让Sentry把后面的<code>title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</code>认为是Fingerprint的一部分。</p>
<p>具体是哪个版本开始支持的我没在网上查到，如果你私有部署的Sentry版本发现不支持，可以尝试升级一下版本。</p>
</blockquote>
<h4 id="4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules"><a href="#4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules" class="headerlink" title="4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?"></a>4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?</h4><p>在添加了自定义的Fingerprint Rules之后，我们如何确定某个Event有没有命中呢？</p>
<p>其实我们直接查看对于的JSON数据即可，如果匹配上的话，会看到下图这样：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/finger_print_in_json.png" alt="匹配上的JSON"></p>
<p>我们可以在_fingerprint_info中看到当前Event的各种信息</p>
<ul>
<li><code>client_fingerprint</code>，对应的是这个Event的SDK Fingerprint（下面会讲到，当前Event没有设置SDK Fingerprint，所以为default）</li>
<li><code>matched_rule</code>，对应的是Fingerprint Rules，比如这里显示当前Event命中的Matchers是哪个，以及当前Matchers设置的Fingerprint，还有我们自定义的title</li>
</ul>
<p>同时下面的<code>fingerprint</code>字段，也展示了当前Event最终的Fingerprint。</p>
<p>如果是旧版Sentry的话，这里就没有<code>_fingerprint_info</code>这个字段了，同时会把我们设置的title认为是Fingerprint的一部分，会是下面这样：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/old_version_custom_title_in_json.png" alt="旧版Sentry的JSON"></p>
<h3 id="5-SDK-Fingerprint"><a href="#5-SDK-Fingerprint" class="headerlink" title="5. SDK Fingerprint"></a>5. SDK Fingerprint</h3><p>如果上面说的Fingerprint Rules，不能满足我们的需要，那么我们可以使用SDK Fingerprint来更灵活地生成Fingerprint。</p>
<blockquote>
<p>从上面的Fingerprint Rules文档可以看到，Fingerprint Rules只有少部分Matchers支持设置通配符，所以可能没那么灵活。</p>
</blockquote>
<p>如果从上面的官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>中看，会发现文档里没有单独SDK Fingerprint的文档。</p>
<p>这是因为SDK Fingerprint是针对不同的Sentry SDK的，不同的项目会使用不同的Sentry SDK。每个SDK中设置Fingerprint的方式都不一样，甚至可能部分SDK不支持设置Fingerprint。所以要针对不同的平台，查看各自平台的SDK文档，这里以JavaScript Sentry SDK为例<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/javascript/usage/sdk-fingerprinting/">SDK Fingerprinting for Browser JavaScript</a>。</p>
<p><em>更多平台请看这里：<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/">Platforms</a></em></p>
<p>官网文档提供了比较友好的三个例子：</p>
<h4 id="5-1-基础示例"><a href="#5-1-基础示例" class="headerlink" title="5.1 基础示例"></a>5.1 基础示例</h4><p>单独处理某个上报Event的Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">method, path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(method, path, options).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    Sentry.withScope(<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// group errors together based on their request and response</span></span><br><span class="line">      scope.setFingerprint([method, path, <span class="built_in">String</span>(err.statusCode)]);</span><br><span class="line">      Sentry.captureException(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用变量替换，把一些Fingerprint Rules支持的变量填入，作为我们设置的Fingerprint的一部分，比如<code>&#123;&#123; default &#125;&#125;</code>，<code>&#123;&#123; stack.abs_path &#125;&#125;</code>，<code>&#123;&#123; error.type &#125;&#125;</code>等，详见上面提到的Fingerprint Rules变量。</p>
<h4 id="5-2-更细粒度地控制分组"><a href="#5-2-更细粒度地控制分组" class="headerlink" title="5.2 更细粒度地控制分组"></a>5.2 更细粒度地控制分组</h4><p>在原有的Fingerprint后拼接上自定义的一些字段，可以达到比默认的规则更细粒度的控制。</p>
<p>比如下面例子，进一步拆分Sentry创建的默认分组（由<code>&#123;&#123; default &#125;&#125;</code>表示），同时考虑错误对象的一些属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRPCError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message, functionName, errorCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The name of the RPC function that was called (e.g. &quot;getAllBlogArticles&quot;)</span></span><br><span class="line">    <span class="built_in">this</span>.functionName = functionName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For example a HTTP status code returned by the server.</span></span><br><span class="line">    <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MyRPCError) &#123;</span><br><span class="line">      event.fingerprint = [</span><br><span class="line">        <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span>,</span><br><span class="line">        <span class="built_in">String</span>(exception.functionName),</span><br><span class="line">        <span class="built_in">String</span>(exception.errorCode),</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-3-完全重写Fingerprint"><a href="#5-3-完全重写Fingerprint" class="headerlink" title="5.3 完全重写Fingerprint"></a>5.3 完全重写Fingerprint</h4><p>还可以直接整个重写Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnectionError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DatabaseConnectionError) &#123;</span><br><span class="line">      event.fingerprint = [<span class="string">&quot;database-connection-error&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-和Fingerprint-Rules怎么划分职责？"><a href="#5-4-和Fingerprint-Rules怎么划分职责？" class="headerlink" title="5.4 和Fingerprint Rules怎么划分职责？"></a>5.4 和Fingerprint Rules怎么划分职责？</h4><p>Fingerprint Rules和SDK Fingerprint都可以实现相同的功能，那么我们在设置自定义Fingerprint的时候，要怎么取舍，或者说什么时候用Fingerprint Rules，什么时候用SDK Fingerprint？</p>
<p><strong>Fingerprint Rules：</strong></p>
<ul>
<li>优势：<ul>
<li>可以随时修改规则，不需要进行代码的变更</li>
<li>可以同时在线上所有版本生效</li>
</ul>
</li>
<li>劣势：<ul>
<li>没有SDK Fingerprint灵活，有些处理不了，比如error.type不支持通配符匹配</li>
</ul>
</li>
</ul>
<p><strong>SDK Fingerprint：</strong></p>
<ul>
<li>优势：<ul>
<li>灵活，可以用JS很方便地处理或者自定义Fingerprint</li>
</ul>
</li>
<li>劣势：<ul>
<li>需要修改代码</li>
<li>分组规则和代码版本耦合，如果应用需要用户手动升级的话，那么旧版本应用内的Sentry上报没办法处理</li>
</ul>
</li>
</ul>
<p>从上面的优劣对比来看，可以看到<strong>Fingerprint Rules和SDK Fingerprint是优劣互补的，一方的优势恰好是另一方的劣势</strong>。</p>
<p>对比下来，我们在项目中使用的时候，建议<strong>如果可以使用Fingerprint Rules实现的，都用Fingerprint Rules，只有在Fingerprint Rules无法满足的情况下，再用考虑使用SDK Fingerprint</strong>。</p>
<h3 id="6-Filter"><a href="#6-Filter" class="headerlink" title="6. Filter"></a>6. Filter</h3><p>上面说了这么多关于Issue分组的，那么对于一些我完全不想要的上报，有没有办法完全不分组，直接过滤掉呢？</p>
<p>也是有的，可以在Sentry平台上，直接设置一些Filter过滤器来过滤，而不需要我们手动在使用SDK的地方修改。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Inbound Filters</strong>。</p>
<p>过滤器分为内置的一些过滤器，和自定义的过滤器。</p>
<h4 id="6-1-内置过滤器"><a href="#6-1-内置过滤器" class="headerlink" title="6.1 内置过滤器"></a>6.1 内置过滤器</h4><p>Sentry平台内置了一些可以直接启用的过滤器，这些过滤器包括：</p>
<ul>
<li>浏览器拓展插件的error</li>
<li>来自于localhost的event</li>
<li>已知的旧版浏览器错误，比如IE的</li>
<li>已知的网络爬虫错误</li>
<li>React hydrate的报错（和React服务端渲染有关的错误）</li>
<li>……</li>
</ul>
<p>这些过滤器可能和不同版本的Sentry有关，比较旧的版本中，可能会缺少一些过滤器。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/built_in_filters.png" alt="内置过滤器"></p>
<h4 id="6-2-自定义过滤器"><a href="#6-2-自定义过滤器" class="headerlink" title="6.2 自定义过滤器"></a>6.2 自定义过滤器</h4><p>可以创建自定义过滤器，目前支持以下三种，以下三种在匹配时，都是大小写不敏感的。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/custom_filters.png" alt="自定义过滤器"></p>
<h5 id="a-特定IP地址"><a href="#a-特定IP地址" class="headerlink" title="a. 特定IP地址"></a>a. 特定IP地址</h5><p>可以设置IP地址，过滤特定IP的错误上报，比如<code>127.0.0.1</code>。</p>
<h5 id="b-特定发布版本"><a href="#b-特定发布版本" class="headerlink" title="b. 特定发布版本"></a>b. 特定发布版本</h5><ul>
<li>发布版本，指的是在Sentry.init的时候，传入的release字段。</li>
<li>可以使用通配符，比如production-v3.24.*</li>
<li>如果某个Event不包含release字段，那么这个Event不会被过滤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">release</span>: <span class="string">`<span class="subst">$&#123;env&#125;</span>-<span class="subst">$&#123;version&#125;</span>`</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不确定自己项目上报后最终的<code>release</code>字段是什么，可以直接查看任意一个Error Event的原始JSON数据中的<code>release</code>字段（前提是init时传入了这个字段或者Event数据中有这个字段）</p>
<h5 id="c-Error-Message"><a href="#c-Error-Message" class="headerlink" title="c. Error Message"></a>c. Error Message</h5><ul>
<li>可以设置多个匹配项，每行一个。只要任意一个匹配项匹配成功，那么就会过滤这一条上报</li>
<li>对于Error类型的Event，会根据设置的匹配项，对格式为<code>&#123;exception.type&#125;: &#123;exception.value&#125;</code>的整个错误描述进行匹配。<br>但是不建议直接匹配整个描述，比如把冒号也加在里面，一般都是通过通配符来进行匹配。比如<code>*ConnectionError*</code></li>
<li>Transaction类型的Event，不会被过滤</li>
</ul>
<p>在设置完之后，可以检查下Issue的原始JSON数据，设置的过滤器会根据JSON里的<code>title</code>字段进行匹配，可以检查下是否有问题。</p>
<p>在设置好过滤器之后，我们就可以看到有多少Event被过滤掉了：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/sentry_issue_grouping/filterd_issues.png" alt="过滤掉的Event"></p>
<h2 id="五、治理"><a href="#五、治理" class="headerlink" title="五、治理"></a>五、治理</h2><p>到这里我们已经搞明白Sentry对Issue分组的原理了，也知道了怎么自定义分组。那我们是使用Stack Trace Rules还是Fingerprint Rules来处理呢？</p>
<p>使用Stack Trace Rules本质上还是根据调用栈来进行分组，但是这就需要我们必须上传Source Maps。</p>
<p>在上传了Source Maps的情况下，可以通过设置调用栈Stack Trace Rules来<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#cut-stack-traces">裁切调用栈</a>，或者限制Sentry在生成调用栈Fingerprint的时候需要考虑的<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#stack-trace-frame-limits">top帧数量</a>。</p>
<p>考虑到目前我们的项目因为某种原因，还不能上传Source Maps，同时代码每个版本变化可能会导致同样的问题的调用堆栈信息不同。基于我们的需求来看，完全自定义的Fingerprint Rules更符合我们的情况。</p>
<p>所以我们的项目会做如下处理：</p>
<ul>
<li>在Sentry平台上设置Fingerprint Rules，处理绝大部分可以处理的Error</li>
<li>少部分Fingerprint Rules无法处理的Error（比如error.type不支持通配符），通过SDK Fingerprint，在代码中Sentry.init的时候，增加<code>beforeSend</code>进行处理</li>
<li>一些不需要关注的Error，设置Inbound Filters直接过滤</li>
</ul>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>一番调研下来，通过Fingerprint Rules，Stack Trace Rules，SDK Fingerprint，以及Inbound Filters，我们把项目的Issue进行了自定义分组，更方便我们排查问题，分析处理。</p>
<p>Sentry是一个简单易上手的监控平台，但是Sentry上也有许多十分复杂的配置项，这篇文章只是Sentry文档的一小部分，有哪里不正确的，还请多多指正。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/" class="post-title-link" itemprop="url">字符编码简史：从二进制到UTF-8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-11T00:00:00+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>所谓<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码（Character encoding）</a>，就是把字符集中的字符，以某种指定的格式或规则，映射到另外一个集合中某一个值（相当于是把字符从一种形式转换成另一种形式），以便字符在计算机中存储或通过网络传递。</p>
<p>从计算机诞生到现在，对于字符的编码经历了多个阶段的变化，让我们一起来了解下字符编码的发展简史。</p>
</blockquote>
<h2 id="一、为什么聊这个"><a href="#一、为什么聊这个" class="headerlink" title="一、为什么聊这个"></a>一、为什么聊这个</h2><p>为什么会想要聊这个呢？这还得从开发中遇到的一个bug说起。</p>
<p>在一次开发中，由于要对一些字符串中的字符做一些高亮和截断，但是最开始只考虑了英文字符，单个字符的长度都是1，但是后续由于部分中文、emoji的加入，导致长度判断出了问题，出现了一些乱码。我们发现emoji的长度大多数为2甚至更长，比如“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span>.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这激起了我的一些好奇心，于是乎从头开始，完整了解了一下字符编码的发展简史。</p>
<h2 id="二、从二进制到各国编码"><a href="#二、从二进制到各国编码" class="headerlink" title="二、从二进制到各国编码"></a>二、从二进制到各国编码</h2><h3 id="1-二进制"><a href="#1-二进制" class="headerlink" title="1. 二进制"></a>1. 二进制</h3><p>我们都知道，由于电子管只有<code>开</code>和<code>关</code>这两种状态，所以计算机采用的是二进制来存储数据，也就是说所有的数据，最终都是以二进制的形式被计算机存储起来的。例如，a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示。</p>
<p>采用二进制可以更方便计算机进行运算，但是对于使用计算机的人类来说，就不那么方便了。为了方便人可以看懂计算机的二进制数据，需要<strong>设计一套规则来说明用哪些二进制数字表示哪个符号</strong>，这就是<strong>编码</strong>。</p>
<h3 id="2-ASCII"><a href="#2-ASCII" class="headerlink" title="2. ASCII"></a>2. ASCII</h3><p>为了防止不同的计算机使用不同的编码规则造成混乱，美国有关的标准化组织就推出了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII">ASCII编码（American Standard Code for Information Interchange，美国信息交换标准代码）</a>。</p>
<p>具体来说，ASCII编码一共规定了128个字符的编码，包括大小写英文字母、数字、常用符号，以及32个无法打印出来的控制符号。128个字符分别用数字<code>0 ~ 127</code>（十进制）来表示，对应的二进制为<code>0000 0000 ~ 0111 1111</code>。比如<code>a</code>对应是<code>97</code>（十进制），相应的二进制为<code>0110 0001</code>。</p>
<p>这样的话，任意英文都可以在计算机中用二进制表示了，比如“Hello world”这句话，在计算机中的表示就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100</span><br></pre></td></tr></table></figure>

<p>按理说128个字符，用7位二进制表示就够了（<em>2^7=128</em>），为什么要用8位二进制来表示呢。因为计算机里数据的计量单位是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节（byte）</a>，一个字节是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">8比特（bit）</a>，也就是8位，所以使用8位二进制（一个字节）来表示这128个字符，最前面的一位统一规定为0。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td><em>NUL</em></td>
<td><em>SOH</em></td>
<td><em>STX</em></td>
<td><em>ETX</em></td>
<td><em>EOT</em></td>
<td><em>ENQ</em></td>
<td><em>ACK</em></td>
<td><em>BEL</em></td>
<td><em>BS</em></td>
<td><em>HT</em></td>
<td><em>LF</em></td>
<td><em>VT</em></td>
<td><em>FF</em></td>
<td><em>CR</em></td>
<td><em>SO</em></td>
<td><em>SI</em></td>
</tr>
<tr>
<td>1x</td>
<td><em>DLE</em></td>
<td><em>DC1</em></td>
<td><em>DC2</em></td>
<td><em>DC3</em></td>
<td><em>DC4</em></td>
<td><em>NAK</em></td>
<td><em>SYN</em></td>
<td><em>ETB</em></td>
<td><em>CAN</em></td>
<td><em>EM</em></td>
<td><em>SUB</em></td>
<td><em>ESC</em></td>
<td><em>FS</em></td>
<td><em>GS</em></td>
<td><em>RS</em></td>
<td><em>US</em></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td><em>DEL</em></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>是空格。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>表示不同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII#%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">控制字符</a>。</p>
<h3 id="3-编码的“战国时期”"><a href="#3-编码的“战国时期”" class="headerlink" title="3. 编码的“战国时期”"></a>3. 编码的“战国时期”</h3><p>ASCII码是美国人发明的，对于只用英文的美国人来说，ASCII码其实就够用了，但是在计算机传到欧洲时情况就有变化了。虽然很多欧洲国家的语言中也是包含26个英文字母，但是很多国家还会包含一些带有声调或者其他附加符号的字母或者其他字母，如<code>À</code>、<code>Ö</code>等。对于这些字母，ASCII码无法表示。</p>
<h4 id="3-1-Latin-1"><a href="#3-1-Latin-1" class="headerlink" title="3.1 Latin-1"></a>3.1 Latin-1</h4><p>在这种背景下，欧洲推出了自己的一种编码，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1编码（又叫做ISO/IEC 8859-1）</a>。这个编码以ASCII为基础，使用了ASCII码中没有用到的第一位，在空置的<code>0xA0 ~ 0xFF</code>（即十进制的<code>160 ~ 255</code>，二进制的<code>1010 0000 ~ 1111 1111</code>）的范围内，加入96个字母及符号，以供使用附加符号的拉丁字母语言使用。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td><em>NBSP</em></td>
<td>¡</td>
<td>¢</td>
<td>£</td>
<td>¤</td>
<td>¥</td>
<td>¦</td>
<td>§</td>
<td>¨</td>
<td>©</td>
<td>ª</td>
<td>«</td>
<td>¬</td>
<td><em>SHY</em></td>
<td>®</td>
<td>¯</td>
</tr>
<tr>
<td>Bx</td>
<td>°</td>
<td>±</td>
<td>²</td>
<td>³</td>
<td>´</td>
<td>µ</td>
<td>¶</td>
<td>·</td>
<td>¸</td>
<td>¹</td>
<td>º</td>
<td>»</td>
<td>¼</td>
<td>½</td>
<td>¾</td>
<td>¿</td>
</tr>
<tr>
<td>Cx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">À</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">Á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">Â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">Ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">Ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">Å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">Æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">Ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">È</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">É</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">Ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">Ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">Ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">Í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">Î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">Ï</a></td>
</tr>
<tr>
<td>Dx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">Ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">Ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">Ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">Ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">Ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">Õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">Ö</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%97">×</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">Ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">Ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">Ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">Û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">Ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">Ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">Þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9F">ß</a></td>
</tr>
<tr>
<td>Ex</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">à</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">è</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">é</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">ï</a></td>
</tr>
<tr>
<td>Fx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">ö</a></td>
<td>÷</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C5%B8">ÿ</a></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>（32）是空格、<code>0xA0</code>（160）是不换行空格、<code>0xAD</code>是选择性连接号。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>、<code>0x80 ~ 0x9F</code>在此字符集中没有定义（控制字符是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C0%E4%B8%8EC1%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">ISO/IEC 6429</a>定义）。</p>
<h4 id="3-2-其他欧洲字符集"><a href="#3-2-其他欧洲字符集" class="headerlink" title="3.2 其他欧洲字符集"></a>3.2 其他欧洲字符集</h4><p>可是只有Latin-1还是不够，上面这个字符集只能用来表示<strong>西欧</strong>的字符，对于中欧、北欧，以及包括俄文在内的斯拉夫语族的字符都不包含在内，于是乎各个地区的国家，又陆续以同样的方式，使用ASCII编码中没有使用到的第一位进行拓展，产生了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-2">Latin-2</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-3">Latin-3</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-4">Latin-4</a>等等欧洲地区的其他Latin编码，这些编码后来统一定义在了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859">ISO/IEC 8859标准</a>里，并且分别命名为ISO/IEC 8859-1、ISO/IEC 8859-2等。</p>
<p>这些编码虽然很好地支持了不同的国家的语言，但是在不同国家之间的兼容性上，可以说是几乎没有。由于它们都是基于ASCII进行拓展，占用了ASCII未使用到的第一位，所以对于<code>0x7F</code>（十进制<code>0111 1111</code>）之后的字符，同样的二进制数，在不同国家地区代表了不同的字符。某个国家的文件在另一个国家打开，一般情况下看到的都是乱码。</p>
<h4 id="3-3-亚洲地区的编码"><a href="#3-3-亚洲地区的编码" class="headerlink" title="3.3 亚洲地区的编码"></a>3.3 亚洲地区的编码</h4><p>同时随着计算机在亚洲的流行，像中文、日文、韩文这种动则几千上万字符的语言，都基于ASCII增加或者自创了自己的编码，比如中文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GB_2312">GB2312</a>编码，日文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Shift_JIS">Shift_JIS</a>等。</p>
<p>由于越来越多的编码出现，电脑上一份文件要想展示正确的内容，<strong>需要电脑包含所有这些不同的字符集，并且采用正确的方式打开</strong>，否则看到的将会是乱码。这也就是乱码产生的本质，即使用了错误的编码方式/字符集来展示某个文件。</p>
<p>为了解决这个问题，Unicode编码出现了。</p>
<h2 id="三、Unicode：万国码"><a href="#三、Unicode：万国码" class="headerlink" title="三、Unicode：万国码"></a>三、Unicode：万国码</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode">Unicode，又叫做万国码</a>，其官方机构Unicode联盟整理、编码了世界上大部分的文字系统，使得电脑能以通用划一的字符集来处理和显示文字。目前最新的版本为2022年9月公布的15.0.0，已经收录超过14万个字符。</p>
<h3 id="1-码位"><a href="#1-码位" class="headerlink" title="1. 码位"></a>1. 码位</h3><p>Unicode编码从0开始，为每一个字符分配一个唯一的编号，这个编号就叫做<strong>码位（code point，也叫码点）</strong>，以“计算机”的“机”字举例，“机”的码位为<code>26426</code>（十进制），即Unicode字符集中第26426个字符，就是“机”。</p>
<p>但是在表示一个Unicode的字符时，通常会用<code>U+</code>然后紧接着一组十六进制的数字来表示这一个字符。也就是说，“机”在Unicode中的表示方式是<code>U+673A</code>，码位是<code>673A</code>。</p>
<p>Unicode为了和已有的编码方式相互兼容，其首256个字符保留给ISO/IEC 8859-1所定义的字符（Latin-1编码），使既有的西欧语系文字（包括英文）的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。</p>
<h3 id="2-平面"><a href="#2-平面" class="headerlink" title="2. 平面"></a>2. 平面</h3><p>对于不同国家数十万的字符，Unicode联盟显然不可能一下子就给出全部字符的码位定义，更何况现在的有些字符，在那个时候还没有出现。Unicode联盟把所有字符，分为了17组进行编排，每组称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">平面（Plane）</a>，而每平面拥有65536（即216）个代码位。</p>
<p>也就是说目前一共有17个平面，共计2^16 * 17（1114112）个码位，最多可以表示一百多万个字符。</p>
<table>
<thead>
<tr>
<th><strong>平面</strong></th>
<th><strong>始末字符值</strong></th>
<th><strong>名称</strong></th>
<th><strong>简称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">0号平面</a></td>
<td><code>U+0000 ~ U+FFFF</code></td>
<td><strong>基本多文种平面</strong></td>
<td><strong>BMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%80%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">1号平面</a></td>
<td><code>U+10000 ~ U+1FFFF</code></td>
<td><strong>多文种补充平面</strong></td>
<td><strong>SMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%BA%8C%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">2号平面</a></td>
<td><code>U+20000 ~ U+2FFFF</code></td>
<td><strong>表意文字补充平面</strong></td>
<td><strong>SIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">3号平面</a></td>
<td><code>U+30000 ~ U+3FFFF</code></td>
<td><strong>表意文字第三平面</strong></td>
<td><strong>TIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%9B%9B%E8%87%B3%E5%8D%81%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">4-13号平面</a></td>
<td><code>U+40000 ~ U+DFFFF</code></td>
<td>（尚未使用）</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">14号平面</a></td>
<td><code>U+E0000 ~ U+EFFFF</code></td>
<td><strong>特别用途补充平面</strong></td>
<td><strong>SSP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">15号平面</a></td>
<td><code>U+F0000 ~ U+FFFFF</code></td>
<td>保留作为<strong>私人使用区（A区）</strong></td>
<td><strong>PUA-A</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">16号平面</a></td>
<td><code>U+100000 ~ U+10FFFF</code></td>
<td>保留作为<strong>私人使用区（B区）</strong></td>
<td><strong>PUA-B</strong></td>
</tr>
</tbody></table>
<p>其中我们常用的一些字符，都定义在了第一个平面里，即<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">基本多文种平面（Basic Multilingual Plane, BMP）</a>，或称<strong>基本平面</strong>或<strong>0号平面（Plane 0）</strong>。比如大部分的汉字，都是定义在<code>U+4E00 ~ U+9FFF</code>代表的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>内（我们上面所说的“机”，<code>U+673A</code>，也在里面）。</p>
<p>而除了基本平台其他的十六个平面，都叫做辅助平面，用来放一些不常用的字符（如扑克牌花色），或者已经被废弃的古文字（如甲骨文）等。还有一些用作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%81%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%8C%BA">私人使用区</a>，主要是指没有在Unicode标准中指定，而是由合作用户之间的私人协议决定其用途的编码区。</p>
<p>现在看起来只需要使用Unicode编码，就可以囊括所有的语言符号，再也不会有乱码的问题了，真美好。</p>
<h3 id="3-好像还有些事情要做"><a href="#3-好像还有些事情要做" class="headerlink" title="3. 好像还有些事情要做"></a>3. 好像还有些事情要做</h3><p>可是事情真的像预期的那边美好吗？</p>
<p>Unicode定义了字符的编码方式，但是没有定义这些编码的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a>。就是说Unicode编码虽然给每一个字符一个唯一的编码，解决了字符集不统一的情况，但是没有定义在计算机底层，要怎么存储或者传输每一个Unicode字符。</p>
<p>例如ASCII定义了用一个字节（8位二进制）来存储每个字符，GB2312是用两个字节来存储每个汉字，Unicode的每一个字符应该用多大的空间来存储呢？这就涉及到Unicode编码的实现方式了，或者称为Unicode转换格式。</p>
<h2 id="四、UTF"><a href="#四、UTF" class="headerlink" title="四、UTF"></a>四、UTF</h2><p>Unicode编码的实现方式称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><strong>Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong></a>。由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式也有所不同，下面我们说几个经常听到的转换格式。</p>
<h3 id="0-码元"><a href="#0-码元" class="headerlink" title="0. 码元"></a>0. 码元</h3><p>在开始之前，先引入一个概念，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81#%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E4%BB%A3%E7%A0%81%E9%A1%B5%EF%BC%8C%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%98%A0%E5%B0%84">码元（Code Unit）</a>，是指一种编码转换格式中具有最短的二进制组合的单元，即字符占用的最少二进制位。比如上面说的ASCII编码，每个字符都是占用8位二进制，所以ASCII编码的码元是8。</p>
<h3 id="1-UTF-32"><a href="#1-UTF-32" class="headerlink" title="1. UTF-32"></a>1. UTF-32</h3><p>首先，最简单的就是，用一个能包含所有Unicode编码的空间，来存储每一个字符。Unicode目前一共有17个平面，共计216 * 17个码位。</p>
<p><strong><code>2^16 * 17 = 2^20 + 2^16</code></strong></p>
<p><strong><code>2^20 &lt; 2^20 + 2^16 &lt; 2^21</code></strong></p>
<p>只需要使用大于21位的二进制来存储就可以了，例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-32">UTF-32</a>编码，这个编码用32位（4个字节）的二进制来存储Unicode编码的字符，不算固定为<code>0</code>的首位数字，总计能表示 231个字符，够用了。</p>
<p>由于UTF-32可以表示的字符比Unicode所有字符还多，可以做到UTF-32的编码与字符的Unicode码位的数值完全一致。由于UTF-32种每个字符都是用用32位（4个字节）来表示，所以<strong>UTF-32的码元就是32</strong>。</p>
<p>还是以上面的“机”为例，它的码位是<code>U+673A</code>（即十六进制<code>0x673A</code>），那么它在UTF-32中的编码值为<code>0x0000673A</code>（因为总共有32位，4个字节，所以要在前面补上两个字节的0，凑够4字节）</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-32编码：</strong></td>
<td><code>0x0000 673A</code></td>
</tr>
<tr>
<td><strong>UTF-32编码的二进制形式：</strong></td>
<td><code>00000000 00000000 01100111 00111010</code></td>
</tr>
</tbody></table>
<p>看起来UTF-32挺好的，可以通过Unicode码位直接知道对应的UTF-32编码，查找编码是一个常数时间的操作。但是它有个巨大的缺陷，就是占用空间太大。</p>
<p>在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，一般只需要1-2个字节就可以表示，比如上面的“机”（<code>01100111 00111010</code>），只需要两个字节就可以表示，但是UTF-32中却占了4个字节。</p>
<p>对于纯英文的文本来说，这种情况更甚，比如字母<code>a</code>的码位为<code>0110 0001</code>，只需要一个字节，但是在UTF-32同样要用4个字节来表示，<code>00000000 00000000 00000000 01100001</code>。</p>
<p>这也就造成UTF-32所需空间接近UTF-16的两倍和UTF-8的四倍，空间浪费较多。所以UTF-32编码，目前基本没有人使用，甚至<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/#character-encodings">在HTML5标准中明确规定在HTML中禁止使用UTF-32编码</a>。</p>
<h3 id="2-UTF-16"><a href="#2-UTF-16" class="headerlink" title="2. UTF-16"></a>2. UTF-16</h3><h4 id="2-1-变长编码"><a href="#2-1-变长编码" class="headerlink" title="2.1 变长编码"></a>2.1 变长编码</h4><p>既然在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，那么有没有一种更节省空间的实现方式？有，那就是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>。（当然这个是从现在这个时间点来看的，UTF-16设计出来的目的并不是为了解决UTF-32的问题，还涉及到一个UCS-2的编码实现方式，下面会讲到）</p>
<p>UTF-16是一个<strong>变长的编码转换格式</strong>，也就是说相比UTF-32这种固定长度（4字节）的来说，它的编码长度取决于字符在Unicode中的码位，可能是2个字节，有可能是4个字节。</p>
<p>根据上面的Unicode平面对应的码位，可以看到基本平面内的字符<code>U+0000 ~ U+FFFF</code>，长度最长只有2个字节。所以对于基本平面的字符，在UTF-16中用2个字节来表示。对于其他辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，则用4个字节来表示。由于UTF-16中字符最少要占用2个字节（16位），所以UTF-16的码元是16，即UTF-16中字符要么用1个码元来表示，要么用2个码元来表示。</p>
<p>以上面“计算机”中的“机”为例，“机”的码位是<code>U+673A</code>，位于基本平面内，用两个字节表示，这个时候它的UTF-16编码和它在Unicode中的码位是一样的，即<code>0x673A</code>，换成二进制就是<code>01100111 00111010</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码的二进制形式：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>这样在绝大多数情况下，用2个字节就可以存储或者表示字符，极少数情况下用到的辅助平面字符，才会用到4个字节的表示方式。</p>
<p>但是这样也会带来一个问题，计算机在读取字符的二进制时，比如读取了2个字节，要怎么知道这2个字节表示的是一个字符，还是说要再加上后面2个字节连起来组成一个字符呢？</p>
<h4 id="2-2-前导代理和后尾代理"><a href="#2-2-前导代理和后尾代理" class="headerlink" title="2.2 前导代理和后尾代理"></a>2.2 前导代理和后尾代理</h4><p>我们知道，需要用4个字节来表示的字符，都是位于16个辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，16辅助平面内的字符总用有220个：</p>
<p><strong><code>2^16 * 16 = 2^20</code></strong></p>
<p>这些辅助平面内的字符，相对于辅助平面内的第一个字符<code>U+10000</code>，偏移量分别是 0 ~ 2^20 - 1</p>
<p><strong><code>0x10000 - 0x10000 = 0</code></strong></p>
<p><strong><code>0x10FFFF - 0x10000 = 2^20 - 1</code></strong></p>
<p>只需要记录下每个辅助平面内字符<strong>相对于第一个辅助平面字符的偏移量</strong>，就可以知道每个字符在Unicode中的码位。</p>
<p>而220个数字只需要用20位长度的二进制就可以表示，20位长度的二进制拆分到4个字节里，每2个字节存储10位长度的二进制。</p>
<p>以<code>𐐷</code>这个字符为例，这个字符的码位是<code>U+10437</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code></td>
</tr>
</tbody></table>
<p>也就是说<code>𐐷</code>这个字符占4个字节，前2个字节是<code>00000000 00000001</code>，后2个字节是<code>00000000 00110111</code>。</p>
<p>但是到这里依然没有解决上面的问题，计算机在读取到前2个字节<code>00000000 00000001</code>时，不知道这表示的是<code>SOH</code>这个控制字符，还是说要和后面2个字节连起来，共同组成一个字符<code>𐐷</code>。因此，需要在<strong>基本平面</strong>中保留不对应任何Unicode字符的两个区域，用于标识UTF-16的4字节字符的前10位和后10位。这两个区域就是</p>
<table>
<thead>
<tr>
<th><code>0xD800 ~ 0xDBFF</code></th>
<th>容纳前10位的区域，区域大小为 210</th>
</tr>
</thead>
<tbody><tr>
<td><code>0xDC00 ~ 0xDFFF</code></td>
<td>容纳后10位的区域，区域大小为 210</td>
</tr>
</tbody></table>
<p>而只需要把上面的前10位<code>00000000 00000001</code>和后10位<code>00000000 00110111</code>，分别加上这两个区域的起始值，就是这个字符在UTF-16中真正的表示：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code>, <code>0x0001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code>, <code>0x0037</code></td>
</tr>
<tr>
<td>**前10位 + **<code>0xD800</code><strong>：</strong></td>
<td><code>0xD800</code> + <code>0x0001</code> = <code>0xD801</code>, <code>11011000 00000001</code></td>
</tr>
<tr>
<td>**后10位 + **<code>0xDC00</code><strong>：</strong></td>
<td><code>0xDC00</code> + <code>0x0037</code> = <code>0xDC37</code>, <code>11011100 00110111</code></td>
</tr>
<tr>
<td><strong>UTF-16 中真正的表示：</strong></td>
<td><code>0xD801``0xDC37</code>，<code>11011000 00000001``11011100 00110111</code></td>
</tr>
</tbody></table>
<p>所以<code>𐐷</code>这个字符，在UTF-16中的真正表示为<code>0xD801</code> <code>0xDC37</code>，以二进制形式就是<code>11011000 00000001</code> <code>11011100 00110111</code>，前后各2个字节分别叫做这个字符的<strong>前导代理</strong>（lead surrogates）和<strong>后尾代理</strong>（trail surrogates），这个字符就是由这样一个<strong>代理对</strong>（Surrogate Pair）来表示。</p>
<h4 id="2-3-计算机读取"><a href="#2-3-计算机读取" class="headerlink" title="2.3 计算机读取"></a>2.3 计算机读取</h4><p>计算机在读取时，每读取2个字节，如果这两个字节范围处于<code>0xD800 ~ 0xDBFF</code>这个区域，那么就知道这2个字节，要和后面的2个字节连起来，共同组成一个字符。</p>
<p>以上面为例，在读取到<code>11011000 00000001</code>时，发现这个数字位于<code>0xD800 ~ 0xDBFF</code>，那么就知道<code>11011000 00000001</code>表示这个字符的前导代理而不是一个真正字符，需要再读取后2个字节里的后尾代理，具体步骤为：</p>
<ol>
<li>读取：<code>11011000 00000001</code> <code>11011100 00110111</code>，即<code>0xD801</code> <code>0xDC37</code></li>
<li>分别减去<code>0xD800</code>和<code>0xDC00</code>：<code>0x0001</code> <code>0x0037</code>，即<code>0000000001</code> <code>0000110111</code></li>
<li>组合起来就是<code>0000 0000 0100 0011 0111</code>，即<code>0x00437</code></li>
<li>也就是说字符相对于<code>0x10000</code>的偏移量是<code>0x00437</code>，或者换种说法，这个字符是辅助平面字符里的第<code>0x00437</code>个辅助平面字符</li>
<li>所以真正的码位是<code>0x10000 + 0x00437 = 0x10437</code>，即<code>U+10437</code>，所表示字符为<code>𐐷</code></li>
</ol>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>到这里UTF-16基本是说完了，看起来很复杂，但总结下来就三点：</p>
<ol>
<li>对于基本平面内的字符，用2个字节表示；对于其他辅助平面内的字符，用4个字节表示</li>
<li>对于辅助平面内的字符，拆成两半<ol>
<li>一半映射在<code>0xD800 ~ 0xDBFF</code>内</li>
<li>一半映射在<code>0xDC00 ~ 0xDFFF</code>内</li>
</ol>
</li>
<li>读取2个字节，如果发现这2个字节的码位处于<code>0xD800 ~ 0xDBFF</code>，那么就当做4字节字符处理，再读取后面的2个字节共同组成字符。否则就直接作为2字节字符</li>
</ol>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>既然UTF-16可以通过对字符做区分，不同字符使用不同长度的字节来表示，那应该有更加节省空间的变长编码转换格式才对。而<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</a>就是这样一个变长的编码转换格式。</p>
<h4 id="3-1-编码规则"><a href="#3-1-编码规则" class="headerlink" title="3.1 编码规则"></a>3.1 编码规则</h4><p>UTF-8从名字就可以知道，这是一种最小长度为8位二进制（即1个字节）的编码转换格式。使用 1 ~ 4 个字节来表示字符（1、2、3、4个字节都有可能），具体的规则如下：</p>
<table>
<thead>
<tr>
<th><strong>码位范围</strong></th>
<th><strong>字节数</strong></th>
<th><strong>Byte 1</strong></th>
<th><strong>Byte 2</strong></th>
<th><strong>Byte 3</strong></th>
<th><strong>Byte 4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000 ~ U+007F</code></td>
<td>1</td>
<td><code>0xxxxxxx</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0080 ~ U+07FF</code></td>
<td>2</td>
<td><code>110xxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0800 ~ U+FFFF</code></td>
<td>3</td>
<td><code>1110xxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
</tr>
<tr>
<td><code>U+10000 ~ U+10 FFFF</code></td>
<td>4</td>
<td><code>11110xxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
</tr>
</tbody></table>
<p>对于一个字符，首先确定其在Unicode中的码位，根据上面表格第一列，确定这个码位所属的范围所需要用到的字节。</p>
<ol>
<li>如果是单字节字符，那么这个字节首位为<code>0</code>，用剩下的7位来表示这个字符。可以看到，对于ASCII中的字符，在ASCII和UTF-8中的编码规则是一致的，也就是说UTF-8兼容ASCII编码</li>
<li>如果是多字节字符，假设是<code>n</code>字节字符，就在第一个字节开头用<code>n</code>个<code>1</code>来填充，第<code>n + 1</code>位用<code>0</code>填充，且后面的字节的前两个字符，都用<code>10</code>来填充。剩下的没有被填充的位，就是用来填充这个字符Unicode码位的二进制，从右向左填充，未填充满的用<code>0</code>补齐</li>
</ol>
<p>由于UTF-8中字符最少占据1个字节（8位），所以<strong>UTF-8的码元是8</strong>，即UTF-8中字符用 1 ~ 4 个码元来表示。<br>还是以上面的“计算机”的“机”为例：</p>
<ol>
<li>“机”的码位为<code>U+673A</code></li>
<li>根据上面的表格，处于<code>U+0800 ~ U+FFFF</code>这个范围内，所以要用3个字节来表示</li>
<li>也就是说格式为<code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>，<code>x</code>为这个字符码位二进制填充位</li>
<li><code>U+673A</code>的二进制为<code>110011100111010</code>，从右向左依次填充，得到：</li>
</ol>
<p><code>11100110</code> <code>10011100</code> <code>10111010</code><br>即字符“机”在UTF-8中的编码为<code>11100110 10011100 10111010</code>，用16进制表示为<code>0xE69CBA</code>。</p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码：</strong></td>
<td><code>0xE69CBA</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码的二进制形式：</strong></td>
<td><code>11100110 10011100 10111010</code></td>
</tr>
</tbody></table>
<h4 id="3-2-真的最节省空间吗？"><a href="#3-2-真的最节省空间吗？" class="headerlink" title="3.2 真的最节省空间吗？"></a>3.2 真的最节省空间吗？</h4><p>UTF-8最小字节单位为 1 个字节，相比起UTF-16和UTF-32最小字节单位是 2 字节和 4 字节来说，确实是可以节省下不少空间。但是这个节省空间是相对的。</p>
<p>对于以拉丁字母作为主要语言的英语、西欧语言等来说，绝大多数情况下只需要 1 个字节或者 2 个字节就可以表示字符。对于这些语言来说，最节省空间的确实是UTF-8。但是对于很多亚洲国家来说，比如中日韩，却不是这样。</p>
<p>从上面的内容可以知道，对于中日韩这些文字来说，在UTF-16中，绝大多数文字都只需要 2 个字节就可以表示，但是在UTF-8中，却需要 3 个字节来表示，占用空间比UTF-16多出了 50%，这样看来，对于中日韩文字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">CJK</a>文字来说，最节省空间的反而是UTF-16编码了。</p>
<p>也就是说，哪种编码转换格式最节省空间是由字符内容决定的，UTF-8只有在英语等拉丁语言的情况下才是最节省空间的，但是对于亚洲地区来说，最合适的编码方式是UTF-16。</p>
<h3 id="4-Big-Endian-和-Little-Endian"><a href="#4-Big-Endian-和-Little-Endian" class="headerlink" title="4. Big Endian 和 Little Endian"></a>4. Big Endian 和 Little Endian</h3><p>其实除了上面说的内容，对于多字节的编码转换格式来说，还有一个 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%A4%A7%E7%AB%AF%E5%BA%8F">Big Endian（大端序，简称BE）</a>和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%B0%8F%E7%AB%AF%E5%BA%8F">Little Endian（小端序，简称LE）</a>的概念。因为这些多字节的编码中字符占用多个字节，在将字符二进制拆分成多个字节后，多个字节可能会有排列顺序的区分。</p>
<p>比如上面的“机”，UTF-16编码中会把码位二进制<code>01100111 00111010</code>放到两个字节里：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>那么在UTF-16 BE和UTF-16 LE中，编码分别为<code>01100111 00111010</code>和<code>00111010 01100111</code>，两个字节的顺序正好相反。</p>
<table>
<thead>
<tr>
<th><strong>UTF-16 BE 编码</strong></th>
<th><code>01100111 00111010</code></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><strong>UTF-16 LE 编码</strong></th>
<th><code>00111010 01100111</code></th>
</tr>
</thead>
</table>
<p>我们上面举例的一些字符，都是以BE的形式来表示的。这个其实没有一个优劣，更多是一种人们情绪化的选择，就好像鸡蛋应该从大的那头拨开还是小的那头拨开一样。感兴趣的可以看看这个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E7%AB%AF%EF%BC%88endian%EF%BC%89%E7%9A%84%E8%B5%B7%E6%BA%90">大小端问题的起源</a>。</p>
<h2 id="五、JavaScript中使用的编码"><a href="#五、JavaScript中使用的编码" class="headerlink" title="五、JavaScript中使用的编码"></a>五、JavaScript中使用的编码</h2><p>说了这么多，在JavaScript中使用的是哪种编码呢？</p>
<h3 id="1-编码格式"><a href="#1-编码格式" class="headerlink" title="1. 编码格式"></a>1. 编码格式</h3><p>其实JavaScript使用的是一个叫做UCS-2的编码，并不是上面的任何一种。UCS-2是一种<strong>定长</strong>的编码转换格式，用2个字节来表示字符，可以理解为是只能用来表示基本平面内字符的UTF-16，不能表示辅助平面内的字符。或者说<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16#UTF-16%E8%88%87UCS-2%E7%9A%84%E9%97%9C%E4%BF%82">UTF-16是基于UCS-2的超集</a>。</p>
<p>同样的，Java和 Objective-C都是使用的是UCS-2。这些语言之所以选择这个编码转换格式，是因为在Unicode早期，大家都以为用2个字节就足够表示所有字符了，所以UCS-2使用了2字节定长编码，且字符编码和字符的Unicode码位的一样的，获取字符的开销是一个常数操作，对于需要处理字符串的编程语言来说是最合适的选择。</p>
<p>但是到后期随着Unicode的扩充，2字节定长编码的UCS-2无法满足需求，也就诞生了基于UCS-2的UTF-16编码，在基本平面内兼容UCS-2，同时通过可变的长度来支持辅助平面内字符。这些编程语言也基本过渡到了UTF-16上。</p>
<p>但是一些稍微新一些的编程语言，比如Python3，Go等，默认的编码转换格式都已经是UTF-8了。</p>
<h3 id="2-获取字符串长度"><a href="#2-获取字符串长度" class="headerlink" title="2. 获取字符串长度"></a>2. 获取字符串长度</h3><p>既然知道了JavaScript中的编码转换格式，那我们来试下获取字符长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.length;   <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.length;  <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.length;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，同样是一个字符，“a”和“机”的长度都是“1”，但是一个笑哭的emoji“😂”，长度却是2。这是为什么呢？<br><em><strong>因为获取字符串长度，本质上就是获取字符串在当前编码格式中占用的码元（Code Unit）数量。</strong></em><br>在UTF-16（UCS-2）中，码元为16（2个字节）：</p>
<ul>
<li>“a”和“机”都是<strong>基本平面</strong>内的字符，都可以用 2 个字节，即 1 个UTF-16码元来表示，所以长度是1</li>
<li>“😂”这个emoji的Unicode码位是<code>U+1F602</code>，已经超出了基本平面<code>U+0000 ~ U+FFFF</code>，是<strong>辅助平面</strong>内的字符，要用 4 个字节，即 2 个UTF-16码元来表示，所以长度是2</li>
</ul>
<p>Java和OC中执行结果也和上面一样。相应的，如果这些字符串放在默认编码方式为UTF-8的语言中，如Go，得到的长度就会是下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="string">&quot;a&quot;</span>)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;机&quot;</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;😂&quot;</span>)   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>这是因为在UTF-8中，码元为8（1个字节）：</p>
<ul>
<li>“a”，<code>U+0061</code>，是用 1 个字节表示，1个码元，所以长度是1</li>
<li>“机”，<code>U+673A</code>，用 3 个字节表示，即 3 个UTF-8码元，所以长度是3</li>
<li>“😂”，<code>U+1F602</code>，用 4 个字节表示，即 4 个UTF-8码元，所以长度是4</li>
</ul>
<p>所以，在一些前后端默认字符编码编码格式不一样的场景，比如前端（JS/Java/OC），后端Go，就可能会出现一些字符串长度判断不一致的情况（看到一篇<a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">文章</a>里就有遇到这种情况）。</p>
<h3 id="3-获取字符串中真正的字符个数"><a href="#3-获取字符串中真正的字符个数" class="headerlink" title="3. 获取字符串中真正的字符个数"></a>3. 获取字符串中真正的字符个数</h3><p>说了这么多，有没有办法在JS中获取到真正的字符个数呢，比如“😂”。有的，通过<code>Array.from(str)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;😂&#x27;</span>).length;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>再来看一个特殊情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>.length;                <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>).length;    <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>);           <span class="comment">// [&#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可以看到“👩‍👩‍👧‍👧”这个emoji，其实是由4个emoji组合到一起的，并且中间用了<code>U+200D</code>这个名字叫做“零宽度连字符”的字符来连接，这个字符的长度是1，所以这个emoji本质上是7个字符组合到一起的，<strong>总计7个字符</strong>，长度为：</p>
<p><strong><code>2 + 1 + 2 + 1 + 2 + 1 + 2 = 11</code></strong></p>
<p>我们也可以反向来试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是空字符串</span></span><br><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;\u&#123;200D&#125;&#x27;</span>);        <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是 U+200D</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其他一些和字符编码有关的方法和逻辑"><a href="#4-其他一些和字符编码有关的方法和逻辑" class="headerlink" title="4. 其他一些和字符编码有关的方法和逻辑"></a>4. 其他一些和字符编码有关的方法和逻辑</h3><h4 id="4-1-获取码位"><a href="#4-1-获取码位" class="headerlink" title="4.1 获取码位"></a>4.1 获取码位</h4><p>在JS中，想要获取一个字符的Unicode码位很简单，只需要通过<code>String.prototype.codePointAt()</code>即可获取码位的<strong>十进制值</strong>。<code>codePointAt</code>接受一个参数，可以用来获取指定码元处码位，不传则默认为<code>0</code>，即这个字符第一个码元处的码位的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.codePointAt();    <span class="comment">// 97 (十进制)</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.codePointAt();   <span class="comment">// 26426</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt();   <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">0</span>);  <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">1</span>);  <span class="comment">// 56834</span></span><br></pre></td></tr></table></figure>

<p>如果指定的这个码元位置的码位是UTF-16<strong>代理对的前导代理</strong>，那么就会返回这个字符完整的Unicode码位，否则就直接返回这个位置的码位，详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt">MDN</a>。</p>
<p>如上面<code>&#39;😂&#39;.codePointAt(0)</code>，因为“😂”这个字符在UTF-16中是用2个码元（4个字节）来表示的，根据规则组成这个字符的 2个码元是一个<strong>代理对</strong>，它的第一个码元是前导代理，所以直接返回了“😂”这个字符的完整Unicode码位<code>128514</code>，即<code>U+1F602</code>。</p>
<p>但是<code>&#39;😂&#39;.codePointAt(1)</code>，因为索引为1的码元，是一个后尾代理，所以直接返回了这个后尾代理的码位<code>56834</code>，即<code>U+DE02</code>。而“😂”的在UTF-16中的完整编码格式为<code>U+D83D</code> <code>U+DE02</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>😂</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+1F602</code></td>
</tr>
<tr>
<td><strong>前导代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>后尾代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>UTF-16 BE 中的表示：</strong></td>
<td><code>U+D83D</code> <code>U+DE02</code></td>
</tr>
</tbody></table>
<h4 id="4-2-用码位表示字符"><a href="#4-2-用码位表示字符" class="headerlink" title="4.2 用码位表示字符"></a>4.2 用码位表示字符</h4><p>JS中是允许用码位来表示字符的，表示方式是<code>\u&#123;xxxx&#125;</code>，即反斜杠 + u + 花括号，花括号内为16进制的码位。又由于JS使用的是UTF-16，所以在JS中可以用下面的方式来表示“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span>;                 <span class="comment">// true Unicode码位表示</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;          <span class="comment">// true UTF-16编码格式表示</span></span><br><span class="line"><span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-直接查看文件中字符的二进制"><a href="#4-3-直接查看文件中字符的二进制" class="headerlink" title="4.3 直接查看文件中字符的二进制"></a>4.3 直接查看文件中字符的二进制</h4><p>说了这么多，都是在讲解，那有什么办法直接查看某个字符或者字符串的二进制编码呢？最简单的我们可以通过一些文本编辑器来看，比如sublime。还是以“机”和“𐐷”为例。</p>
<p>在sublime中输入一个字符，然后以某种编码格式保存，我们这里分别用UTF-8，UTF-16 BE，UTF-16 LE来保存：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/character_encoding/save_by_sublime.png" alt="save_by_sublime.png"></p>
<p>然后打开终端，通过<code>xbb -b</code>命令分别查看三个文件的二进制内容：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/character_encoding/show_binary.png" alt="show_binary.png"></p>
<p>可以看到二进制内容，和上面讲到的是完全一致的。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>到这里基本上已经说完了，字符编码从二进制，到ASCII问世，到Latin-1、2、3…，再到GB2312、Shift_JIS的“战国时代”，直到最后Unicode万国码“一统天下”。而随Unicode诞生的，还有UTF-32、UTF-16、UTF-8、UCS-2等。</p>
<p>可以看到一个小的字符编码引起的Bug，后面可以挖出这么多，有时候日常开发中不那么起眼的一些点，后面也有很多有趣的内容。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>感谢下面这些参考链接的作者，看这些文章收获很多！</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">Wikipedia 字符编码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_37967865/article/details/103311765">计算机编码发展历史和编码方式_计算机最早的编码方式_cacho_37967865的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">‘👩‍👩‍👧‍👧’.length === 11 ? Emoji 有多长</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/16205678.html">前端开发中需要搞懂的字符编码知识 - jimojianghu - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.xxkid.com/post/e5b12a4a.html">JS 判断带 emoji 的字符串长度的究极方法 - 小小孩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/p/27990849">程序的逻辑 (6) 编码的本质与乱码的恢复</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346662618">《JavaScript 权威指南》解读——字符串是 16 位值的序列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34281537/article/details/92508414">Javascript中的string类型使用UTF-16编码_weixin_34281537的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/308677093">Java 为什么使用 UTF-16 而不是更节省内存的 UTF-8？ - 知乎</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/" class="post-title-link" itemprop="url">聊聊深色模式（Dark Mode）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 10:29:00" itemprop="dateCreated datePublished" datetime="2023-03-13T10:29:00+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-21 10:47:55" itemprop="dateModified" datetime="2025-04-21T10:47:55+08:00">2025-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是深色模式"><a href="#什么是深色模式" class="headerlink" title="什么是深色模式"></a>什么是深色模式</h2><p>深色模式（Dark Mode），或者叫暗色模式，黑夜模式，是和日常使用的浅色（亮色）模式（Light Mode）相对应的一种UI主题。</p>
<p>深色模式最早来源于人机交互领域的研究和实践，从2018年左右开始，Apple推出了<strong>iOS 13</strong>，其中包含了系统级别的深色模式，可以将整个系统的界面切换为暗色调。</p>
<p>Google也在<strong>Android 10</strong>中推出了类似的深色模式功能，使深色模式得到了更广泛的应用和推广。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/dark_mode_example.png" alt="iOS官网的深色模式示例"></p>
<p>它不是简单的把背景变为黑色，文字变为白色，而是一整套的配色主题，这种模式相比浅色模式更加柔和，可以减少亮度对用户眼睛造成的刺激和疲劳。</p>
<p>随着越来越多的应用开始支持深色模式，作为开发也理应多了解下深色模式。</p>
<h2 id="首先，怎么打开深色模式"><a href="#首先，怎么打开深色模式" class="headerlink" title="首先，怎么打开深色模式"></a>首先，怎么打开深色模式</h2><p>在说怎么实现之前，先来说说我们要怎么打开深色模式，一般来说只需要在系统调节亮度的地方就可以调节深色模式，具体我们可以看各个系统的官方网站即可：<br>如何打开深色模式</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT210332">在 iPhone 和 iPad 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT208976">在 Mac 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.google.com/android/answer/9730472?hl=zh-Hans">在 Android 设备上更改为深色模式或颜色模式 - Android帮助</a></li>
<li><a target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9B%B4%E6%94%B9%E9%A2%9C%E8%89%B2-d26ef4d6-819a-581c-1581-493cfcc005fe">在 Windows 中更改颜色 - Microsoft 支持</a></li>
</ul>
<p>但是在开发调试调试时，不断切换深色模式可能比较麻烦，这时浏览器就提供了一种模拟系统深色模式的方法，可以让当前的Web页面临时变为深色模式，以Chrome为例：<br>浏览器模拟深色/浅色模式</p>
<ol>
<li>打开Chrome DevTools</li>
<li><code>Command</code>+<code>Shift</code>+<code>P</code></li>
<li>输入dark或者light</li>
<li>打开深色或者浅色模式<img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/open_dark_mode_in_devtool.png" alt="打开深色模式"><br><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/open_light_mode_in_devtool.png" alt="打开浅色模式"></li>
</ol>
<p>不过要注意的是，浏览器DevTools里开启深色模式，在关闭开发者工具后就会失效。</p>
<h2 id="自动适配-声明页面支持深色模式"><a href="#自动适配-声明页面支持深色模式" class="headerlink" title="自动适配 - 声明页面支持深色模式"></a>自动适配 - 声明页面支持深色模式</h2><p>其实，在支持深色模式的浏览器中，有一套默认的深色模式，只需要我们在应用中声明，即可自动适配深色模式，声明有两种方式：</p>
<h3 id="1-添加color-scheme的meta标签"><a href="#1-添加color-scheme的meta标签" class="headerlink" title="1. 添加color-scheme的meta标签"></a>1. 添加<code>color-scheme</code>的<code>meta</code>标签</h3><p>在HTML的<code>head</code>标签中增加<code>color-scheme</code>的<code>meta</code>标签，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">	and the page author prefers light.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;color-scheme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;light dark&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上述声明，告诉浏览器这个页面支持深色模式和浅色模式，并且页面更倾向于浅色模式。在声明了这个之后，当系统切换到深色模式时，浏览器将会把我们的页面自动切换到默认的深色模式配色，如下所示：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<h3 id="2-在CSS里添加color-scheme属性"><a href="#2-在CSS里添加color-scheme属性" class="headerlink" title="2. 在CSS里添加color-scheme属性"></a>2. 在CSS里添加<code>color-scheme</code>属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">  and the page author prefers light.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面在<code>:root</code>元素上添加<code>color-scheme</code>属性，值为<code>light dark</code>，可以实现和<code>meta</code>标签一样的效果，同时这个属性不只可用于<code>:root</code>级别，也可用于单个元素级别，比<code>meta</code>标签更灵活。</p>
<p>但是提供<code>color-scheme</code>CSS属性需要首先下载CSS（如果通过<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>引用）并进行解析，使用<code>meta</code>可以更快地使用所需配色方案呈现页面背景。两者各有优劣吧。</p>
<h2 id="自定义适配"><a href="#自定义适配" class="headerlink" title="自定义适配"></a>自定义适配</h2><h3 id="1-自动适配的问题"><a href="#1-自动适配的问题" class="headerlink" title="1. 自动适配的问题"></a>1. 自动适配的问题</h3><p>在上面说了我们可以通过一些标签或者CSS属性声明，来自动适配深色模式，但是从自动适配的结果来看，适配的并不理想：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<ul>
<li><p>首先是默认的黑色字体，到深色模式下变成了纯白色<code>#FFFFFF</code>，和黑色背景（虽然说不是纯黑）对比起来很扎眼，在一些设计相关的文章[<a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">1</a>][<a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">2</a>]里提到，深色模式下避免使用纯黑和纯白，否则更容易使人眼睛👁疲劳，同时容易在页面滚动时出现拖影：</p>
<p>  <img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/smearing_when_scrolling.png" alt="滚动时出现拖影，图片来源「即刻」"></p>
</li>
<li><p>自动适配只能适配没有指定颜色和背景色的内容，比如上面的1、2、3级文字还有背景，没有显式设置<code>color</code>和<code>background-color</code>。</p>
<p>  对于设置了颜色和背景色（这种现象在开发中很常见吧）的内容，就无法自动适配，比如上面的7个色块的背景色，写死了颜色，但是色块上的文字没有设置颜色。最终在深色渲染下渲染出的效果就是，色块背景色没变，但是色块上的文字变成了白色，导致一些文字很难看清。</p>
</li>
</ul>
<p>所以，最好还是自定义适配逻辑，除了解决上面的问题，还可以加一下其他的东西，比如加一些深浅色模式变化时的过渡动画等。</p>
<h3 id="2-如何自定义适配"><a href="#2-如何自定义适配" class="headerlink" title="2. 如何自定义适配"></a>2. 如何自定义适配</h3><p>自定义适配有两种方式，CSS媒体查询和通过JS监听主题模式</p>
<h4 id="1-CSS媒体查询"><a href="#1-CSS媒体查询" class="headerlink" title="1). CSS媒体查询"></a>1). CSS媒体查询</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">prefers-color-scheme - CSS：层叠样式表 | MDN</a><br>我们可以通过在CSS中设置媒体查询<code>@media (prefers-color-scheme: dark)</code>，来设置深色模式下的自定义颜色。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#404040</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#bfbfbf</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">  <span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过媒体查询设置元素在深色模式下的1、2、3级文字的颜色，在浅色模式下设置不同的颜色，在深色模式下，增加不透明度：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/left_auto_right_manul.png" alt="左边的是自动适配的浅色深色，右边是自定义适配的浅色深色"></p>
<p>对于<code>prefers-color-scheme</code>的兼容性也不必担心，主流浏览器基本都支持了：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/prefers_color_scheme.png" alt="prefers-color-scheme"></p>
<h4 id="2-JS监听主题颜色"><a href="#2-JS监听主题颜色" class="headerlink" title="2). JS监听主题颜色"></a>2). JS监听主题颜色</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia">Window.matchMedia() - Web API 接口参考 | MDN</a></p>
<p>通过CSS媒体查询适配深色模式已经很方便了，完全不需要修改JS代码逻辑，那为什么还需要JS监听主题颜色呢？</p>
<p>因为通过CSS媒体查询虽然方便，但是只能跟随系统的主题颜色变化，假设用户想要类似于下面的自定义主题颜色，不跟随系统变化，或者业务上想做一些什么高级的操作，那么CSS媒体查询就无能为力了。</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/custom_mode.gif" alt="custom_theme.gif"></p>
<p>在JS中，可以通过<code>window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).match</code>来判断当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> darkModeMediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (darkModeMediaQuery.matches) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.matches) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果使用的是React，还可以写一个自定义hooks，来监听当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EColorScheme &#123;</span><br><span class="line">  LIGHT = <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">  DARK = <span class="string">&#x27;dark&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h4><p>我写完这个hooks之后，有一次偶然用Chat GPT让它写一段监听深色模式的代码，写成hooks，最后生成的代码和这个几乎一模一样，Chat GPT还是有点东西的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ThemeType = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTheme</span>(<span class="params"></span>): <span class="title">ThemeType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState&lt;ThemeType&gt;(</span><br><span class="line">    <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleChange = <span class="function">() =&gt;</span> setTheme(mediaQuery.matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    mediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> mediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useTheme;</span><br></pre></td></tr></table></figure>

<p><code>window.matchMedia</code>的兼容性也挺好的：</p>
<p><img src="https://youfindme-1254464911.cos.ap-hongkong.myqcloud.com/blog/dark_mode/window_match_media.png" alt="window.matchMedia"></p>
<p>通过JS监听颜色主题变化之后，那可玩性就很多了，我们可以通过下面这些方式来适配深色模式：</p>
<ul>
<li><p>动态添加类名覆盖样式</p>
<p>  通过判断深色模式来添加一个深色模式的类名，覆盖浅色模式样式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=&#123;classnames(</span><br><span class="line">    style.wrapper,</span><br><span class="line">    scheme === EColorScheme.DARK &amp;&amp; style.darkModeWrapper</span><br><span class="line">  )&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &#123;/* some code here */&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>对于深色模式直接引用不同的CSS资源文件</p>
</li>
<li><p>用一些第三方的库，比如<code>postcss-darkmode</code>等</p>
</li>
</ul>
<p>回到上面话题，通过JS可以监听到系统的颜色主题，那怎么实现用户主动选择颜色主题，不随系统的改变呢？其实也很简单，可以在本地store中设置一个颜色主题的值，用户设置了就优先选用store里的，没有设置就跟随系统，以上面的hooks为例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 store 中取出用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">const</span> manualScheme = useSelector(selectManualColorScheme);</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先取用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">return</span> manualScheme || scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="React-Native中的适配"><a href="#React-Native中的适配" class="headerlink" title="React Native中的适配"></a>React Native中的适配</h2><p>上面说的都是在浏览器里对深色模式的适配，那在React Native里面要怎么适配深色模式呢？</p>
<h3 id="1-大于等于0-62的版本"><a href="#1-大于等于0-62的版本" class="headerlink" title="1. 大于等于0.62的版本"></a>1. 大于等于0.62的版本</h3><p><a target="_blank" rel="noopener" href="https://reactnative.dev/docs/appearance">Appearance · React Native</a></p>
<p>在React Native 0.62版本中，引入了<code>Appearance</code>模块，通过这个模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColorSchemeName = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Appearance &#123;</span><br><span class="line">  <span class="keyword">type</span> AppearancePreferences = &#123;</span><br><span class="line">    <span class="attr">colorScheme</span>: ColorSchemeName;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> AppearanceListener = <span class="function">(<span class="params">preferences: AppearancePreferences</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note: Although color scheme is available immediately, it may change at any</span></span><br><span class="line"><span class="comment">   * time. Any rendering logic or styles that depend on this should try to call</span></span><br><span class="line"><span class="comment">   * this function on every render, rather than caching the value (for example,</span></span><br><span class="line"><span class="comment">   * using inline styles rather than setting a value in a `StyleSheet`).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Example: `const colorScheme = Appearance.getColorScheme();`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add an event handler that is fired when appearance preferences change.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove an event handler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A new useColorScheme hook is provided as the preferred way of accessing</span></span><br><span class="line"><span class="comment"> * the user&#x27;s preferred color scheme (aka Dark Mode).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>Appearance</code>模块，可以获得当前的系统颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = Appearance.getColorScheme();</span><br><span class="line"><span class="keyword">if</span> (colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Appearance.addChangeListener(<span class="function">(<span class="params">prefer: Appearance.AppearancePreferences</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prefer.colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时也提供了一个上面我们自己实现的hooks，<code>useColorScheme</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = useColorScheme();</span><br></pre></td></tr></table></figure>

<h4 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h4><ol>
<li><p><code>Appearance</code>这个接口在Chrome调试模式下，会不生效，永远返回<code>light</code></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></p>
</li>
<li><p><code>Appearance</code>想要生效，还需要Native做一些配置</p>
<p> <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></p>
<blockquote>
<p>Also make sure you do <strong>not</strong> have UIUserInterfaceStyle set in your Info.plist. I had it set to ‘light’ so Appearance.getColorScheme() was always returning ‘light’.</p>
</blockquote>
</li>
</ol>
<h3 id="2-小于0-62的版本"><a href="#2-小于0-62的版本" class="headerlink" title="2. 小于0.62的版本"></a>2. 小于0.62的版本</h3><p>对于0.62之前的版本，由于RN没有提供官方接口，需要通过第三方的库<code>react-native-dark-mode</code>来实现：<br><a target="_blank" rel="noopener" href="https://github.com/codemotionapps/react-native-dark-mode">GitHub - codemotionapps/react-native-dark-mode: Detect dark mode in React Native</a></p>
<p>它的实现原理感兴趣的可以看下：</p>
<blockquote>
<p><strong>react-native-dark-mode 实现原理</strong>(这段实现原理其实也是问Chat GPT得到的答案😂)</p>
<p><code>react-native-dark-mode</code>库的实现原理比较简单，它主要是利用了原生平台的接口来检测当前系统是否处于深色模式。在iOS平台上，它使用了<code>UIUserInterfaceStyle</code>接口来获取当前系统的界面风格，然后判断是否为暗黑模式。在Android平台上，它使用了<code>UiModeManager</code>接口来获取当前系统的 UI 模式，然后判断是否为夜间模式。</p>
<p>具体来说，<code>react-native-dark-mode</code>在React Native项目中提供了一个名为<code>useDarkMode</code>的 React Hooks，用于获取当前系统是否处于深色模式。当使用这个Hooks时，它会首先检测当前平台是否支持暗黑模式，如果支持，就直接调用原生平台的接口获取当前系统的界面风格或UI模式，并将结果返回给调用方。如果不支持，就返回一个默认值（比如浅色模式）。</p>
<p>需要注意的是，由于<code>react-native-dark-mode</code>是一个纯JS库，它无法直接调用原生平台的接口。所以它在Native端编写了一个名为<code>DarkMode</code>的模块，在JS层通过<code>NativeModules.DarkMode</code>来调用。</p>
<ul>
<li>在iOS上，<code>DarkMode</code>模块会通过<code>RCT_EXPORT_MODULE()</code>宏将自己暴露给RN的JS层。同时，它还会使用<code>RCT_EXPORT_METHOD()</code>宏将检测系统界面风格的方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
<li>在Android上，<code>DarkMode</code>模块同样会通过<code>@ReactModule</code>注解将自己暴露给JS层。然后，它会创建一个名为<code>DarkModeModule</code>的Java类，并在该类中实现检测系统UI模式的方法。最后，它会使用<code>@ReactMethod</code>注解将该方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
</ul>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7044043307340529694#heading-8">web深色模式适配指南 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904024085364750">扫盲， H5适配暗黑主题（DarkMode）全部解法 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">紧跟潮流学设计：深色模式设计的8个小技巧-36氪</a></li>
<li><a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">即刻7.0：如何设计深色模式？（非官方） | 人人都是产品经理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xiaoxili.com/hi-face/docs/other/minapp-to-dark-mode.html">【草稿】深色模式在Web端的适配技巧，附带小程序侧的思考 · Hi头像</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cpming.top/p/detect-dark-mode-in-rn">在 React Native 中检测并适配暗黑模式 - 长跑茗</a></li>
<li><a target="_blank" rel="noopener" href="https://web.dev/color-scheme/">Improved dark mode default styling with the color-scheme CSS property and …</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冰河</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
