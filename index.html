<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"youfindme.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="冰河的个人网站">
<meta property="og:type" content="website">
<meta property="og:title" content="冰河">
<meta property="og:url" content="https://youfindme.top/index.html">
<meta property="og:site_name" content="冰河">
<meta property="og:description" content="冰河的个人网站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冰河">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://youfindme.top/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冰河</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冰河</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冰河</p>
  <div class="site-description" itemprop="description">冰河的个人网站</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2024/05/08/%E5%89%8D%E7%AB%AF%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/08/%E5%89%8D%E7%AB%AF%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">前端视角下的鸿蒙开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-08 10:23:01" itemprop="dateCreated datePublished" datetime="2024-05-08T10:23:01+08:00">2024-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-10 12:32:25" itemprop="dateModified" datetime="2024-05-10T12:32:25+08:00">2024-05-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>鸿蒙系统，一个从诞生就一直处于舆论风口浪尖上的系统，从最开始的“套壳”安卓的说法，到去年的不再兼容安卓的NEXT版本的技术预览版发布，对于鸿蒙到底是什么，以及鸿蒙的应用开发的讨论从来没停止过。</p>
<p>这次我们就从一个前端开发的角度来了解一下鸿蒙，学习一下鸿蒙应用的开发。</p>
</blockquote>
<h2 id="一、-什么是鸿蒙"><a href="#一、-什么是鸿蒙" class="headerlink" title="一、 什么是鸿蒙"></a>一、 什么是鸿蒙</h2><p>在开始之前，先问大家一个问题，大家听说过几种鸿蒙？</p>
<p>其实到目前为止，我们经常听到的鸿蒙系统，总共有三种，分别是：</p>
<p>OpenHarmony，HarmonyOS，以及HarmonyOS NEXT。</p>
<h3 id="1-OpenHarmony"><a href="#1-OpenHarmony" class="headerlink" title="1. OpenHarmony"></a>1. OpenHarmony</h3><p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/open_harmony.png" alt="OpenHarmony"></p>
<p><a target="_blank" rel="noopener" href="https://www.openharmony.cn/">OpenHarmony（开源鸿蒙系统）</a>，由开放原子开源基金会进行管理。开放原子开源基金会由华为、阿里、腾讯、百度、浪潮、招商银行、360等十家互联网企业共同发起组建。包含了“鸿蒙操作系统”的基础能力，是“纯血”鸿蒙的底座。</p>
<p>这个版本的鸿蒙是开源的，代码仓库的地址在这里：<a target="_blank" rel="noopener" href="https://gitee.com/openharmony">https://gitee.com/openharmony</a>。</p>
<p>从我个人的一些粗浅理解来看，OpenHarmony类似于Android里的AOSP，可以装到各种设备上，比如手表、电视甚至是一些嵌入式设备上，详见可见官网的一些<a target="_blank" rel="noopener" href="https://www.openharmony.cn/armList/?id=6">例子</a>。</p>
<h3 id="2-HarmonyOS"><a href="#2-HarmonyOS" class="headerlink" title="2. HarmonyOS"></a>2. HarmonyOS</h3><p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/harmony_os.png" alt="HarmonyOS"></p>
<p>基于 OpenHarmony、AOSP等开源项目，同时加入了自己的HMS（因为被美国限制后无法使用GMS）的商用版本，可以兼容安卓，也可以运行部分OpenHarmony开发的鸿蒙原生应用。</p>
<p>这个也是目前经常被吐槽是“套壳”安卓的系统，截止到目前（2024.04）已经更新到了HarmonyOS 4.2。</p>
<h3 id="3-HarmonyOS-NEXT"><a href="#3-HarmonyOS-NEXT" class="headerlink" title="3. HarmonyOS NEXT"></a>3. HarmonyOS NEXT</h3><p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/harmony_os_next.png" alt="HarmonyOS NEXT"></p>
<p>2023年秋季发布的技术预览版，在当前HarmonyOS的基础上去除了AOSP甚至是JVM，不再兼容安卓，只能运行鸿蒙原生应用，同时对OpenHarmony的能里进行了大量的更新，增加和修改了很多API。</p>
<p>这个也就是所谓的“纯血”鸿蒙系统，可惜的是这个目前我们用不到，需要以公司名义找华为合作开权限，或者个人开发者使用一台Mate60 Pro做专门的开发机。并且目前由于有保密协议，网上也没有太多关于最新API的消息。</p>
<blockquote>
<p>NEXT版本文档：<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-releases/releasenotes-overview-0000001602419138">https://developer.huawei.com/consumer/cn/doc/harmonyos-releases/releasenotes-overview-0000001602419138</a></p>
</blockquote>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/can_not_access_next_doc.png" alt="无法直接访问的NEXT版本的开发文档"></p>
<p>据说目前HarmonyOS NEXT使用的API版本已经到了API12，目前官网可以访问的最新文档还是API9，所以接下来的内容也都是基于API9的版本来的。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>所以一个粗略的视角来看，OpenHarmony、HarmonyOS以及HarmonyOS NEXT这三者之间的关系是这样的：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/relationship.png" alt="三者之间的关系"></p>
<h2 id="二、-初识鸿蒙开发"><a href="#二、-初识鸿蒙开发" class="headerlink" title="二、 初识鸿蒙开发"></a>二、 初识鸿蒙开发</h2><p>在大概知道了什么是鸿蒙之后，我们先来简单看一下鸿蒙开发的套件。下图是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">官网</a>所描述的一些开发套件，包括了设计、开发、测试、上架所涉及到的技术和产品。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/development_kit.png" alt="鸿蒙开发套件"></p>
<p>我们这篇文章里主要讨论右下角的三个：<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkts/">ArkTS</a>、<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkui/">ArkUI</a>、<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">ArkCompiler</a>。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/arkts_arkui.png" alt="ArkTS&amp;ArkUI"></p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/arkcompiler.png" alt="ArkCompiler"></p>
<h2 id="三、-关于ArkTS的一些疑惑"><a href="#三、-关于ArkTS的一些疑惑" class="headerlink" title="三、 关于ArkTS的一些疑惑"></a>三、 关于ArkTS的一些疑惑</h2><p>作为一个前端开发，最常用的编程语言就是JavaScript或者TypeScript，那么在看到鸿蒙应用开发用到的编程语言是ArkTS之后，我脑子里最先蹦出来的就是下面这几个问题：</p>
<p><strong>1. ArkTS语言的运行时是啥？</strong><br>   既然编程语言是TS（TS的拓展，ArkTS），那么它的运行时是什么呢？是V8？JSC？Hermes？还是其他什么呢？<br><strong>2. ArkTS还是单线程语言吗？</strong><br>   ArkTS还是和JS一样，是单线程语言吗？<br><strong>3. 基于TS拓展了什么？</strong><br>   TS是JS的超集，对JS进行了拓展，增加了开发时的类型支持。而ArkTS对对TS又进行了拓展，是TS的超集，那它基于TS拓展了什么内容呢？</p>
<p>下面我们一个一个来看。</p>
<h3 id="1-Question1-ArkTS语言的运行时"><a href="#1-Question1-ArkTS语言的运行时" class="headerlink" title="1. Question1 - ArkTS语言的运行时"></a>1. Question1 - ArkTS语言的运行时</h3><p>先说结论，ArkTS的运行时不是V8，不是JSC、Hermes，不是目前任何一种JS引擎。ArkTS的运行时是一个自研的运行时，叫做方舟语言运行时（简称方舟运行时）。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/runtime.png" alt="方舟运行时"></p>
<p>而这个运行时，执行的也不是JS/TS/ArkTS代码，而是执行的<strong>字节码和机器码</strong>。<br>这是因为方舟运行时是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">ArkCompiler（方舟编译器）</a>的一部分，对于JS/TS/ArkTS的编译在运行前就进行了（和Hermes有点像，下面会讲到）。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/dev_framework.png" alt="方舟开发框架示意图"></p>
<p>我们来简单了解一下ArkCompiler，从官网的描述可以看到，ArkCompiler关注的重点主要有三个方面：</p>
<ul>
<li>AOT 编译模式</li>
<li>LiteActor 轻量化并发</li>
<li>源码安全</li>
</ul>
<h4 id="AOT-编译模式"><a href="#AOT-编译模式" class="headerlink" title="AOT 编译模式"></a>AOT 编译模式</h4><p>首先是编译模式，我们知道，目前编程语言大多以下几方式运行：</p>
<ul>
<li>机器码AOT编译<br>在程序运行之前进行AST生成和代码编译，编译为机器码，在运行无需编译，直接运行，比如C语言。</li>
<li>中间产物AOT编译<br>在程序运行前进行AST生成并进行编译，但不是编译为机器码，而是编译为中间产物，之后在运行时将字节码解释为机器码再执行。比如Hermes或Java编译为字节码，之后运行时由Hermes引擎或JVM解释执行字节码。</li>
<li>完全的解释执行<br>在程序运行前不进行任何编译，在运行时动态地根据源码生成AST，再编译为字节码，最后解释执行字节码。比如没有开启JIT的V8引擎执行JS代码时的流程。</li>
<li>混合的JIT编译<br>在通过解释执行字节码时（运行时动态生成或者AOT编译生成），对多次执行的热点代码进行进一步的优化编译，生成机器码，后续执行到这部分逻辑时，直接执行优化后的机器码。比如<a target="_blank" rel="noopener" href="https://juejin.cn/post/7179130165262286885">开启JIT的V8引擎</a>运行JS或者<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">支持JIT的JVM</a>运行class文件。</li>
</ul>
<blockquote>
<p>当然，以上仅考虑生产环境下的运行方式，不考虑部分语言在生产和开发阶段不同的运行方式。比如Dart和Swift，一般是开发阶段通过JIT实时编译快速启动，生产环境下为了性能通过AOT编译。</p>
</blockquote>
<p>在V8 JIT出现之前，所有的JS虚拟机所采用的都是采用的<strong>完全解释执行</strong>的方式，在运行时把源码生成AST语法树，之后生成字节码，然后将字节码解释为机器码执行，这是JS执行速度过慢的主要原因之一。</p>
<p>而这么做有以下两个方面的原因：</p>
<ul>
<li>JS是动态语言，变量类型在运行时可能改变</li>
<li>JS主要用于Web应用，Web应用如果提前编译为字节码将导致体积增大很多，对网络资源的消耗会更大</li>
</ul>
<p>我们一个一个来说。</p>
<h5 id="a-JS变量类型在运行时可能改变"><a href="#a-JS变量类型在运行时可能改变" class="headerlink" title="a. JS变量类型在运行时可能改变"></a>a. JS变量类型在运行时可能改变</h5><p>首先我们来看一张图，这张图描述了现在V8引擎的工作流程，目前Chrome和Node里的JS引擎都是这个：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/v8_work_flow.png" alt="V8现有工作流程"></p>
<p>从上面可以看到，V8在拿到JS源码后，会先解析成AST，之后经过Ignition解释器把语法树编译成字节码，然后再解释字节码执行。</p>
<p>于此同时还会收集热点代码，比如代码一共运行了多少次、如何运行的等信息，也就是上面的Feedback的流程。</p>
<p>如果发现一段代码会被重复执行，则监视器会将此段代码标记为热点代码，交给V8的Turbofan编译器对这段字节码进行编译，编译为对应平台（Intel、ARM、MIPS等）的二进制机器码，并执行机器码，也就是图里的Optimize流程。</p>
<p>等后面V8再次执行这段代码，则会跳过解释器，直接运行优化后的机器码，从而提升这段代码的运行效率。</p>
<p>但是我们发现，图里面除了Optimize外，还有一个Deoptimize，<strong>反优化</strong>，也就是说被优化成机器码的代码逻辑，可能还会被反优化回字节码，这是为什么呢？</p>
<p>其实原因就是上面提到的“JS变量类型在运行时可能改变”，我们来看一个例子：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/type_change_in_js.png" alt="JS变量类型在运行时可能改变"></p>
<p>比如一个<code>add</code>函数，因为JS没有类型信息，底层编译成字节码后伪代码逻辑大概如这张图所示。会判断<code>x</code>和<code>y</code>的各种类型，逻辑比较复杂。</p>
<p>在Ignition解释器执行<code>add(1, 2)</code>时，已经知道<code>add</code>函数的两个参数都是整数，那么TurboFan在进一步编译字节码时，就可以假定<code>add</code>函数的参数是整数，这样可以极大地简化生成的汇编代码，不再判断各种类型，伪代码如第三张图里所示。</p>
<p>接下来的<code>add(3, 4)</code>与<code>add(5, 6)</code>由于入参也是整数，可以直接执行之前编译的机器码，但是<code>add(&quot;7&quot;, &quot;8&quot;)</code>时，发现并不是整数，这时候就只能将这段逻辑Deoptimize为字节码，然后解释执行字节码。</p>
<p>这就是所谓的Deoptimize，<strong>反优化</strong>。可以看出，如果我们的JS代码中变量的类型变来变去，是会给V8引擎增加不少麻烦，为了提高性能，我们可以尽量不要去改变变量的类型。</p>
<p>虽然说使用TS可以部分缓解这个问题，但是TS只能约束<strong>开发时</strong>的类型，运行的时候TS的类型信息是会被丢弃的，也无法约束，V8还是要做上面的一些假定类型的优化，无法一开始就编译为机器码。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/type_info_discarded.png" alt="TS类型信息运行时被丢弃"></p>
<p>可以说TS的类型信息被浪费了，没有给运行时代码特别大的好处。</p>
<h5 id="b-JS编译为字节码将导致体积增大"><a href="#b-JS编译为字节码将导致体积增大" class="headerlink" title="b. JS编译为字节码将导致体积增大"></a>b. JS编译为字节码将导致体积增大</h5><p>上面说到JS主要用于Web应用，Web应用如果提前编译为字节码将导致体积增大很多，对网络资源的消耗会更大。那么对于非Web应用，其实是可以做到提前编译为字节码的，比如Hermes引擎。</p>
<p>Hermes作为React Native的运行时，是作为App预装到用户的设备上，除了热更新这种场景外，绝大部分情况下是不需要打开App时动态下载代码资源的，所以体积增大的问题影响不是很大，但是预编译带来的运行时效率提升的好处却比较明显。</p>
<p>所以相对于V8，Hermes<a target="_blank" rel="noopener" href="https://supercodepower.com/mobile-javascript-engines#3hermes">去掉了JIT，支持了生成字节码</a>，在构建App的时候，就把JS代码进行了预编译，预编译为了Hermes运行时可以直接处理的字节码，省去了在运行阶段解析AST语法树、编译为字节码的工作。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/optimize_in_hermes.png" alt="Hermes对JS编译和执行流程的改进"></p>
<blockquote>
<p>一句题外话，这里去掉JIT除了JIT会导致JS引擎启动时间变长、内存占用增大外，还有一部分可能的原因是iOS为了安全考虑，不允许除了Safari和WebView之外的第三方应用里直接使用JSC的JIT能力，也不允许第三方JS运行时支持JIT（相关问题）。</p>
<p>甚至V8专门出了一个去掉JIT的JIT-less V8版本来在iOS上集成，Hermes似乎也不太可能完全没考虑到这一点。</p>
</blockquote>
<h5 id="c-取长补短"><a href="#c-取长补短" class="headerlink" title="c. 取长补短"></a>c. 取长补短</h5><p>在讨论了V8的JIT和Hermes的预编译之后，我们再来看看ArkCompiler，截取一段<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">官方博客里的描述</a>：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/blog_desc_of_arkcompiler.png" alt="博客描述"></p>
<p>还记得上面说的“TS的类型信息被浪费了”吗？TS的类型信息只在开发时有用，在编译阶段就被丢弃了，而ArkCompiler就是利用了这一点，直接在App构建阶段，利用TS的类型信息直接预编译为字节码以及优化机器码。</p>
<p>即在ArkCompiler中，不存在TS-&gt;JS的这一步转译，而是直接从TS编译为了字节码和优化机器码。同时由于鸿蒙应用也是一个App而不是Web应用，所以ArkCompiler和Hermes一样，也是在构建App时就进行了预编译，而不是在运行阶段做这个事情。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/optimize_in_arkcompiler.png" alt="ArkCompiler对JS/TS编译和执行流程的改进"></p>
<p>简单总结下来，ArkCompiler像Hermes一样支持生成字节码，同时又将V8引擎JIT生成机器码的工作也提前在预编译阶段做了。是比Hermes只生成字节码的AOT更进一步的AOT（同时生成字节码和部分优化后的机器码）。</p>
<h4 id="LiteActor轻量化并发"><a href="#LiteActor轻量化并发" class="headerlink" title="LiteActor轻量化并发"></a>LiteActor轻量化并发</h4><p>到这里其实已经可以回答上面讲到的第二个问题了，ArkTS还是单线程语言吗？</p>
<p>答案是：是的，还是单线程语言。但是ArkTS里通过<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/taskpool-vs-worker-0000001632849934-V2">Worker和TaskTool</a>这两种方式支持并发。</p>
<p>同时ArkCompiler对现有的Worker进行了一些优化，直接看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">官网博客</a>：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/lite_actor.png" alt="LiteActor轻量化并发"></p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/blog_desc_of_lite_actor.png" alt="LiteActor轻量化并发博客描述"></p>
<p>这里的Actor是什么呢？Actor是一种并发编程里的线程模型。</p>
<p>线程模型比较常见的就是共享内存模型，多个线程之间共享内存，比如Java里多个线程共享内存数据，需要通过<code>synchronized</code>同步锁之类的来防止数据一致性的问题。</p>
<p>Actor模型是另一种线程模型，“Actor”是处理并发计算的基本单位，每个Actor都有自己的状态，并且可以接收和发送消息。当一个Actor接收到消息时，它可以改变自己的状态，发送消息给其他Actor，或者创建新的Actor。</p>
<p>这种模型可以帮助开发者更好地管理复杂的状态和并发问题，因为每个Actor都是独立的，它们之间不会共享状态，这可以避免很多并发问题。同时，Actor模型也使得代码更易于理解和维护，因为每个Actor都是独立的，它们的行为可以被清晰地定义和隔离。</p>
<p>到这里大家应该已经比较明白了，前端里的Web Worker就是这种线程模型的一种体现，通过Worker来开启不同的线程。</p>
<h4 id="源码安全"><a href="#源码安全" class="headerlink" title="源码安全"></a>源码安全</h4><p>按照<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkcompiler/">官网</a>的说法，ArkCompiler会把ArkTS编译为字节码，并且ArkCompiler使用多种混淆技术提供更高强度的混淆与保护，使得HarmonyOS应用包中装载的是多重混淆后的字节码，有效提高了应用代码安全的强度。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/source_code_security.gif" alt="源码安全"></p>
<h3 id="2-Question2-ArkTS还是单线程语言吗"><a href="#2-Question2-ArkTS还是单线程语言吗" class="headerlink" title="2. Question2 - ArkTS还是单线程语言吗"></a>2. Question2 - ArkTS还是单线程语言吗</h3><p>这个刚刚已经回答了，还是单线程语言，借用官网的描述：</p>
<blockquote>
<p>HarmonyOS应用中每个进程都会有一个主线程，主线程有如下职责：</p>
<ol>
<li>执行UI绘制；</li>
<li>管理主线程的ArkTS引擎实例，使多个UIAbility组件能够运行在其之上；</li>
<li>管理其他线程（例如Worker线程）的ArkTS引擎实例，例如启动和终止其他线程；</li>
<li>分发交互事件；</li>
<li>处理应用代码的回调，包括事件处理和生命周期管理；</li>
<li>接收Worker线程发送的消息；</li>
</ol>
<p>除主线程外，还有一类与主线程并行的独立线程Worker，主要用于执行耗时操作，但不可以直接操作UI。Worker线程在主线程中创建，与主线程相互独立。最多可以创建8个Worker。</p>
</blockquote>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/threading_model.png" alt="ArkTS线程模型"></p>
<h3 id="3-Question3-基于TS拓展了什么"><a href="#3-Question3-基于TS拓展了什么" class="headerlink" title="3. Question3 - 基于TS拓展了什么"></a>3. Question3 - 基于TS拓展了什么</h3><p>当前，ArkTS在TS的基础上主要扩展了如下能力：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-basic-syntax-overview-0000001531611153-V2">基本语法</a>：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-management-overview-0000001524537145-V2">状态管理</a>：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。</li>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-rendering-control-overview-0000001543911149-V2">渲染控制</a>：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li>
</ul>
<p>而上面这些，也就是我们接下来要介绍的ArkTS+ArkUI的语法。</p>
<h2 id="四、-ArkTS-amp-ArkUI"><a href="#四、-ArkTS-amp-ArkUI" class="headerlink" title="四、 ArkTS &amp; ArkUI"></a>四、 ArkTS &amp; ArkUI</h2><p>首先，在聊ArkUI之前，还有一个问题大家可能比较感兴趣：ArkUI是怎么渲染我们写的UI呢？</p>
<p>答案是<strong>自绘</strong>，类似于Flutter，使用自己的渲染引擎（应该是发展于Skia），而不是像RN那样将UI转为不同平台上的底层UI。</p>
<p>不管是从官网的描述[<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/arkui/">1</a>]、[<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-ui-development-overview-0000001438467628-V2">2</a>]来看，还是社区里的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7280006531922673719#heading-0">讨论</a>来看，ArkUI的渲染无疑是自绘制的，并且ArkUI和Flutter之间的联系很密切：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/discuss_of_arkui.png" alt="社区里的一些讨论"></p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><p>从前端的角度来看，ArkTS和ArkUI的定位其实就是类似于前端中TS+React+配套状态管理工具（如Redux），可以用TS写声明式UI（有点像写jsx），下面是基本语法：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/basic_grammar.png" alt="基本语法"></p>
<ul>
<li>装饰器<br>用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2#section1430055924816">@Component</a>表示自定义组件，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2#section1430055924816">@Entry</a>表示该自定义组件为入口组件，<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-0000001474017162-V2">@State</a>表示组件中的状态变量，状态变量变化会触发UI刷新</li>
<li>自定义组件<br>可复用的UI单元，可组合其他组件，如上述被@Component装饰的<code>struct Hello</code></li>
<li>UI描述<br>以声明式的方式来描述UI的结构，例如<code>build()</code>方法中的代码块</li>
<li>系统组件<br>ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的<code>Column</code>、<code>Text</code>、<code>Divider</code>、<code>Button</code></li>
<li>事件方法<br>组件可以通过链式调用设置多个事件的响应逻辑，如跟随在<code>Button</code>后面的<code>onClick()</code></li>
<li>属性方法<br>组件可以通过链式调用配置多项属性，如<code>fontSize()</code>、<code>width()</code>、<code>height()</code>、<code>backgroundColor()</code>等</li>
</ul>
<h3 id="2-数据驱动UI"><a href="#2-数据驱动UI" class="headerlink" title="2. 数据驱动UI"></a>2. 数据驱动UI</h3><p>作为一个声明式的UI框架，ArkUI和其他众多UI框架（比如React、Vue）一样，都是通过数据来驱动UI变化的，即<code>UI = f(State)</code>。我们这里引用一下官网的描述：</p>
<blockquote>
<p>在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。</p>
<p>自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。</p>
</blockquote>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/state_and_ui.png" alt="State和UI"></p>
<blockquote>
<p>View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。<br>State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。</p>
</blockquote>
<p>在ArkUI中，提供了大量的状态管理相关的装饰器，比如<code>@State</code>、<code>@Prop</code>、<code>@Link</code>等。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/overview_of_state.png" alt="ArkTS &amp; ArkUI的状态管理总览"></p>
<p>更多细节详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-management-0000001524177629-V2">状态管理</a>。</p>
<h3 id="3-渲染控制"><a href="#3-渲染控制" class="headerlink" title="3. 渲染控制"></a>3. 渲染控制</h3><p>在ArkUI中，可以像React那样，通过<code>if else</code>，<code>for each</code>等进行跳转渲染、列表渲染等，更多细节详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-rendering-control-0000001504769325-V2">渲染控制</a>。</p>
<blockquote>
<p>ArkUI通过<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-create-custom-components-0000001473537046-V2">自定义组件</a>的<code>build()</code>函数和<code>@builder</code><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-builder-0000001524176981-V2">装饰器</a>中的声明式UI描述语句构建相应的UI。在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助UI的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句以及针对大数据量场景的数据懒加载语句。</p>
</blockquote>
<h3 id="4-更多语法"><a href="#4-更多语法" class="headerlink" title="4. 更多语法"></a>4. 更多语法</h3><p>语法其实不是我们这篇文章的重点，上面是一些大概的介绍，更多语法可以详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-basic-syntax-0000001504650057-V2">官网</a>，或者我的另外一篇专门讲解语法的笔记《前端视角下的ArkTS语法》(先留个占位符，有时间了补充一下)。</p>
<h3 id="5-ArkTS-amp-ArkUI小结"><a href="#5-ArkTS-amp-ArkUI小结" class="headerlink" title="5. ArkTS &amp; ArkUI小结"></a>5. ArkTS &amp; ArkUI小结</h3><p>从前面的内容其实可以看到，ArkUI和RN相似点还挺多的：</p>
<ol>
<li>都是使用JS/TS作为语言（ArkTS）</li>
<li>都有自己的JS引擎/运行时（ArkCompiler，方舟运行时）</li>
<li>引擎还都支持直接AOT编译成字节码</li>
</ol>
<p>不同的是RN是将JS声明的UI，转换成iOS、Android原生的组件来渲染，而ArkUI则是采用自绘制的渲染引擎来自绘UI。</p>
<p>从这点来看，鸿蒙更像是Flutter，只不过把开发语言从Dart换成了JS/TS（ArkTS），和Flutter同样是自绘制的渲染引擎。</p>
<p>社区里其实也有类似的思考：其它方向的探索：<a target="_blank" rel="noopener" href="https://supercodepower.com/cross-platform-tech#6%E5%85%B6%E5%AE%83%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A2%E7%B4%A2js-engine--flutter-rnderpipeline">JS Engine + Flutter RenderPipeLine</a>。而ArkUI则是对这种思路的实现。</p>
<p>感觉这也可以从侧面解释为什么ArkUI的语法和Flutter比较像，应该参考了不少Flutter的实现（比如渲染引擎）。</p>
<p>而华为宣称鸿蒙可以反向兼容Flutter甚至是RN也就没有那么难以理解了，毕竟ArkUI里Flutter和RN的影子确实不少。</p>
<p>另外,除了ArkUI以外，华为还提供了一个跨平台的开发框架<a target="_blank" rel="noopener" href="https://gitee.com/arkui-x">ArkUI-X</a>，可以像Flutter那样，跨HarmonyOS、Android、iOS三个平台。</p>
<p>这么看来，ArkTS&amp;ArkUI从开发语言、声明式UI的语法、设计思想来看，不管是前端、iOS、安卓、或者Flutter、RN，鸿蒙应用开发都是比较入门友好的。</p>
<h2 id="五、-其他"><a href="#五、-其他" class="headerlink" title="五、 其他"></a>五、 其他</h2><h3 id="1-包管理工具"><a href="#1-包管理工具" class="headerlink" title="1. 包管理工具"></a>1. 包管理工具</h3><p>HarmonyOS开发中，使用的包管理工具是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ide-command-line-ohpm-0000001490235312-V2">ohpm</a>，目前看来像是一个借鉴<a target="_blank" rel="noopener" href="https://pnpm.io/">pnpm</a>的三方包管理工具，详见<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ide-command-line-ohpm-0000001490235312-V2">官方文档</a>。</p>
<p>另外，鸿蒙也提供了第三方包发布的仓库：<a target="_blank" rel="noopener" href="https://ohpm.openharmony.cn/">https://ohpm.openharmony.cn</a>。</p>
<h3 id="2-应用程序结构"><a href="#2-应用程序结构" class="headerlink" title="2. 应用程序结构"></a>2. 应用程序结构</h3><p>在鸿蒙系统中，一个应用包含一个或者多个Module，每一个Module都可以独立进行编译和运行。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/architecture_of_app.png" alt="应用程序结构"></p>
<p>发布时，每个Module编译为一个<code>.hap</code>后缀的文件，即HAP。每个HarmonyOS应用可以包含多个<code>.hap</code>文件。</p>
<p>在应用上架到应用市场时，需要把应用包含的所有<code>.hap</code>文件打包为一个<code>.app</code>后缀的文件用于上架。</p>
<p>但是<code>.app</code>包不能直接安装到设备上，只是上架应用市场的单元，安装到设备上的是<code>.hap</code>。</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/architecture_of_build.png" alt="打包结构"></p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/architecture_of_dev_build.png" alt="开发态和打包后视图"></p>
<p>鸿蒙应用的整体开发调试与发布部署流程大概是这样的：</p>
<p><img src="https://static.youfindme.cn/blog//harmony_os_getting_started/dev-debug-release-deploy.png" alt="开发-调试-发布-部署"></p>
<p>HAP可分为Entry和Feature两种类型：</p>
<ul>
<li><strong>Entry类型的HAP</strong>：是应用的主模块<br>在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。</li>
<li><strong>Feature类型的HAP</strong>：是应用的动态特性模块<br>一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含；Feature类型的HAP通常用于实现应用的特性功能，可按需下载安装</li>
</ul>
<p>而设计成多hap，主要是有3个目标：</p>
<ol>
<li>为了解耦应用的各个模块，比如一个支付类型的App，Entry类型的hap可以是首页主界面，上面的扫一扫、消息、理财等可以的feature类型的HAP</li>
<li>方便开发者将多HAP合理地组合并部署到不同的设备上，比如有三个HAP，Entry、Feature1和Feature2，其中A类型的设备只能部署Entry和Feature1。B类型的设备只能部署Entry和Feature2</li>
<li>方便应用资源共享，减少程序包大小。多个HAP都需要用到的资源文件可以放到单独的HAP中</li>
</ol>
<blockquote>
<p>多说一句：从这些描述来看，给我的感觉是每个.hap有点类似于前端项目中Mono-repo仓库中的一个package，各个package之间有一定的依赖，同时每个package可以独立发布。</p>
</blockquote>
<p>另外，HarmonyOS也支持类似RN热更新的功能，叫做<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/quickfix-principles-0000001493743976-V2">快速修复（quick fix）</a>。</p>
<h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>现在再回到最开始那个问题：什么是鸿蒙？从前端视角来看，它是这样一个系统：</p>
<ul>
<li>ArkTS作为应用开发语言</li>
<li>类Flutter、Compose、Swift的声明式UI语法</li>
<li>和React有些相似的数组驱动UI的设计思想</li>
<li>ArkCompiler进行字节码和机器码的AOT编译 + 方舟运行时</li>
<li>类似Flutter Skia渲染引擎的自绘制渲染引擎</li>
<li>通过提供一系列ohos.xxx的系统内置包来提供TS访问系统底层的能力（比如网络、媒体、文件、USB等）</li>
</ul>
<p>所以关于HarmonyOS是不是安卓套壳，个人感觉其实已经比较明了了：以前应该是，但快要发布的HarmonyOS NEXT大概率不再是了。</p>
<h3 id="其他一些讨论"><a href="#其他一些讨论" class="headerlink" title="其他一些讨论"></a>其他一些讨论</h3><p>其实在华为宣布了HarmonyOS NEXT不再兼容安卓后，安卓套壳的声音越来越少了，但现在网上另外一种声音越来越多了：</p>
<blockquote>
<ol>
<li>HarmonyOS NEXT是一个大号的小程序底座，上面的应用都是网页应用，应用可以直接右键查看源码，没有安全性可言</li>
<li>HarmonyOS NEXT上的微信小程序就是在小程序里运行小程序</li>
<li>因为使用的是ArkTS开发，所以的HarmonyOS NEXT上的应用性能必然很差</li>
</ol>
</blockquote>
<p>这种说法往往来自于只知道鸿蒙系统应用开发语言是TS，但是没有去进一步了解的人，而且这种说法还有很多人信。其实只要稍微看下文档，就知道这种说法是<strong>完全错误的</strong>。</p>
<p>首先它的View层不是DOM，而是类似Flutter的自绘制的渲染引擎，不能因为使用了TS就说是网页，就像可以说React Web是网页应用，但不能说React Native是网页应用，同样也不是说Flutter是网页应用。</p>
<p>另外开发语言本身并不能决定最终运行性能，还是要看编译器和运行时的优化。同样是JS，从完全的解释执行（JS-&gt;AST-&gt;字节码-&gt;执行），到开启JIT的V8，性能都会有质的飞跃。从一些<a target="_blank" rel="noopener" href="https://github.com/GoodManWEN/Programming-Language-Benchmarks-Visualization">编程语言性能测试</a>中可以看到，开启JIT的NodeJs的性能，甚至和Flutter所使用的Dart差不多。</p>
<p>而ArkCompiler是结合了Hermes和V8 JIT的特点，AOT编译为字节码和机器码，所以理论上讲性能应该相当不错。</p>
<p>（当然我也没有实机可以测试，只能根据文档来分析）。</p>
<p>上面这种HarmonyOS NEXT是网页应用的说法还有可能是由于，最早鸿蒙应用支持使用HTML、CSS、JS三件套进行<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ui-js-overview-0000001428061548-V2">兼容Web的开发</a>，导致了刻板印象。这种开发方式使用的是<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-with-js-fa-0000001428061452-V2">FA模型</a>，而目前这种方式已经<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/application-model-description-0000001493584092-V2">不是鸿蒙主推的开发方式了</a>。</p>
<p>到这里这篇文章就结束了，整体上是站在一个前端开发的视角下来认识和了解鸿蒙开发的，希望能帮助一些像我一样对鸿蒙开发感兴趣的前端开发入门。大家如果感兴趣可以到<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">鸿蒙官网</a>查看更多的了解。</p>
<p>如果感觉对你有帮助，可以点个赞哦~</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/">华为开发者联盟-HarmonyOS开发者官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.openharmony.cn/">OpenHarmony</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/arkui-x">ArkUI-X</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8UHznZenc7A_UICta2bETg">不同设备如何统一语言编程平台高效开发？本文为你揭秘</a></li>
<li><a target="_blank" rel="noopener" href="https://supercodepower.com/mobile-javascript-engines">🤔 移动端 JS 引擎哪家强？美国硅谷找…… | 卤代烃实验室</a></li>
<li><a target="_blank" rel="noopener" href="https://supercodepower.com/cross-platform-tech">🎯【深入解析】跨端框架的核心技术到底是什么？ | 卤代烃实验室</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21320960/answer/18628710">苹果为何又如何在 iOS 上禁止 Safari 之外的应用使用 Nitro JIT 编译？ - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7179130165262286885">一次看懂V8引擎与JIT原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7280006531922673719">Harmony 开始支持 Flutter ，聊聊 Harmony 和 Flutter 之间的因果</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2024/01/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84void%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84void%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">你不知道的 void 运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-01-27 18:26:00 / 修改时间：18:58:02" itemprop="dateCreated datePublished" datetime="2024-01-27T18:26:00+08:00">2024-01-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>void</code>运算符，一个在 JavaScript 中很常见，但你却不一定很熟悉的运算符。它出现在各个地方，你可能在下面这些地方见到过：</p>
<ul>
<li><p>HTML的<code>a</code>标签里</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span>&gt;</span>This is a link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JS表达式（尤其是 tsc 或者 babel 编译后的代码里）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = foo === <span class="literal">null</span> || foo === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : foo.bar;</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> <span class="keyword">void</span> doSomething();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>那么<code>void</code>运算符的作用究竟是什么呢？</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之所以突然聊这个，是因为在某次代码CR里讨论到了TypeScript的<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">可选链（Optional Chaining）</a>语法（当然从<a target="_blank" rel="noopener" href="https://262.ecma-international.org/11.0/#sec-optional-chains">ES2020</a>开始，JS中也支持了这个语法）。</p>
<p>可选链大家应该都不陌生，在获取深层次对象属性的时候极其方便，比如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = foo?.bar;</span><br></pre></td></tr></table></figure>

<p>上面这行代码作用类似于下面这种写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = foo === <span class="literal">null</span> || foo === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : foo.bar;</span><br><span class="line"><span class="keyword">const</span> result = temp;</span><br></pre></td></tr></table></figure>

<p>虽然是这样说，但是作为一个凡事都要试一试的人来说，还是自己编译一下看看比较好，在用 tsc 试了一下之后，发现编译后的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = foo === <span class="literal">null</span> || foo === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : foo.bar;</span><br></pre></td></tr></table></figure>

<p>好像和上面的有点不一样，这里的代码里所有的<code>undefined</code>全部换成了<code>void 0</code>，这是为什么呢？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实从MDN上，我们很容易知道<code>void</code>运算符的作用：</p>
<blockquote>
<p><code>void</code>运算符对给定的表达式进行求值，然后返回<code>undefined</code>。</p>
</blockquote>
<p>即不论<code>void</code>运算符后面跟的是什么，这个运算符总是返回<code>undefined</code>。比如下面这些写法都会返回<code>undefine</code>：</p>
<ul>
<li><code>void 0</code></li>
<li><code>void(0)</code></li>
<li><code>void &#39;hello&#39;</code></li>
<li><code>void (1+2)</code></li>
<li><code>void(console.log(&#39;Hello world&#39;));</code></li>
</ul>
<p>也就是说上面 tsc 编辑后的语法中<code>void 0</code>和<code>undefined</code>是等价的。</p>
<p>而之所以不直接使用<code>undefined</code>，是因为在早期的 JavaScript 版本中，<code>undefined</code>是可以被重新赋值的，而使用<code>void 0</code>，则可以获取到**<code>undefined</code>的原始值**。</p>
<p>我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="keyword">void</span> <span class="number">0</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码运行后，第一个<code>console</code>将会打印<code>false</code>，第二个将会打印<code>true</code>，这就是因为<code>undefined</code>被重新赋值为了<code>1</code>，不再是原始的值，而为了保证编译后代码的正确性和稳定性，一般都会使用<code>void 0</code>来获取原始的<code>undefined</code>值。</p>
<p>到这里我们就搞明白刚刚那个问题了，那除了这个场景，<code>void</code>运算符还有哪些作用呢？</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="1-获取undefined的原始值"><a href="#1-获取undefined的原始值" class="headerlink" title="1. 获取undefined的原始值"></a>1. 获取undefined的原始值</h3><p>这个上面的例子中已经说到了，这里就不再赘述。</p>
<h3 id="2-用在-JavaScript-URI-中，以及阻止a标签的默认行为"><a href="#2-用在-JavaScript-URI-中，以及阻止a标签的默认行为" class="headerlink" title="2. 用在 JavaScript URI 中，以及阻止a标签的默认行为"></a>2. 用在 JavaScript URI 中，以及阻止<code>a</code>标签的默认行为</h3><p>当用户点击一个以<code>javascript:</code>开头的 URI 时，它会执行 URI 中的代码，然后<strong>用返回的值替换页面内容</strong>，除非返回的值是<code>undefined</code>。这个时候<code>void</code>运算符就派上了用场，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:&#x27;zzzzz&#x27;&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子里，点击<code>a</code>标签后，整个页面的内容，包括下面的<code>12345</code>，都会被替换为<code>zzzzz</code>。</p>
<p>如果使用了<code>void</code>，则不会这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(&#x27;zzzzz&#x27;);&quot;</span>&gt;</span>这个链接点击之后不会做任何事情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(document.body.style.backgroundColor=&#x27;green&#x27;);&quot;</span>&gt;</span></span><br><span class="line">  点击这个链接会让页面背景变成绿色。</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，很多地方的<code>a</code>标签都会添加一个简单的<code>href=&quot;javascript:void(0)</code>来阻止<code>a</code>标签的默认行为，达到类似<code>preventDefault</code>的效果。</p>
<p>可能有小伙伴有疑问，直接不写<code>href</code>属性或者<code>href</code>设为空字符串不就行了吗？其实还是有差别的,可以看下面的示例，从上到下三个<code>a</code>标签分别为：</p>
<ol>
<li>没有<code>href</code>属性</li>
<li><code>href</code>值为空</li>
<li><code>href</code>值为<code>javascript: void(0);</code></li>
</ol>
<p><img src="https://static.youfindme.cn/blog/void_operator/different_a_link.png" alt="image.png"></p>
<p>可以看到还是有一些区别的。</p>
<p>不过，目前除了<code>javascript: void(0);</code>比较常见之外，其他利用<code>javascript:</code>伪协议来执行 JavaScript 代码已经十分少见了，同时这种行为也是不太推荐的做法，推荐的做法是给对应的元素绑定事件处理器。</p>
<p><em><strong>PS：</strong></em></p>
<p>这里有一些历史背景在里面，在早期，各个浏览器有着不同的 DOM2 事件处理接口，对于阻止默认行为也有不同的实现，比如</p>
<ul>
<li><p>在支持W3C标准的浏览器中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault(); <span class="comment">// 阻止默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>而在IE中则是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="literal">false</span>; <span class="comment">// 阻止默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以很多开发者为了省事，不想写两套兼容代码，就直接省事在<code>a</code>标签的<code>href</code>属性中添加<code>javascript: void(0);</code>来阻止默认行为了，之后点击行为的自定义处理再通过 DOM0 支持的事件处理器来处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linkEle.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法流传很广，所以即便是在现代浏览器对 W3C 标准支持的比较好的今天，我们还是能在很多地方看到<code>javascript: void(0);</code>。</p>
<h3 id="3-用于立即执行函数表达式（IIFE）"><a href="#3-用于立即执行函数表达式（IIFE）" class="headerlink" title="3. 用于立即执行函数表达式（IIFE）"></a>3. 用于立即执行函数表达式（IIFE）</h3><p>在使用立即执行函数表达式时，如果像下面这样写，会得到一个报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，有两种方式：</p>
<ul>
<li><p>给函数体包一层圆括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>或者使用void运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>不过话说回来，IIFE 多用于 ES6 之前实现模块化，在 ES6 引入了<code>import</code>、<code>export</code>之后，IIFE 在实际的开发中用到的场景越来越少了，是一种过时的技术，这里是为了讲解<code>void</code>运算符才使用的，大家可以只做了解即可。</p>
<h3 id="4-强制返回undefined（常见于箭头函数中）"><a href="#4-强制返回undefined（常见于箭头函数中）" class="headerlink" title="4. 强制返回undefined（常见于箭头函数中）"></a>4. 强制返回<code>undefined</code>（常见于箭头函数中）</h3><p>在箭头函数中，允许在函数体不使用花括号来直接返回值，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> doSomething();</span><br></pre></td></tr></table></figure>

<p>但是这样做会把<code>doSomething</code>函数的执行结果作为返回值来返回给调用方，而如果<code>doSomething</code>函数的返回值从<code>undefined</code>变成了其他值，可能会造成预料之外的结果。</p>
<p>所以如果明确<code>onclick</code>不需要返回值时，可以通过增加<code>void</code>运算符来强制返回<code>undefined</code>，防止因为<code>doSomething</code>返回值的变化带来其他副作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> <span class="keyword">void</span> doSomething();</span><br></pre></td></tr></table></figure>

<p>当然了，这里除了这种方式外，也可以通过给箭头函数增加一对花括号来解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面这些就是<code>void</code>运算符用的比较多的场景了，如果还有需要补充的，欢迎在评论区留言~</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/21/%E4%B8%80%E8%B5%B7%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0React%20SSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">一起从零实现React SSR服务端渲染</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-21 17:25:00" itemprop="dateCreated datePublished" datetime="2023-12-21T17:25:00+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-24 19:06:47" itemprop="dateModified" datetime="2024-01-24T19:06:47+08:00">2024-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Next.js 14 发布了，很多地方都在讨论，虽然之前也有用过 Next.js，也看过一些关于 SSR 的文章，了解了一些 SSR 的原理，但是一直没有动手实现过。这次正好趁着这个机会，从零开始手动实现一个 React SSR 服务端渲染的项目，来加深一下对 SSR 的理解。</p>
<h2 id="一、-什么是SSR"><a href="#一、-什么是SSR" class="headerlink" title="一、 什么是SSR"></a>一、 什么是SSR</h2><p>SSR，即Server Side Render，服务端渲染。和服务端渲染相对的，就是CSR，Client Side Render，客户端渲染。</p>
<p>从字面意思上就有看出，这两种渲染方式的差别就在于页面渲染的时机：</p>
<ul>
<li>服务端渲染是页面在服务端的时候就渲染完成了</li>
<li>而客户端渲染是页面在客户端（浏览器或者WebView之类的）进行渲染，服务端只会返回空页面（下面例子中会讲到）</li>
</ul>
<h2 id="二、-为什么需要SSR"><a href="#二、-为什么需要SSR" class="headerlink" title="二、 为什么需要SSR"></a>二、 为什么需要SSR</h2><p>在讨论为什么需要SSR之前，我们先来看看常见的CSR，比如下面这个很简单的React渲染的页面：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/page_overview.png" alt="page_overview.png"></p>
<p>页面包含一个count计数，点击“Increment”、“Decrement”和“Reset”按钮，分别可以增加计数，减小计数以及重设计数。</p>
<p>现在我们打开DevTool，看看访问这个地址的时候服务端返回的内容：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_html_content.png" alt="csr_html_content.png"></p>
<p>从DevTool可以看到，服务端一共返回了两个文件，一个HTML一个JS。</p>
<p><strong>我们发现HTML里没有任何页面上的元素，是空的</strong>，只有一个root节点和一个main.js脚本。而所有的这些count计数以及下面这些按钮，都是在HTML页面以及main.js下载完成后，浏览器通过执行main.js来进行渲染生成的，这也就是所谓的客户端渲染。</p>
<p>通过这个我们可以发现，CSR的应用有两个比较明显的问题：</p>
<h3 id="1-CSR应用十分不利于SEO"><a href="#1-CSR应用十分不利于SEO" class="headerlink" title="1. CSR应用十分不利于SEO"></a>1. CSR应用十分不利于SEO</h3><p>SEO，也就是Search Engine Optimization，搜索引擎优化。CSR应用从服务端返回的HTML是一个空的页面，页面内容元素完全依赖JS代码来生成，导致搜索引擎爬虫在抓取和解析网页时，无法获取到完整的网页内容，从而不利于搜索引擎优化搜索结果和搜索排名。</p>
<blockquote>
<p>题外话：现在的一些搜索引擎（比如Google）已经可以解析CSR应用里的JS，所以CSR目前对SEO的影响可能没有以前那么大了，但是如果SEO对你来说很重要，那么最好还是做一些SSR服务端渲染</p>
</blockquote>
<h3 id="2-首屏加载时间可能较长"><a href="#2-首屏加载时间可能较长" class="headerlink" title="2. 首屏加载时间可能较长"></a>2. 首屏加载时间可能较长</h3><p>由于CSR应用页面里所有的内容，都是通过JS动态生成的，那么在访问页面的时候，除了下载HTML外，还需要额外下载JS脚本才可以展示出页面。</p>
<p>衡量首屏加载性能的指标有很多，我们这里用常用的<a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint?utm_source=devtools">FCP（First Contentful Paint）</a>，即“首次内容渲染”时间来看下这个页面的表现。由于我们这个页面太过简单，而且是在本地<code>127.0.0.1</code>启动的服务，所以直接感受可能不明显，我们可以在DevTool里设置网络状态，改成“低速3G”来模拟：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_network_panel.png" alt="csr_network_panel.png"></p>
<p>而FCP除了可以用<code>performance</code> API获取到之外，也可以直接在Chrome DevTool的“性能”面板，通过点击面板里的“重新加载”按钮录制得到：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/csr_perf_panel.png" alt="csr_perf_panel.png"></p>
<p>从上面的网络瀑布和性能面板可以看到，在“低速3G”的网络状态下，页面在获取到2.01s获取到HTML后，并没有渲染任何内容，而是在又等了4.76s等到JS下载完成之后，才渲染出内容，页面的FCP总计是6822.2ms。</p>
<p>也就是说，在2.01s的时候，HTML已经下载好的情况下，用户还是无法看到内容，额外等待了4.76s等待JS的下载，首屏加载时间较长。</p>
<p>下面我们就来尝试把上面这个项目改成支持服务端渲染，来改善这两个CSR的弊端。</p>
<h2 id="三、-准备好一个项目"><a href="#三、-准备好一个项目" class="headerlink" title="三、 准备好一个项目"></a>三、 准备好一个项目</h2><p>首先我们先准备好上面这个项目的代码，这是项目的GitHub地址，大家可自取：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></p>
<p>项目的目录结构长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── Button</span><br><span class="line">│   │       ├── index.module.css</span><br><span class="line">│   │       └── index.tsx</span><br><span class="line">│   ├── Home.module.css</span><br><span class="line">│   ├── Home.tsx</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── index.tsx</span><br><span class="line">├── webpack</span><br><span class="line">│   └── client.config.js</span><br><span class="line">├── .babelrc</span><br><span class="line">├── .eslintignore</span><br><span class="line">├── .eslintrc.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .prettierignore</span><br><span class="line">├── .prettierrc.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── types.d.ts</span><br></pre></td></tr></table></figure>

<p>关键的几个文件内容如下：</p>
<ol>
<li><code>src/components/Button/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IButtonProps &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span>;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Button: React.FC&lt;IButtonProps&gt; = <span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  text,</span></span></span><br><span class="line"><span class="params"><span class="function">  className,</span></span></span><br><span class="line"><span class="params"><span class="function">  onClick,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">className</span>=<span class="string">&#123;classNames(styles.btn,</span> <span class="attr">className</span>)&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;text&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>src/Home.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;@/components/Button&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Home.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Home: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.btnWrapper&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Increment&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prev =&gt; prev + 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Decrement&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(prev =&gt; prev - 1)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">text</span>=<span class="string">&quot;Reset&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">className</span>=<span class="string">&#123;styles.btn&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(0)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>src/index.tsx</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>webpack/client.config.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ForkTsCheckerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;fork-ts-checker-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist/client&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>, path.resolve(rootDir, <span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">      <span class="attr">scriptLoading</span>: <span class="string">&#x27;defer&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ForkTsCheckerWebpackPlugin(&#123;&#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">performance</span>: &#123;</span><br><span class="line">    <span class="attr">hints</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">maxEntrypointSize</span>: <span class="number">512000</span>,</span><br><span class="line">    <span class="attr">maxAssetSize</span>: <span class="number">512000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>package.json</code></li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之前，其他一些都是代码规范化相关的配置，比如eslint、prettier之类的，不是这次重点讨论的范围，感兴趣的可以看我之前这篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/7314365567376162853">《前端代码规范化配置最佳实践 - 掘金》</a>。</p>
<p>通过在本地执行<code>npm run dev</code>或者<code>npm run build</code>，就可以编译项目，这里我没有使用webpack dev server，而是起了一个Nginx服务，简单改了一下Nginx配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">3006</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   /your-project-location/react-<span class="literal">no</span>-ssr-demo/dist/client;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样直接在浏览器访问<code>127.0.0.1:3006</code>或者<code>localhost:3006</code>就可以了。</p>
<h2 id="四、-使用服务端渲染"><a href="#四、-使用服务端渲染" class="headerlink" title="四、 使用服务端渲染"></a>四、 使用服务端渲染</h2><p>现在让我们开始给项目添加服务端渲染，既然要服务端渲染，就必须在服务端使用React的<a target="_blank" rel="noopener" href="https://react.docschina.org/reference/react-dom/server/renderToString">renderToString</a>来渲染好HTML再返回给客户端，既然要求在服务端跑JS代码，那么服务端就必须要引入Node了，也就是说做服务端渲染，必须要有一个Node做中间层（Next.js的<a target="_blank" rel="noopener" href="https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation">SSG</a>不算是严格意义上的服务端渲染，不在讨论范围内）。</p>
<h3 id="1-添加Node服务"><a href="#1-添加Node服务" class="headerlink" title="1. 添加Node服务"></a>1. 添加Node服务</h3><p>现在让我们先加一个基础的Node服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br><span class="line">npm install --save-dev @types/express</span><br></pre></td></tr></table></figure>

<p>添加一个<code>src/server.tsx</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;React SSR&lt;/title&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  res.send(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我们换了一个<code>3007</code>端口，为了和刚刚的CSR项目的<code>3006</code>端口区分开来（另外使用了Node服务之后，也就不需要Nginx了）。</p>
<p>从上面的代码可以看到，<code>src/server.tsx</code>中，先创建了一个express服务，然后监听了<code>3007</code>端口，在访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>的时候，服务端调用ReactDOMServer的<code>renderToString</code>方法，将我们的<code>Home</code>组件渲染为了HTML字符串，并且拼接到了一个HTML模板中，返回给了客户端。</p>
<h3 id="2-添加src-server-tsx的编译配置"><a href="#2-添加src-server-tsx的编译配置" class="headerlink" title="2. 添加src/server.tsx的编译配置"></a>2. 添加<code>src/server.tsx</code>的编译配置</h3><p>由于<code>src/server.tsx</code>使用了TS和JSX的语法，那么这个文件也需要使用webpack和babel进行编译，让我们添加一下这个server文件的编译配置，<code>webpack/server.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/server.tsx&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(rootDir, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;server.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(tsx?|jsx?)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;/node_modules/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在<code>package.json</code>中添加一下编译服务端的scripts命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run dev:server</code>以及<code>npm start</code>之后，打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_no_js.gif" alt="ssr_no_js.gif"></p>
<p>果然，这次服务端返回的HTML不再是空的了，页面上的元素直接就可以在HTML中看到。</p>
<p>但是这里奇怪的是，页面的样式没有了，点击这些按钮也不再生效了，同时从网络请求里看到，服务端也只返回了一个HTML，没有JS，这是为什么呢？</p>
<h2 id="五、-同构-amp-hydrate"><a href="#五、-同构-amp-hydrate" class="headerlink" title="五、 同构 &amp; hydrate"></a>五、 同构 &amp; hydrate</h2><p>其实，这是因为我们上面实现的SSR还不是一个完整的React SSR项目。<code>renderToString</code>虽然可以在服务端把组件渲染为HTML，但是却无法实现事件监听器的挂载或者绑定（毕竟事件绑定是要绑定到浏览器上真实的DOM上，而不是HTML字符串上），所以在<code>renderToString</code>的时候会把事件处理器给过滤掉。</p>
<h3 id="1-同构"><a href="#1-同构" class="headerlink" title="1. 同构"></a>1. 同构</h3><p>那么为了实现完整的SSR，就需要引入“同构渲染”的概念了。这个词相信大家之前都或多或少听过，其实很简单，同构渲染就是同一份代码，既在服务端运行（SSR），又在客户端运行（CSR）。</p>
<p>最开始我们提到的那个CSR代码，只是在客户端运行，后来加上的服务端渲染的能力，只是在服务端运行（客户端只是接收了一个HTML，并没有运行什么JS代码）。现在需要将两者结合起来，接下来让我们开始改造一下：</p>
<p>首先，<code>src/server.tsx</code>中，我们不再直接返回一个模板HTML，而是在上面CSR项目编译出来的HTML中直接加上服务端渲染的内容，同时在服务端提供静态资源访问服务：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientDistDir = path.resolve(__dirname, <span class="string">&#x27;../dist/client&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlPath = path.resolve(clientDistDir, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 读取 dist/client/index.html 文件</span></span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(htmlPath, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> app = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 将渲染后的 React HTML 插入到 div#root 中</span></span><br><span class="line">  <span class="keyword">const</span> finalHtml = html.replace(</span><br><span class="line">    <span class="string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">`&lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;`</span></span><br><span class="line">  );</span><br><span class="line">  res.send(finalHtml);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供静态资源访问服务</span></span><br><span class="line">app.use(express.static(clientDistDir));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">3007</span>;</span><br><span class="line">app.listen(PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server is listening on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接在命令行执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm run dev:server</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>打开<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>看下：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_render.gif" alt="ssr_render.gif"></p>
<p>看起来好像OK了，既有服务端渲染（返回的HTML不为空，直接就有页面上的元素），又有客户端渲染（事件绑定成功，有页面交互）。但是如果这个时候你查看一下控制台的话，会发现会有一个Waring：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_render_warn.png" alt="ssr_render_warn.png"></p>
<p>说是调用<code>ReactDOM.render()</code>去渲染（水合，或者说注水）一个服务端渲染的页面的行为会在React 18停止支持。</p>
<h3 id="2-hydrate"><a href="#2-hydrate" class="headerlink" title="2. hydrate"></a>2. hydrate</h3><p>其实这个从<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/server/renderToString#reference">React官网</a>也可以看到，在服务端使用<code>renderToString</code>外进行服务端渲染后，还需要在客户端使用<code>hydrate</code>（或者<code>hydrateRoot</code>，后者是React 18中的写法），来完成事件绑定和页面的交互性逻辑。</p>
<p>来改下代码，在<code>src/index.tsx</code>中，改为如下内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Home &#125; <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.hydrate(<span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>同时为了方便调试，安装一下两个依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save nodemon</span><br><span class="line">npm install --save-dev npm-run-all</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;npm-run-all --parallel dev:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:client&quot;</span>: <span class="string">&quot;webpack --config webpack/client.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:server&quot;</span>: <span class="string">&quot;webpack --config webpack/server.config.js --mode development --watch --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npm-run-all build:*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:client&quot;</span>: <span class="string">&quot;webpack build --config webpack/client.config.js --mode production --stats verbose&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:server&quot;</span>: <span class="string">&quot;webpack build --config webpack/server.config.js --mode production --stats verbose&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>nodemon</code>用于监听<code>dist/server.js</code>的变化，一旦修改了<code>src/server.tsx</code> webpack会重新编译，生成新的<code>dist/server.js</code>，这个时候nodemon会重新运行新的<code>dist/server.js</code>。</p>
<p><code>npm-run-all</code>则用于同时运行多个npm命令。</p>
<p>这个时候再运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>访问<code>127.0.0.1:3007</code>或者<code>localhost:3007</code>，发现已经没有Waring了：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_hydrate_no_warn.png" alt="ssr_hydrate_no_warn.png"></p>
<h3 id="3-hydrate和render的区别"><a href="#3-hydrate和render的区别" class="headerlink" title="3. hydrate和render的区别"></a>3. hydrate和render的区别</h3><p><code>render()</code>和<code>hydrate()</code>在大部分情况下的行为是相似的，这两个都会将React元素渲染到指定的DOM节点中，但是在处理服务端渲染返回的HTML是有一些区别。</p>
<p>服务端渲染的时候，服务端会渲染React元素并且生成一个HTML字符串返回给客户端（也就是浏览器），之后客户端会用这个HTML来生成DOM。在同构渲染的时候，客户端还会重新执行一遍JS代码，重新生成一个React组件树和相应的DOM节点。而<code>render()</code>和<code>hydrate()</code>的区别就在这里。</p>
<p><code>render()</code>会直接创建一个新的React组件数和相应的DOM节点，而<code>hydrate()</code>则是在生成的时候，会判断这个节点是否已经在服务端渲染好，<strong>会尽可能地保留现有的DOM，只更新必要的部分</strong>。</p>
<p>这也就是React官网所说的：</p>
<blockquote>
<p>Call hydrate in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.</p>
<p>React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it.</p>
</blockquote>
<p>在React 17及以下版本中调用<code>hydrate</code>，可以将React“附加”到在服务器环境中已经由React渲染的现有HTML上。</p>
<p>React将会附加到<code>domNode</code>内部现有的HTML，并接管有关的DOM的管理。</p>
<h2 id="六、-再来看下CSR的两个痛点"><a href="#六、-再来看下CSR的两个痛点" class="headerlink" title="六、 再来看下CSR的两个痛点"></a>六、 再来看下CSR的两个痛点</h2><p>到这里就算是完成了一个最基本的React服务端渲染，现在我们回头来看一下，是否解决了上面CSR项目的两个痛点。</p>
<h3 id="1-SEO"><a href="#1-SEO" class="headerlink" title="1. SEO"></a>1. SEO</h3><p>首先是之前SEO不友好的问题。</p>
<p>在做了SSR渲染后，从服务端返回的HTML里就已经包含了页面上的元素，搜索引擎爬虫在抓取和解析网页时，可以获取到完整的网页内容，显然SSR渲染可以解决这个问题（当前想要更好的SEO效果，还有其他可以优化的地方，不过这些就和CSR/SSR无关了）。</p>
<h3 id="2-FCP"><a href="#2-FCP" class="headerlink" title="2. FCP"></a>2. FCP</h3><p>其次，我们来看一下首屏的加载时间，还是通过设置DevTool里设置网络状态，改成“低速3G”来看一下FCP：</p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_network_panel.png" alt="ssr_network_panel.png"></p>
<p><img src="https://static.youfindme.cn/blog/react_ssr_from_scratch/ssr_perf_panel.png" alt="ssr_perf_panel.png"></p>
<p>从上面可以看到，虽然网络面板内的HTML和JS整体的加载时间和之前几乎一样（都是6.8s左右），但是从性能面板里可以看到，页面的FCP是2043.2ms，比之前的6822.2ms少了将近70%。</p>
<p>从时间轴的截图上也可以发现，页面在HTML下载成功之后（2.02s），就立刻可以看到页面内容，虽然页面的交互还是需要等到6.8s JS下载完成，但是从用户体验上来讲，缩短页面的白屏时间，用户可以更快的看到页面内容，对于用户体验是一个很大的提升。</p>
<p>也就是说，SSR确实解决了CSR的两个痛点。</p>
<h2 id="七、-服务端渲染一些主要注意的事情"><a href="#七、-服务端渲染一些主要注意的事情" class="headerlink" title="七、 服务端渲染一些主要注意的事情"></a>七、 服务端渲染一些主要注意的事情</h2><p>下面是一些做服务端渲染时需要注意的点：</p>
<h3 id="1-React的生命周期和一些Hooks"><a href="#1-React的生命周期和一些Hooks" class="headerlink" title="1. React的生命周期和一些Hooks"></a>1. React的生命周期和一些Hooks</h3><p>React的一些生命周期函数，比如类组件的<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以及函数组件的<code>useEffect</code>和<code>useLayoutEffect</code>，都不会在服务端渲染的时候执行。</p>
<h3 id="2-浏览器专属的API"><a href="#2-浏览器专属的API" class="headerlink" title="2. 浏览器专属的API"></a>2. 浏览器专属的API</h3><p>浏览器专属的API，比如<code>window</code>，<code>document</code>，<code>localStorage</code>等，都不能在服务器端运行，需要判断只有在当前环境是客户端才可以执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下面的代码只会在浏览器环境下执行</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="3-事件处理函数"><a href="#3-事件处理函数" class="headerlink" title="3. 事件处理函数"></a>3. 事件处理函数</h3><p>如上面提到的那样，服务端渲染的时候，不会执行事件处理函数，也不会触发任何事件，需要在客户端处理。</p>
<h3 id="4-服务端渲染和客户端渲染时的差异"><a href="#4-服务端渲染和客户端渲染时的差异" class="headerlink" title="4. 服务端渲染和客户端渲染时的差异"></a>4. 服务端渲染和客户端渲染时的差异</h3><p>在进行同构渲染的时候，<strong>请务必保证</strong>客户端渲染出来的内容和服务端渲染的内容完全相同。如果客户端和服务端渲染出来的内容不一致，React会尝试对不一致的地方进行修复，而这些修复是<a target="_blank" rel="noopener" href="https://react.dev/reference/react-dom/hydrate#caveats">非常耗时的</a>。如果差异过大甚至会重新渲染整个应用（类似于<code>ReactDOM.render</code>）。</p>
<p>所以应尽量避免客户端渲染出来的内容和服务端渲染出来的内容不一致。</p>
<h2 id="八、-小结"><a href="#八、-小结" class="headerlink" title="八、 小结"></a>八、 小结</h2><p>通过上面的内容，我们从零手动完成了一个React服务端渲染的Demo项目，这只是一个最基础的项目，还有更多的比如React路由服务端渲染、服务端渲染时的数据脱水和注水等等，都需要添加更加复杂的配置，有时间了再单独写一篇聊一下。</p>
<p>这里附上文章里提到的两个Demo项目地址：</p>
<ul>
<li>CSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-no-ssr-demo">react-no-ssr-demo</a></li>
<li>SSR：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/react-ssr-demo">react-ssr-demo</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://react.dev/">https://react.dev</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文) - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0">http://www.ayqy.net/blog/react-ssr-under-the-hood/#articleHeader0</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/325952676">什么是前端的同构渲染？</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc">https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/server-side-rendering-ssr-in-reactjs-part1-d2a11890abfc</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/15/DockerNginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/15/DockerNginx/" class="post-title-link" itemprop="url">使用 Docker 安装 Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-15 19:37:06" itemprop="dateCreated datePublished" datetime="2023-12-15T19:37:06+08:00">2023-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx bash</span><br><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/docker/nginx/conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx:/etc/nginx/nginx.conf /opt/docker/nginx/conf/nginx.conf</span><br><span class="line">docker cp nginx:/etc/nginx/conf.d/ /opt/docker/nginx/conf/conf.d</span><br><span class="line">docker cp nginx:/var/<span class="built_in">log</span>/nginx/ /opt/docker/nginx/logs</span><br><span class="line">docker cp nginx:/usr/share/nginx/html/ /opt/docker/nginx/html</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 80:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个是有问题的，这样设置里之后，访问 `http://localhost:80` 依然可以访问到 nginx 的默认页面</span></span><br><span class="line"><span class="comment"># 因为这个命名使用了 `--net host` 选项，这个选项会让容器使用宿主机的网络，所以 Docker 中的 Nginx 依然会监听宿主机的 80 端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是在云服务器上使用 Docker 安装 Nginx，那么下面的命令会导致，使用 8080 端口也可能访问呢不到 Nginx 的默认页面，因为一般情况下云服务器默认的防火墙会关闭 8080 端口。</span></span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">--name nginx \</span><br><span class="line">--net host \</span><br><span class="line">-v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /opt/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v /opt/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7176299143659257893">完整详细使用Docker安装Nginx教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/15932500.html">docker+nginx 安装部署修改资源目录配置文件和容器端口信息</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44248903/article/details/134803724">2023 docker nginx安装教程(含portainer教程)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49194578/article/details/117341481">Docker 安装 nginx 并且配置反向代理遇到的坑</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/11/Sentry%E6%B2%BB%E7%90%86%E4%B9%8BIssue%E5%88%86%E7%BB%84%EF%BC%88Issue%20Grouping%EF%BC%89/" class="post-title-link" itemprop="url">Sentry治理之Issue分组（Issue Grouping）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-11 13:05:23" itemprop="dateCreated datePublished" datetime="2023-12-11T13:05:23+08:00">2023-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Sentry大家应该都不陌生，即便没有使用过，也应该听过Sentry的大名。</p>
<p>作为一个实时事件日志监控平台，Sentry可以记录和聚合我们应用中的报错、打点等，不管是Sentry自动捕获的错误，还是我们主动上报的错误，都可以在Sentry提供的可视化平台看到，方便开发者及时发现、分析和排查应用中存在的问题。</p>
<p>但是在使用Sentry的过程中，我们发现了一些使用起来不那么方便的地方，这个就是我们今天要一起讨论的问题——Sentry Issue的分组（Issue Grouping）。</p>
<h2 id="二、先看看什么是Sentry-Issue"><a href="#二、先看看什么是Sentry-Issue" class="headerlink" title="二、先看看什么是Sentry Issue"></a>二、先看看什么是Sentry Issue</h2><p>在Sentry中，每一条日志上报都是一个事件（Event）,在Sentry的Discover面板中，我们可以看到所有上报的Event，比如我这个项目：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/discover.png" alt="Discover面板"></p>
<p>Event分为两种类型，Transaction和Error。</p>
<p>Transaction事件主要用于性能监控。它记录了一个请求或任务从开始到结束的完整生命周期，包括各种详细的性能数据，如请求的开始时间、结束时间、总耗时、各个阶段的耗时等。</p>
<p>Error事件主要用于错误跟踪。它记录了应用运行过程中发生的错误或异常，包括错误的类型、位置、堆栈跟踪等信息。</p>
<p>而<strong>Issue就是Error类型的Event的聚合</strong>，Sentry会把一些相似的Error进行聚合，合并成一个Issue，这样我们就可以看到某个特定Error发生的频率和趋势，而不仅仅是只能看到单个Error Event。</p>
<p>Sentry的Issue可以在Issues面板中看到，如下图所示：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issues.png" alt="Issue面板"></p>
<p>从这个面板可以看到某个Issue（即某个类型的Error），上报了几次，有多少用户遇到了这个Error，以及这个Error数量变化的趋势，帮助我们快速确认问题的严重程度和影响范围。</p>
<h2 id="三、我们遇到啥问题了？"><a href="#三、我们遇到啥问题了？" class="headerlink" title="三、我们遇到啥问题了？"></a>三、我们遇到啥问题了？</h2><p>从上面的描述可以看到，Sentry把Error进行聚合，合并成一个个Issue，帮助我们查看某个类型Error的一些信息，看起来是挺好的。</p>
<p>但是在我们的项目里，Sentry好像并不是这么做的，比如下图：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/repeat_issues.png" alt="重复的Issue"></p>
<p>说好的自动聚合分组呢？</p>
<p>同样的一个Error（或者是极其相似的Error）,并没有被聚合为同一个Issue，而是分到了不同的几个Issue里，并且这些Issue的名字几乎一摸一样，每个Issue还各自展示一个Event次数。</p>
<p>而且这个问题不止出现在某一种类型的Error上，几乎所有的Error上报都或多或少地存在这种问题，导致不能很好地分析某种Error的影响或者变化趋势。</p>
<p>而且有时候即便我们手动Ignore某个Issue，未来还是会不断地有新的这个Issue出现，或者我们像下面这样手动Merge两个Issue，也还是会源源不断地产生新的、没有被Merge进手动Merge的分组内的Issue。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<h2 id="四、研究下Sentry是怎么对Error分组的"><a href="#四、研究下Sentry是怎么对Error分组的" class="headerlink" title="四、研究下Sentry是怎么对Error分组的"></a>四、研究下Sentry是怎么对Error分组的</h2><p>在解决我们遇到的问题之前，还是要先了解下Sentry是怎么对Error进行分组的，知道原理才能着手解决。</p>
<p>看了下官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>，这才揭开了Sentry分组的面纱。</p>
<h3 id="1-Sentry-Issue的Fingerprint和分组"><a href="#1-Sentry-Issue的Fingerprint和分组" class="headerlink" title="1. Sentry Issue的Fingerprint和分组"></a>1. Sentry Issue的Fingerprint和分组</h3><p>在Sentry中，有一个“指纹”的概念，Fingerprint，Fingerprint是标识Event的一种方式，每个Event（包括Error和Transaction）都有一个Fingerprint。</p>
<p>Sentry会根据某种规则，来给每一个Event生成Fingerprint，具有相同Fingerprint的Event会被Sentry分为一组，这就是Sentry分组的基本原则。</p>
<h4 id="1-1-如何在Sentry上查看一个Event的Fingerprint呢？"><a href="#1-1-如何在Sentry上查看一个Event的Fingerprint呢？" class="headerlink" title="1.1 如何在Sentry上查看一个Event的Fingerprint呢？"></a>1.1 如何在Sentry上查看一个Event的Fingerprint呢？</h4><p>从Discover或者Issues列表中，随便点击一个进入Error详情（Transaction不行，下面会讲原因），点击查看这个Error对应原始JSON数据：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_detail_json.png" alt="查看原始JSON"></p>
<p>在原始JSON中搜索fingerprint字段，可以看到如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;fingerprint&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个<code>&#123;&#123; default &#125;&#125;</code>，这说明使用的是Sentry默认规则生成的Fingerprint。如果是其他的规则，则会展示为其他的值。</p>
<h4 id="1-2-Event默认的Fingerprint生成规则"><a href="#1-2-Event默认的Fingerprint生成规则" class="headerlink" title="1.2 Event默认的Fingerprint生成规则"></a>1.2 Event默认的Fingerprint生成规则</h4><p>不同类型的Event，有不同的Fingerprint生成规则：</p>
<ul>
<li>Error类型：Error类型会基于这个Error的调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>，从这三个方面来生成Fingerprint</li>
<li>Transaction类型：通过这个类型的Spans来生成，可以查看原始JSON数据中的<code>spans</code>字段</li>
</ul>
<p>我们这次只讨论Error类型的Event Fingerprint生成规则。</p>
<p>首先，Sentry每个版本生成Fingerprint的默认规则可能会有一些差异，每次Sentry默认的Fingerprint生成规则变化了之后，Sentry都会发布一个新版本，所以Fingerprint生成规则变化了之后，不会影响已有的Event。</p>
<p>每次新建一个Project，都会自动使用目前最新版本的Fingerprint生成规则，如果想要现有的Project升级到最新的Fingerprint生成规则，需要在设置里手动修改，具体位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Upgrade Grouping</strong>.如下图：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/upgrade_grouping.png" alt="升级分组"></p>
<p>所有版本的Fingerprint生成规则都是最先考虑<code>Stack Trace</code>，然后是<code>Exception</code>, 最后是<code>message</code>。</p>
<h5 id="a-按照Stack-Trace分组"><a href="#a-按照Stack-Trace分组" class="headerlink" title="a. 按照Stack Trace分组"></a>a. 按照Stack Trace分组</h5><p>对于一个上报的Error Event，如果他的原始数据中有调用堆栈信息，就会完全根据调用堆栈来进行分组（即不考虑其他的），主要会使用下列信息：</p>
<ul>
<li>模块名module</li>
<li>文件名（去除哈希值等之后的名字）filename</li>
<li>上下文，行号列号等信息</li>
</ul>
<p>这里的堆栈信息只包括和当前Project有关的堆栈，和当前项目无关的堆栈信息不会用于分组。</p>
<p>堆栈信息可以在原始的JSON数据中的<code>exception.values</code>的<code>stacktrace</code>字段中看到，如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;exception&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;xxx err&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;stacktrace&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;frames&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;rrr&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;uuu&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///ddd/eee/fff.js&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;lineno&quot;</span>: <span class="number">20</span>,</span><br><span class="line">              <span class="attr">&quot;colno&quot;</span>: <span class="number">57</span>,</span><br><span class="line">              <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>stacktrace</code>字段中有个<code>frames</code>，是一个数据，记录的是当前Error发生时的调用堆栈帧列表，数组中的每一项就是一个调用帧（frame），每一帧中都有如下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;abs_path&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lineno&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;colno&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;in_app&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Sentry就是根据这些调用栈的帧列表，来生成Fingerprint。即相同调用堆栈的错误，被认为是同一种类Error，会被归为同一组。</p>
<p>用这个方法来分组，一般来说效果都挺不错，但是如果出现下面这些情况，就会导致这个分组方法或者说分组规则，效果不那么好：</p>
<ol>
<li><p>代码经过混淆或者压缩（比如TS/JS代码经过Babel编译）<br>由于混淆或者压缩之后，代码的变量名、函数名、代码结构等都会发生变化，即便对于同一个Error，不同版本的代码（比如两个release版本之间，或者两次不同的构建之间）的调用堆栈信息也会发生变化，导致Sentry认为这些是不同的Error，从而没有进行聚合分组。<br>如果代码有混淆或者压缩，就需要上传Source Maps到Sentry，让Sentry通过原始的堆栈信息生成Fingerprint，来避免分组混乱。</p>
</li>
<li><p>代码通过装饰器等引入了新的堆栈层级，也会导致调用堆栈发生变化。比如</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> decoratorFn = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Before function execution&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;After function execution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @decoratorFn</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Inside function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，<code>myFunction</code>被<code>decoratorFn</code>装饰。当调用<code>myFunction</code>时，实际上是在调用<code>decoratorFn</code>返回的函数。因此，如果在这个过程中发生错误并生成堆栈信息，堆栈信息中将会包含<code>decoratorFn</code>返回的函数的调用，这就是通过引入新的堆栈层级来修改堆栈信息。</p>
<p>可以通过自定义的<code>beforeSend</code>来自定义删除或者修改这些堆栈信息（下面会讲到）。</p>
<h5 id="b-按照Exception分组"><a href="#b-按照Exception分组" class="headerlink" title="b.按照Exception分组"></a>b.按照Exception分组</h5><p>如果上报的Error Event的数据中没有堆栈调用信息，但是有完整的<code>Exception</code>信息（这里的完整指的是<code>Exception</code>的type和value同时存在），就会按照<code>Exception</code>的type和value进行分组，但是这种分组可靠性比较低，因为错误的信息可能会改变。</p>
<p>这里的<code>Exception</code>指的就是各种Error，JS里的<code>Exception</code>就是各种类型的<code>Error</code>，比如<code>ReferenceError</code>、<code>TypeError</code>、<code>RangeError</code>、<code>SyntaxError</code>等。</p>
<ul>
<li><code>Exception</code>的type就是Error的name，如果有自定义的name就是自定义的name，比如<code>DownloadFileError</code>，没有自定义的话默认就是各个类型名</li>
<li>Exception的value指的就是err.message</li>
</ul>
<p>比如访问一个未定义的变量，JS会抛出一个<code>ReferenceError</code>，type就是“ReferenceError”，value可能是“x is not defined”。</p>
<p>如果是下面的自定义name的Error：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;This is a mock err msg&#x27;</span>);</span><br><span class="line">err.name = <span class="string">&#x27;MyMockError&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个Error的type就是“MyMockError”，value就是“This is a mock err msg”。</p>
<p>这里的type和value也可以直接在Sentry上任意一个Error原始的JSON数据中看到，JSON中的<code>metadata</code>字段，记录了这个Error的type和value：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;display_title_with_tree_label&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;app:///aaa/bbb/ccc.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;function&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;MyMockError: This is a mock err msg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;MyMockError&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;This is a mock err msg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>问：</strong></em><br>什么情况下会出现存在Exception但是不包含堆栈信息？</p>
<p><em><strong>ChatGPT:</strong></em><br>在大多数情况下，当JavaScript抛出一个异常时，这个异常都会包含一个堆栈跟踪。堆栈跟踪记录了错误发生时的函数调用序列，这对于理解和调试错误是非常有用的。<br>然而，在某些情况下，异常可能不包含堆栈跟踪。例如：</p>
<ol>
<li><p>如果你手动创建并抛出一个错误，但没有提供堆栈跟踪，那么这个错误就不会有堆栈跟踪。例如，throw new Error()会创建一个包含堆栈跟踪的错误，但throw { message: ‘error’ }则不会。</p>
</li>
<li><p>在某些JavaScript环境中，例如某些旧版本的浏览器或某些JavaScript引擎，可能不支持堆栈跟踪，或者支持的方式与标准不同。</p>
</li>
<li><p>如果错误发生在异步代码中，并且这个错误没有被正确地捕获和处理，那么可能只有错误信息，没有堆栈跟踪。</p>
</li>
<li><p>如果你的代码中有捕获错误并处理的逻辑，可能会修改或移除堆栈跟踪。</p>
</li>
</ol>
</blockquote>
<h5 id="c-兜底的分组"><a href="#c-兜底的分组" class="headerlink" title="c. 兜底的分组"></a>c. 兜底的分组</h5><p>如果上面两种情况都没办法对Event进行分组，那么就会使用兜底的分组，即直接使用上报的时候收到的Event消息来分组。</p>
<h4 id="1-3-分析一下"><a href="#1-3-分析一下" class="headerlink" title="1.3 分析一下"></a>1.3 分析一下</h4><p>到这里我们可以先分析一下，为什么我们的项目会出现上面说的问题了。</p>
<p>首先，我们的项目没有修改过任何和Event Fingerprint有关的设置，使用的是默认分组规则，即使用调用堆栈<code>Stack Trace</code>，异常类型<code>Exception</code>，和日志消息<code>message</code>来进行分组。而绝大部分都是使用调用堆栈进行分组。</p>
<p>我们的JS项目由于某种原因，在编译后没有把Source Maps上传到Sentry，导致代码的变量名、函数名、代码结构等在不同版本或者不同的构建记录后，都会发生变化，所以即便某个Issue被Ignore或者被手动Merge，到下一个版本，由于同一个Error的调用栈变化了，生成了完全不同的Fingerprint，导致没有被分为一组。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/mixed_call_stack.png" alt="混淆压缩后的代码的调用栈"></p>
<blockquote>
<p><strong>💡注意：</strong><br>代码混淆之后并不是会让Sentry没办法对Error生成Fingerprint以及分组，即使代码被混淆和压缩，只要所有用户都使用的是同一份混淆和压缩后的代码，那么同一个地方的Error应该会生成相同的堆栈跟踪，Sentry应该能够正确地将这些错误分到同一组。</p>
<p>真正的问题在于多个版本或者多个构建之间，每次压缩混淆后的代码都不一样，从而导致不同版本直接Error分组混乱。</p>
</blockquote>
<p>看来使用默认的Fingerprint生成规则不行了，至少在我们项目上传Source Maps之前不行。需要看下怎么自定义分组。</p>
<h4 id="1-4-自定义分组"><a href="#1-4-自定义分组" class="headerlink" title="1.4 自定义分组"></a>1.4 自定义分组</h4><p>首先，只有Error类型的Event支持自定义分组，Transaction类型的暂时无法自定义。这也是为什么上面说Transaction类型的Event，无法在原始JSON数据中看到fingerprint字段的原因，因为Transaction Event无法自定义，所以也就不会展示在JSON数据里。</p>
<p>对于Error类型的Event，从简单到复杂有以下4种方式来自定义分组：</p>
<ol>
<li><p>在Sentry Admin对应的项目Issues列表中，手动Merge<br>手动合并（你认为是）相同的Issues，最简单，不需要修改任何设置和配置项。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Fingerprint Rules<br>设置Fingerprint Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在Sentry Admin对应的项目设置中，设置自定义的Stack Trace Rules<br>设置Stack Trace Rules，只影响新上报的的Event，不影响已经上报的Event。</p>
</li>
<li><p>在使用Sentry SDK的本地项目里，使用SDK Fingerprinting<br>在本地项目中，使用SDK上报之前，设置Event的Fingerprint。</p>
</li>
</ol>
<p>下面我们一个个来看。</p>
<h3 id="2-手动合并Issue"><a href="#2-手动合并Issue" class="headerlink" title="2. 手动合并Issue"></a>2. 手动合并Issue</h3><p>在Sentry项目的Issues列表中，手动选择2或者更多个Issue，然后点击Merge，即可合并为一个分组。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/merge_issues.png" alt="手动Merge"></p>
<p>需要注意的是，Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则，新产生的Issue还是会按照之前的规则来分组，然后根据放到我们手动Merge的Issue集合中。</p>
<p>这也解释了为什么我们项目中，每次手动Merge之后，还是会产生新的没有被进入Merge后的分组，因为“Sentry并不会根据我们如何手动Merge，来改变或者推断出任何新的分组规则”。</p>
<h3 id="3-Stack-Trace-Rules"><a href="#3-Stack-Trace-Rules" class="headerlink" title="3. Stack Trace Rules"></a>3. Stack Trace Rules</h3><p>虽然按照Sentry官网的文档的说法，Stack Trace Rules要比Fingerprint Rules复杂一些，我们还是先来讲下Stack Trace Rules。</p>
<p>在比较旧的Sentry版本中，Stack Trace Rules也叫作Grouping Enhancements或者Custom Grouping Enhancements。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Stack Trace Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Custom Grouping Enhancements</strong>。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/stack_trace_rules.png" alt="Stack Trace Rules"></p>
<p>修改Stack Trace Rules会影响<strong>输入到Stack Trace分组算法中的数据</strong>。我们可以通过规则来改变哪些stack trace frames被视为”in-app”，这会影响Sentry如何将Issue分组。例如，我们可以将某些通常被视为”not in-app”的frames标记为”in-app”，这样它们就会被包含在分组算法中。</p>
<p>在自定义的Stack Trace Rules中，每一行都是一条规则。每条规则有匹配项（matcher）、表达式（expression），以及跟在后面的操作（action）组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matcher-name:expression other-matcher:expression ... action1 action2 ...</span><br></pre></td></tr></table></figure>

<p>一条规则里可以有多个匹配表达式，后面也可以有多个action。这些action会在前面所有匹配表达式匹配的时候执行。</p>
<p>所有的规则会从上到下，对调用堆栈信息里的所有帧（Frames）执行。</p>
<p>如果要表达否定，那么就在matcher前加上一个感叹号<code>!</code>，某一行以<code>#</code>开头则表达这一行是注释。</p>
<p>下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mark all functions in the std namespace to be outside the app</span><br><span class="line">family:native stack.function:std::*       -app</span><br><span class="line"></span><br><span class="line"># mark all code in node modules not to be in app</span><br><span class="line">stack.abs_path:**/node_modules/**         -app</span><br><span class="line"></span><br><span class="line"># remove all generated javascript code from all grouping</span><br><span class="line">stack.abs_path:**/generated/**.js         -group</span><br></pre></td></tr></table></figure>

<p>由于Stack Trace Rules不是我们这次讨论的重点，这里就不太说太多了，更多详细的关于Matchers和Actions的信息，详见官方文档：<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#matchers">Matchers</a>，<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#actions">Actions</a>。</p>
<h3 id="4-Fingerprint-Rules"><a href="#4-Fingerprint-Rules" class="headerlink" title="4. Fingerprint Rules"></a>4. Fingerprint Rules</h3><p>在比较旧的Sentry版本中，也叫作Server Side Fingerprinting（叫这个名字是为了和SDK Fingerprinting对应）。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Issue Grouping &gt; Fingerprint Rules</strong>。</p>
<p>或者旧版本中为：<strong>Settings &gt; Project &gt; [Your Project] &gt; General Settings &gt; Server Side Fingerprinting</strong>。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/fingerprint_rules.png" alt="Fingerprint Rules"></p>
<p>Fingerprint Rules的配置方式和Stack Trace Rules类似，只有语法上不同。但是和Stack Trace Rules不同的是，Fingerprint Rules允许我们直接指定一个Issue的Fingerprint，它会完全覆盖默认的分组规则。</p>
<p>可以理解为，<strong>Stack Trace Rules更关注如何改变分组算法的输入数据</strong>（比如翻转一些标志位，或者对调用栈做一些裁剪），而<strong>Fingerprint Rules则直接指定了分组的结果</strong>。</p>
<p>首先，Fingerprint Rules同样是每一行是一条规则。每一条规则的Matcher和Stack Trace Rules的语法规则也是一样的，并且都可以设置<code>!</code>来表示取反，以及设置<code>#</code>来注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># You can use comments to explain the rules.  Rules themselves follow the</span><br><span class="line"># following syntax:</span><br><span class="line">matcher:expression -&gt; list of values</span><br><span class="line"># The list of values can be hardcoded or substituted values.</span><br></pre></td></tr></table></figure>

<p>Fingerprint Rules也是把一个Event从上到下进行匹配，每条规则都是对调用堆栈信息里的所有帧（Frames）执行，并且会把匹配到的第一条规则作为Event的Fingerprint。</p>
<p>不同的是，Stack Trace Rules的Matcher右侧是对Stack Trace Frames数据进行的一些操作，Fingerprint Rules的Matcher右侧直接就是需要指定的Fingerprint的值，可以是一些写死的<strong>常量</strong>，也可以是一些<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">内置的变量（Variables）</a>。</p>
<p>下面的例子就是把Error类型的Event根据type和value进行分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把 DatabaseUnavailable 和 ConnectionError 这两种类型的 Error，都标记为 system-down</span><br><span class="line">error.type:DatabaseUnavailable -&gt; system-down</span><br><span class="line">error.type:ConnectionError -&gt; system-down</span><br><span class="line"></span><br><span class="line"># 把 Error message 中，包含“connection error: ”的，都标记为 connection-error，同时把当时 Error 的 transaction 字段也拼接到 Fingerprint 中</span><br><span class="line">error.value:&quot;connection error: *&quot; -&gt; connection-error, &#123;&#123; transaction &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-Matchers"><a href="#4-1-Matchers" class="headerlink" title="4.1 Matchers"></a>4.1 Matchers</h4><p>对于Matchers，Sentry允许使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Glob_(programming)">glob patterns</a>语法。Sentry包含了以下的这些Matcher：</p>
<ul>
<li>error.type<br>匹配Error的type（name），对应的是JSON中的<code>metadata.type</code>，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.type:ZeroDivisionError -&gt; zero-division</span><br><span class="line">error.type:ConnectionError -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>error.value<br>匹配Error的value（message），对应的是JSON中的<code>metadata.value</code>，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error.value:&quot;connection error (code: *)&quot; -&gt; connection-error</span><br><span class="line">error.value:&quot;could not connect (*)&quot; -&gt; connection-error</span><br></pre></td></tr></table></figure>

<ul>
<li>message<br>匹配日志消息，对应的是JSON中的<code>message</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message:&quot;system encountered a fatal problem: *&quot; -&gt; fatal-log</span><br></pre></td></tr></table></figure>

<ul>
<li>logger<br>匹配当前的logger的名称，对应的是JSON中的<code>logger</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.mypackage.*&quot; -&gt; mypackage-logger</span><br></pre></td></tr></table></figure>

<ul>
<li>level<br>匹配当前Event的日志级别，对应的是JSON中的<code>level</code>字段，允许使用通配符，大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:&quot;com.myapp.FooLogger&quot; level:&quot;error&quot; -&gt; mylogger-error</span><br></pre></td></tr></table></figure>

<ul>
<li>tags.tag_name<br>匹配某个tag，某个标签名，允许使用通配符。<br>这里的tag_name，对应的是JSON中的<code>tags</code>字段中，每一项的名字。tags是一个数字，代表多个标签，每一项是一个标签，每个标签也是一个数字，数组有两个元素，第一个元素是标签名，即tag_name，第二个是标签值。例如下面这样：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iPhone10,2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;device.family&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS 16.1.2&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;os.name&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iOS&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;environment&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;release&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dev-v3.24&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">      <span class="string">&quot;3.24.1023&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags.release:&quot;dev-v3.x&quot; -&gt; dev-v3-error</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.abs_path<br>匹配调用栈帧的绝对路径，对应的是每一帧中的<code>abs_path</code>字段，允许使用通配符，且大小写不敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.abs_path:&quot;**/my-utils/*.js&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.module<br>匹配调用栈帧的模块名，对应的是每一帧中的<code>module</code>字段，允许使用通配符，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.module:&quot;*/my-utils/*&quot; -&gt; my-utils, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.function<br>匹配调用栈帧的方法名，对应的是每一帧中的<code>function</code>字段，大小写敏感：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;my_assertion_failed&quot; -&gt; my-assertion-failed</span><br></pre></td></tr></table></figure>

<ul>
<li>stack.package<br>匹配当前帧所在的<code>package</code>，允许使用通配符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.package:&quot;**/libcurl.dylib&quot; -&gt; libcurl</span><br><span class="line">stack.package:&quot;**/libcurl.so&quot; -&gt; libcurl</span><br></pre></td></tr></table></figure>

<ul>
<li>family<br>通常用来缩小匹配范围，且通常和其他Matcher一起使用，目前包含以下值：<ul>
<li>javascript，任何来自于JavaScript的Event</li>
<li>native，任何来自于Native的Event</li>
<li>other，其他任何Event</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family:native !stack.module:&quot;myproject::*&quot; -&gt; not-from-my-project</span><br></pre></td></tr></table></figure>

<ul>
<li>app<br>匹配当前帧是否是在app内，通常和其他Matcher一起使用，包含yes和no两个值，对应的是每一帧中的in_app字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:yes stack.function:&quot;assert&quot; -&gt; assert</span><br></pre></td></tr></table></figure>

<p>更多关于Matchers的信息，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#matchers">Matchers</a>。</p>
<h4 id="4-2-Variables"><a href="#4-2-Variables" class="headerlink" title="4.2 Variables"></a>4.2 Variables</h4><p>在一条Fingerprint Rule的右侧，就是Variables，这里其实不只可以是变量，也可以是一些写死的常量。</p>
<p>对于变量来说，它们和Matchers的名字一样，并且会自动把变量对应的原始的值填入，用于生成Fingerprint。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.function:&quot;evaluate_script&quot; -&gt; script-evaluation, &#123;&#123; error.type &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这条规则会匹配调用栈中方法名为<code>evaluate_script</code>的Error，并且会把常量<code>script-evaluation</code>和当前Error的type（name）作为一部分，一起生成Fingerprint。</p>
<p>例如，<code>[&quot;script-evaluation&quot;, &quot;ReferenceError&quot;]</code></p>
<p>或者，<code>[&quot;script-evaluation&quot;, &quot;TypeError&quot;]</code></p>
<p>其他的变量和Matchers的名字一样，都是使用<code>&#123;&#123; &#125;&#125;</code>包裹起来的，详见<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/fingerprint-rules/#variables">Variables</a>。</p>
<h4 id="4-3-自定义标题"><a href="#4-3-自定义标题" class="headerlink" title="4.3 自定义标题"></a>4.3 自定义标题</h4><p>在设置Fingerprint Rules时，我们往往是想要按照自己的规则对Event进行分组，但是Event通常都是使用type和value来作为标题展示在Sentry中的，如果只改了Fingerprint Rules，那么原始的Event标题可能不那么友好，或者具有一定的误导性。</p>
<p>这个时候，我们可以在添加Fingerprint Rules的时候，额外添加title字段，即可设置这个分组的标题。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger:my.package.* level:error -&gt; error-logger, &#123;&#123; logger &#125;&#125; title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>自定义标题前：</strong></p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_before_rename.png" alt="自定义标题前"></p>
<p><strong>自定义标题后：</strong></p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/issue_after_rename.png" alt="自定义标题后"></p>
<p>在设置了自定义标题后，就可以在Error的原始JSON数据中看到title发生了变化：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/title_changed_in_json.png" alt="自定义标题后的JSON"></p>
<blockquote>
<p><strong>🔔 注意：</strong></p>
<p>只有比较新的版本（比如Sentry 23.x）才支持设置自定义的title在旧版本的Sentry中（比如Sentry 20.x），上面的写法会让Sentry把后面的<code>title=&quot;Error from Logger &#123;&#123; logger &#125;&#125;&quot;</code>认为是Fingerprint的一部分。</p>
<p>具体是哪个版本开始支持的我没在网上查到，如果你私有部署的Sentry版本发现不支持，可以尝试升级一下版本。</p>
</blockquote>
<h4 id="4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules"><a href="#4-4-怎么确定有没有匹配上自定义的Fingerprint-Rules" class="headerlink" title="4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?"></a>4.4 怎么确定有没有匹配上自定义的Fingerprint Rules?</h4><p>在添加了自定义的Fingerprint Rules之后，我们如何确定某个Event有没有命中呢？</p>
<p>其实我们直接查看对于的JSON数据即可，如果匹配上的话，会看到下图这样：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/finger_print_in_json.png" alt="匹配上的JSON"></p>
<p>我们可以在_fingerprint_info中看到当前Event的各种信息</p>
<ul>
<li><code>client_fingerprint</code>，对应的是这个Event的SDK Fingerprint（下面会讲到，当前Event没有设置SDK Fingerprint，所以为default）</li>
<li><code>matched_rule</code>，对应的是Fingerprint Rules，比如这里显示当前Event命中的Matchers是哪个，以及当前Matchers设置的Fingerprint，还有我们自定义的title</li>
</ul>
<p>同时下面的<code>fingerprint</code>字段，也展示了当前Event最终的Fingerprint。</p>
<p>如果是旧版Sentry的话，这里就没有<code>_fingerprint_info</code>这个字段了，同时会把我们设置的title认为是Fingerprint的一部分，会是下面这样：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/old_version_custom_title_in_json.png" alt="旧版Sentry的JSON"></p>
<h3 id="5-SDK-Fingerprint"><a href="#5-SDK-Fingerprint" class="headerlink" title="5. SDK Fingerprint"></a>5. SDK Fingerprint</h3><p>如果上面说的Fingerprint Rules，不能满足我们的需要，那么我们可以使用SDK Fingerprint来更灵活地生成Fingerprint。</p>
<blockquote>
<p>从上面的Fingerprint Rules文档可以看到，Fingerprint Rules只有少部分Matchers支持设置通配符，所以可能没那么灵活。</p>
</blockquote>
<p>如果从上面的官方文档<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/">Issue Grouping | Sentry Documentation</a>中看，会发现文档里没有单独SDK Fingerprint的文档。</p>
<p>这是因为SDK Fingerprint是针对不同的Sentry SDK的，不同的项目会使用不同的Sentry SDK。每个SDK中设置Fingerprint的方式都不一样，甚至可能部分SDK不支持设置Fingerprint。所以要针对不同的平台，查看各自平台的SDK文档，这里以JavaScript Sentry SDK为例<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/javascript/usage/sdk-fingerprinting/">SDK Fingerprinting for Browser JavaScript</a>。</p>
<p><em>更多平台请看这里：<a target="_blank" rel="noopener" href="https://docs.sentry.io/platforms/">Platforms</a></em></p>
<p>官网文档提供了比较友好的三个例子：</p>
<h4 id="5-1-基础示例"><a href="#5-1-基础示例" class="headerlink" title="5.1 基础示例"></a>5.1 基础示例</h4><p>单独处理某个上报Event的Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">method, path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(method, path, options).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    Sentry.withScope(<span class="function"><span class="keyword">function</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// group errors together based on their request and response</span></span><br><span class="line">      scope.setFingerprint([method, path, <span class="built_in">String</span>(err.statusCode)]);</span><br><span class="line">      Sentry.captureException(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用变量替换，把一些Fingerprint Rules支持的变量填入，作为我们设置的Fingerprint的一部分，比如<code>&#123;&#123; default &#125;&#125;</code>，<code>&#123;&#123; stack.abs_path &#125;&#125;</code>，<code>&#123;&#123; error.type &#125;&#125;</code>等，详见上面提到的Fingerprint Rules变量。</p>
<h4 id="5-2-更细粒度地控制分组"><a href="#5-2-更细粒度地控制分组" class="headerlink" title="5.2 更细粒度地控制分组"></a>5.2 更细粒度地控制分组</h4><p>在原有的Fingerprint后拼接上自定义的一些字段，可以达到比默认的规则更细粒度的控制。</p>
<p>比如下面例子，进一步拆分Sentry创建的默认分组（由<code>&#123;&#123; default &#125;&#125;</code>表示），同时考虑错误对象的一些属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRPCError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message, functionName, errorCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The name of the RPC function that was called (e.g. &quot;getAllBlogArticles&quot;)</span></span><br><span class="line">    <span class="built_in">this</span>.functionName = functionName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For example a HTTP status code returned by the server.</span></span><br><span class="line">    <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MyRPCError) &#123;</span><br><span class="line">      event.fingerprint = [</span><br><span class="line">        <span class="string">&quot;&#123;&#123; default &#125;&#125;&quot;</span>,</span><br><span class="line">        <span class="built_in">String</span>(exception.functionName),</span><br><span class="line">        <span class="built_in">String</span>(exception.errorCode),</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-3-完全重写Fingerprint"><a href="#5-3-完全重写Fingerprint" class="headerlink" title="5.3 完全重写Fingerprint"></a>5.3 完全重写Fingerprint</h4><p>还可以直接整个重写Fingerprint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnectionError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event, hint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exception = hint.originalException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DatabaseConnectionError) &#123;</span><br><span class="line">      event.fingerprint = [<span class="string">&quot;database-connection-error&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-和Fingerprint-Rules怎么划分职责？"><a href="#5-4-和Fingerprint-Rules怎么划分职责？" class="headerlink" title="5.4 和Fingerprint Rules怎么划分职责？"></a>5.4 和Fingerprint Rules怎么划分职责？</h4><p>Fingerprint Rules和SDK Fingerprint都可以实现相同的功能，那么我们在设置自定义Fingerprint的时候，要怎么取舍，或者说什么时候用Fingerprint Rules，什么时候用SDK Fingerprint？</p>
<p><strong>Fingerprint Rules：</strong></p>
<ul>
<li>优势：<ul>
<li>可以随时修改规则，不需要进行代码的变更</li>
<li>可以同时在线上所有版本生效</li>
</ul>
</li>
<li>劣势：<ul>
<li>没有SDK Fingerprint灵活，有些处理不了，比如error.type不支持通配符匹配</li>
</ul>
</li>
</ul>
<p><strong>SDK Fingerprint：</strong></p>
<ul>
<li>优势：<ul>
<li>灵活，可以用JS很方便地处理或者自定义Fingerprint</li>
</ul>
</li>
<li>劣势：<ul>
<li>需要修改代码</li>
<li>分组规则和代码版本耦合，如果应用需要用户手动升级的话，那么旧版本应用内的Sentry上报没办法处理</li>
</ul>
</li>
</ul>
<p>从上面的优劣对比来看，可以看到<strong>Fingerprint Rules和SDK Fingerprint是优劣互补的，一方的优势恰好是另一方的劣势</strong>。</p>
<p>对比下来，我们在项目中使用的时候，建议<strong>如果可以使用Fingerprint Rules实现的，都用Fingerprint Rules，只有在Fingerprint Rules无法满足的情况下，再用考虑使用SDK Fingerprint</strong>。</p>
<h3 id="6-Filter"><a href="#6-Filter" class="headerlink" title="6. Filter"></a>6. Filter</h3><p>上面说了这么多关于Issue分组的，那么对于一些我完全不想要的上报，有没有办法完全不分组，直接过滤掉呢？</p>
<p>也是有的，可以在Sentry平台上，直接设置一些Filter过滤器来过滤，而不需要我们手动在使用SDK的地方修改。</p>
<p>具体设置位置为：<strong>Settings &gt; Project &gt; [Your Project] &gt; Processing &gt; Inbound Filters</strong>。</p>
<p>过滤器分为内置的一些过滤器，和自定义的过滤器。</p>
<h4 id="6-1-内置过滤器"><a href="#6-1-内置过滤器" class="headerlink" title="6.1 内置过滤器"></a>6.1 内置过滤器</h4><p>Sentry平台内置了一些可以直接启用的过滤器，这些过滤器包括：</p>
<ul>
<li>浏览器拓展插件的error</li>
<li>来自于localhost的event</li>
<li>已知的旧版浏览器错误，比如IE的</li>
<li>已知的网络爬虫错误</li>
<li>React hydrate的报错（和React服务端渲染有关的错误）</li>
<li>……</li>
</ul>
<p>这些过滤器可能和不同版本的Sentry有关，比较旧的版本中，可能会缺少一些过滤器。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/built_in_filters.png" alt="内置过滤器"></p>
<h4 id="6-2-自定义过滤器"><a href="#6-2-自定义过滤器" class="headerlink" title="6.2 自定义过滤器"></a>6.2 自定义过滤器</h4><p>可以创建自定义过滤器，目前支持以下三种，以下三种在匹配时，都是大小写不敏感的。</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/custom_filters.png" alt="自定义过滤器"></p>
<h5 id="a-特定IP地址"><a href="#a-特定IP地址" class="headerlink" title="a. 特定IP地址"></a>a. 特定IP地址</h5><p>可以设置IP地址，过滤特定IP的错误上报，比如<code>127.0.0.1</code>。</p>
<h5 id="b-特定发布版本"><a href="#b-特定发布版本" class="headerlink" title="b. 特定发布版本"></a>b. 特定发布版本</h5><ul>
<li>发布版本，指的是在Sentry.init的时候，传入的release字段。</li>
<li>可以使用通配符，比如production-v3.24.*</li>
<li>如果某个Event不包含release字段，那么这个Event不会被过滤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">release</span>: <span class="string">`<span class="subst">$&#123;env&#125;</span>-<span class="subst">$&#123;version&#125;</span>`</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不确定自己项目上报后最终的<code>release</code>字段是什么，可以直接查看任意一个Error Event的原始JSON数据中的<code>release</code>字段（前提是init时传入了这个字段或者Event数据中有这个字段）</p>
<h5 id="c-Error-Message"><a href="#c-Error-Message" class="headerlink" title="c. Error Message"></a>c. Error Message</h5><ul>
<li>可以设置多个匹配项，每行一个。只要任意一个匹配项匹配成功，那么就会过滤这一条上报</li>
<li>对于Error类型的Event，会根据设置的匹配项，对格式为<code>&#123;exception.type&#125;: &#123;exception.value&#125;</code>的整个错误描述进行匹配。<br>但是不建议直接匹配整个描述，比如把冒号也加在里面，一般都是通过通配符来进行匹配。比如<code>*ConnectionError*</code></li>
<li>Transaction类型的Event，不会被过滤</li>
</ul>
<p>在设置完之后，可以检查下Issue的原始JSON数据，设置的过滤器会根据JSON里的<code>title</code>字段进行匹配，可以检查下是否有问题。</p>
<p>在设置好过滤器之后，我们就可以看到有多少Event被过滤掉了：</p>
<p><img src="https://static.youfindme.cn/blog/sentry_issue_grouping/filterd_issues.png" alt="过滤掉的Event"></p>
<h2 id="五、治理"><a href="#五、治理" class="headerlink" title="五、治理"></a>五、治理</h2><p>到这里我们已经搞明白Sentry对Issue分组的原理了，也知道了怎么自定义分组。那我们是使用Stack Trace Rules还是Fingerprint Rules来处理呢？</p>
<p>使用Stack Trace Rules本质上还是根据调用栈来进行分组，但是这就需要我们必须上传Source Maps。</p>
<p>在上传了Source Maps的情况下，可以通过设置调用栈Stack Trace Rules来<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#cut-stack-traces">裁切调用栈</a>，或者限制Sentry在生成调用栈Fingerprint的时候需要考虑的<a target="_blank" rel="noopener" href="https://docs.sentry.io/product/data-management-settings/event-grouping/stack-trace-rules/#stack-trace-frame-limits">top帧数量</a>。</p>
<p>考虑到目前我们的项目因为某种原因，还不能上传Source Maps，同时代码每个版本变化可能会导致同样的问题的调用堆栈信息不同。基于我们的需求来看，完全自定义的Fingerprint Rules更符合我们的情况。</p>
<p>所以我们的项目会做如下处理：</p>
<ul>
<li>在Sentry平台上设置Fingerprint Rules，处理绝大部分可以处理的Error</li>
<li>少部分Fingerprint Rules无法处理的Error（比如error.type不支持通配符），通过SDK Fingerprint，在代码中Sentry.init的时候，增加<code>beforeSend</code>进行处理</li>
<li>一些不需要关注的Error，设置Inbound Filters直接过滤</li>
</ul>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>一番调研下来，通过Fingerprint Rules，Stack Trace Rules，SDK Fingerprint，以及Inbound Filters，我们把项目的Issue进行了自定义分组，更方便我们排查问题，分析处理。</p>
<p>Sentry是一个简单易上手的监控平台，但是Sentry上也有许多十分复杂的配置项，这篇文章只是Sentry文档的一小部分，有哪里不正确的，还请多多指正。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8F%B2%EF%BC%9A%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0UTF-8/" class="post-title-link" itemprop="url">字符编码简史：从二进制到UTF-8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-11T00:00:00+08:00">2023-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 16:08:35" itemprop="dateModified" datetime="2023-12-28T16:08:35+08:00">2023-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>所谓<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码（Character encoding）</a>，就是把字符集中的字符，以某种指定的格式或规则，映射到另外一个集合中某一个值（相当于是把字符从一种形式转换成另一种形式），以便字符在计算机中存储或通过网络传递。</p>
<p>从计算机诞生到现在，对于字符的编码经历了多个阶段的变化，让我们一起来了解下字符编码的发展简史。</p>
</blockquote>
<h2 id="一、为什么聊这个"><a href="#一、为什么聊这个" class="headerlink" title="一、为什么聊这个"></a>一、为什么聊这个</h2><p>为什么会想要聊这个呢？这还得从开发中遇到的一个bug说起。</p>
<p>在一次开发中，由于要对一些字符串中的字符做一些高亮和截断，但是最开始只考虑了英文字符，单个字符的长度都是1，但是后续由于部分中文、emoji的加入，导致长度判断出了问题，出现了一些乱码。我们发现emoji的长度大多数为2甚至更长，比如“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span>.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这激起了我的一些好奇心，于是乎从头开始，完整了解了一下字符编码的发展简史。</p>
<h2 id="二、从二进制到各国编码"><a href="#二、从二进制到各国编码" class="headerlink" title="二、从二进制到各国编码"></a>二、从二进制到各国编码</h2><h3 id="1-二进制"><a href="#1-二进制" class="headerlink" title="1. 二进制"></a>1. 二进制</h3><p>我们都知道，由于电子管只有<code>开</code>和<code>关</code>这两种状态，所以计算机采用的是二进制来存储数据，也就是说所有的数据，最终都是以二进制的形式被计算机存储起来的。例如，a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示。</p>
<p>采用二进制可以更方便计算机进行运算，但是对于使用计算机的人类来说，就不那么方便了。为了方便人可以看懂计算机的二进制数据，需要<strong>设计一套规则来说明用哪些二进制数字表示哪个符号</strong>，这就是<strong>编码</strong>。</p>
<h3 id="2-ASCII"><a href="#2-ASCII" class="headerlink" title="2. ASCII"></a>2. ASCII</h3><p>为了防止不同的计算机使用不同的编码规则造成混乱，美国有关的标准化组织就推出了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII">ASCII编码（American Standard Code for Information Interchange，美国信息交换标准代码）</a>。</p>
<p>具体来说，ASCII编码一共规定了128个字符的编码，包括大小写英文字母、数字、常用符号，以及32个无法打印出来的控制符号。128个字符分别用数字<code>0 ~ 127</code>（十进制）来表示，对应的二进制为<code>0000 0000 ~ 0111 1111</code>。比如<code>a</code>对应是<code>97</code>（十进制），相应的二进制为<code>0110 0001</code>。</p>
<p>这样的话，任意英文都可以在计算机中用二进制表示了，比如“Hello world”这句话，在计算机中的表示就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100</span><br></pre></td></tr></table></figure>

<p>按理说128个字符，用7位二进制表示就够了（<em>2^7=128</em>），为什么要用8位二进制来表示呢。因为计算机里数据的计量单位是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节（byte）</a>，一个字节是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">8比特（bit）</a>，也就是8位，所以使用8位二进制（一个字节）来表示这128个字符，最前面的一位统一规定为0。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td><em>NUL</em></td>
<td><em>SOH</em></td>
<td><em>STX</em></td>
<td><em>ETX</em></td>
<td><em>EOT</em></td>
<td><em>ENQ</em></td>
<td><em>ACK</em></td>
<td><em>BEL</em></td>
<td><em>BS</em></td>
<td><em>HT</em></td>
<td><em>LF</em></td>
<td><em>VT</em></td>
<td><em>FF</em></td>
<td><em>CR</em></td>
<td><em>SO</em></td>
<td><em>SI</em></td>
</tr>
<tr>
<td>1x</td>
<td><em>DLE</em></td>
<td><em>DC1</em></td>
<td><em>DC2</em></td>
<td><em>DC3</em></td>
<td><em>DC4</em></td>
<td><em>NAK</em></td>
<td><em>SYN</em></td>
<td><em>ETB</em></td>
<td><em>CAN</em></td>
<td><em>EM</em></td>
<td><em>SUB</em></td>
<td><em>ESC</em></td>
<td><em>FS</em></td>
<td><em>GS</em></td>
<td><em>RS</em></td>
<td><em>US</em></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td><em>DEL</em></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>是空格。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>表示不同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII#%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">控制字符</a>。</p>
<h3 id="3-编码的“战国时期”"><a href="#3-编码的“战国时期”" class="headerlink" title="3. 编码的“战国时期”"></a>3. 编码的“战国时期”</h3><p>ASCII码是美国人发明的，对于只用英文的美国人来说，ASCII码其实就够用了，但是在计算机传到欧洲时情况就有变化了。虽然很多欧洲国家的语言中也是包含26个英文字母，但是很多国家还会包含一些带有声调或者其他附加符号的字母或者其他字母，如<code>À</code>、<code>Ö</code>等。对于这些字母，ASCII码无法表示。</p>
<h4 id="3-1-Latin-1"><a href="#3-1-Latin-1" class="headerlink" title="3.1 Latin-1"></a>3.1 Latin-1</h4><p>在这种背景下，欧洲推出了自己的一种编码，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1编码（又叫做ISO/IEC 8859-1）</a>。这个编码以ASCII为基础，使用了ASCII码中没有用到的第一位，在空置的<code>0xA0 ~ 0xFF</code>（即十进制的<code>160 ~ 255</code>，二进制的<code>1010 0000 ~ 1111 1111</code>）的范围内，加入96个字母及符号，以供使用附加符号的拉丁字母语言使用。</p>
<p>该编码的字符集如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>x0</th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>x4</th>
<th>x5</th>
<th>x6</th>
<th>x7</th>
<th>x8</th>
<th>x9</th>
<th>xA</th>
<th>xB</th>
<th>xC</th>
<th>xD</th>
<th>xE</th>
<th>xF</th>
</tr>
</thead>
<tbody><tr>
<td>0x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2x</td>
<td><em>SP</em></td>
<td>!</td>
<td>“</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&amp;</td>
<td>‘</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
</tr>
<tr>
<td>3x</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td>&lt;</td>
<td>=</td>
<td>&gt;</td>
<td>?</td>
</tr>
<tr>
<td>4x</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>5x</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
</tr>
<tr>
<td>6x</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>7x</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td><em>NBSP</em></td>
<td>¡</td>
<td>¢</td>
<td>£</td>
<td>¤</td>
<td>¥</td>
<td>¦</td>
<td>§</td>
<td>¨</td>
<td>©</td>
<td>ª</td>
<td>«</td>
<td>¬</td>
<td><em>SHY</em></td>
<td>®</td>
<td>¯</td>
</tr>
<tr>
<td>Bx</td>
<td>°</td>
<td>±</td>
<td>²</td>
<td>³</td>
<td>´</td>
<td>µ</td>
<td>¶</td>
<td>·</td>
<td>¸</td>
<td>¹</td>
<td>º</td>
<td>»</td>
<td>¼</td>
<td>½</td>
<td>¾</td>
<td>¿</td>
</tr>
<tr>
<td>Cx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">À</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">Á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">Â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">Ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">Ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">Å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">Æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">Ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">È</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">É</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">Ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">Ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">Ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">Í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">Î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">Ï</a></td>
</tr>
<tr>
<td>Dx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">Ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">Ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">Ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">Ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">Ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">Õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">Ö</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%97">×</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">Ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">Ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">Ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">Û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">Ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">Ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">Þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9F">ß</a></td>
</tr>
<tr>
<td>Ex</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%80">à</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%81">á</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%82">â</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%83">ã</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%84">ä</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%85">å</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%86">æ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%87">ç</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%88">è</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%89">é</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8A">ê</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8B">ë</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8C">ì</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8D">í</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8E">î</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%8F">ï</a></td>
</tr>
<tr>
<td>Fx</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%90">ð</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%91">ñ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%92">ò</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%93">ó</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%94">ô</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%95">õ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%96">ö</a></td>
<td>÷</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%98">ø</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%99">ù</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9A">ú</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9B">û</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9C">ü</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9D">ý</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C3%9E">þ</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%C5%B8">ÿ</a></td>
</tr>
</tbody></table>
<p>在上表中，<code>0x20</code>（32）是空格、<code>0xA0</code>（160）是不换行空格、<code>0xAD</code>是选择性连接号。<code>0x00 ~ 0x1F</code>、<code>0x7F</code>、<code>0x80 ~ 0x9F</code>在此字符集中没有定义（控制字符是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C0%E4%B8%8EC1%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">ISO/IEC 6429</a>定义）。</p>
<h4 id="3-2-其他欧洲字符集"><a href="#3-2-其他欧洲字符集" class="headerlink" title="3.2 其他欧洲字符集"></a>3.2 其他欧洲字符集</h4><p>可是只有Latin-1还是不够，上面这个字符集只能用来表示<strong>西欧</strong>的字符，对于中欧、北欧，以及包括俄文在内的斯拉夫语族的字符都不包含在内，于是乎各个地区的国家，又陆续以同样的方式，使用ASCII编码中没有使用到的第一位进行拓展，产生了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-2">Latin-2</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-3">Latin-3</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-4">Latin-4</a>等等欧洲地区的其他Latin编码，这些编码后来统一定义在了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859">ISO/IEC 8859标准</a>里，并且分别命名为ISO/IEC 8859-1、ISO/IEC 8859-2等。</p>
<p>这些编码虽然很好地支持了不同的国家的语言，但是在不同国家之间的兼容性上，可以说是几乎没有。由于它们都是基于ASCII进行拓展，占用了ASCII未使用到的第一位，所以对于<code>0x7F</code>（十进制<code>0111 1111</code>）之后的字符，同样的二进制数，在不同国家地区代表了不同的字符。某个国家的文件在另一个国家打开，一般情况下看到的都是乱码。</p>
<h4 id="3-3-亚洲地区的编码"><a href="#3-3-亚洲地区的编码" class="headerlink" title="3.3 亚洲地区的编码"></a>3.3 亚洲地区的编码</h4><p>同时随着计算机在亚洲的流行，像中文、日文、韩文这种动则几千上万字符的语言，都基于ASCII增加或者自创了自己的编码，比如中文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GB_2312">GB2312</a>编码，日文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Shift_JIS">Shift_JIS</a>等。</p>
<p>由于越来越多的编码出现，电脑上一份文件要想展示正确的内容，<strong>需要电脑包含所有这些不同的字符集，并且采用正确的方式打开</strong>，否则看到的将会是乱码。这也就是乱码产生的本质，即使用了错误的编码方式/字符集来展示某个文件。</p>
<p>为了解决这个问题，Unicode编码出现了。</p>
<h2 id="三、Unicode：万国码"><a href="#三、Unicode：万国码" class="headerlink" title="三、Unicode：万国码"></a>三、Unicode：万国码</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode">Unicode，又叫做万国码</a>，其官方机构Unicode联盟整理、编码了世界上大部分的文字系统，使得电脑能以通用划一的字符集来处理和显示文字。目前最新的版本为2022年9月公布的15.0.0，已经收录超过14万个字符。</p>
<h3 id="1-码位"><a href="#1-码位" class="headerlink" title="1. 码位"></a>1. 码位</h3><p>Unicode编码从0开始，为每一个字符分配一个唯一的编号，这个编号就叫做<strong>码位（code point，也叫码点）</strong>，以“计算机”的“机”字举例，“机”的码位为<code>26426</code>（十进制），即Unicode字符集中第26426个字符，就是“机”。</p>
<p>但是在表示一个Unicode的字符时，通常会用<code>U+</code>然后紧接着一组十六进制的数字来表示这一个字符。也就是说，“机”在Unicode中的表示方式是<code>U+673A</code>，码位是<code>673A</code>。</p>
<p>Unicode为了和已有的编码方式相互兼容，其首256个字符保留给ISO/IEC 8859-1所定义的字符（Latin-1编码），使既有的西欧语系文字（包括英文）的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。</p>
<h3 id="2-平面"><a href="#2-平面" class="headerlink" title="2. 平面"></a>2. 平面</h3><p>对于不同国家数十万的字符，Unicode联盟显然不可能一下子就给出全部字符的码位定义，更何况现在的有些字符，在那个时候还没有出现。Unicode联盟把所有字符，分为了17组进行编排，每组称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">平面（Plane）</a>，而每平面拥有65536（即216）个代码位。</p>
<p>也就是说目前一共有17个平面，共计2^16 * 17（1114112）个码位，最多可以表示一百多万个字符。</p>
<table>
<thead>
<tr>
<th><strong>平面</strong></th>
<th><strong>始末字符值</strong></th>
<th><strong>名称</strong></th>
<th><strong>简称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">0号平面</a></td>
<td><code>U+0000 ~ U+FFFF</code></td>
<td><strong>基本多文种平面</strong></td>
<td><strong>BMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%80%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">1号平面</a></td>
<td><code>U+10000 ~ U+1FFFF</code></td>
<td><strong>多文种补充平面</strong></td>
<td><strong>SMP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%BA%8C%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">2号平面</a></td>
<td><code>U+20000 ~ U+2FFFF</code></td>
<td><strong>表意文字补充平面</strong></td>
<td><strong>SIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">3号平面</a></td>
<td><code>U+30000 ~ U+3FFFF</code></td>
<td><strong>表意文字第三平面</strong></td>
<td><strong>TIP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%9B%9B%E8%87%B3%E5%8D%81%E4%B8%89%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">4-13号平面</a></td>
<td><code>U+40000 ~ U+DFFFF</code></td>
<td>（尚未使用）</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">14号平面</a></td>
<td><code>U+E0000 ~ U+EFFFF</code></td>
<td><strong>特别用途补充平面</strong></td>
<td><strong>SSP</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">15号平面</a></td>
<td><code>U+F0000 ~ U+FFFFF</code></td>
<td>保留作为<strong>私人使用区（A区）</strong></td>
<td><strong>PUA-A</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%87%B3%E5%8D%81%E5%85%AD%E8%BC%94%E5%8A%A9%E5%B9%B3%E9%9D%A2">16号平面</a></td>
<td><code>U+100000 ~ U+10FFFF</code></td>
<td>保留作为<strong>私人使用区（B区）</strong></td>
<td><strong>PUA-B</strong></td>
</tr>
</tbody></table>
<p>其中我们常用的一些字符，都定义在了第一个平面里，即<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">基本多文种平面（Basic Multilingual Plane, BMP）</a>，或称<strong>基本平面</strong>或<strong>0号平面（Plane 0）</strong>。比如大部分的汉字，都是定义在<code>U+4E00 ~ U+9FFF</code>代表的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>内（我们上面所说的“机”，<code>U+673A</code>，也在里面）。</p>
<p>而除了基本平台其他的十六个平面，都叫做辅助平面，用来放一些不常用的字符（如扑克牌花色），或者已经被废弃的古文字（如甲骨文）等。还有一些用作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%81%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%8C%BA">私人使用区</a>，主要是指没有在Unicode标准中指定，而是由合作用户之间的私人协议决定其用途的编码区。</p>
<p>现在看起来只需要使用Unicode编码，就可以囊括所有的语言符号，再也不会有乱码的问题了，真美好。</p>
<h3 id="3-好像还有些事情要做"><a href="#3-好像还有些事情要做" class="headerlink" title="3. 好像还有些事情要做"></a>3. 好像还有些事情要做</h3><p>可是事情真的像预期的那边美好吗？</p>
<p>Unicode定义了字符的编码方式，但是没有定义这些编码的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a>。就是说Unicode编码虽然给每一个字符一个唯一的编码，解决了字符集不统一的情况，但是没有定义在计算机底层，要怎么存储或者传输每一个Unicode字符。</p>
<p>例如ASCII定义了用一个字节（8位二进制）来存储每个字符，GB2312是用两个字节来存储每个汉字，Unicode的每一个字符应该用多大的空间来存储呢？这就涉及到Unicode编码的实现方式了，或者称为Unicode转换格式。</p>
<h2 id="四、UTF"><a href="#四、UTF" class="headerlink" title="四、UTF"></a>四、UTF</h2><p>Unicode编码的实现方式称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><strong>Unicode转换格式（Unicode Transformation Format，简称为UTF）</strong></a>。由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式也有所不同，下面我们说几个经常听到的转换格式。</p>
<h3 id="0-码元"><a href="#0-码元" class="headerlink" title="0. 码元"></a>0. 码元</h3><p>在开始之前，先引入一个概念，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81#%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E4%BB%A3%E7%A0%81%E9%A1%B5%EF%BC%8C%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%98%A0%E5%B0%84">码元（Code Unit）</a>，是指一种编码转换格式中具有最短的二进制组合的单元，即字符占用的最少二进制位。比如上面说的ASCII编码，每个字符都是占用8位二进制，所以ASCII编码的码元是8。</p>
<h3 id="1-UTF-32"><a href="#1-UTF-32" class="headerlink" title="1. UTF-32"></a>1. UTF-32</h3><p>首先，最简单的就是，用一个能包含所有Unicode编码的空间，来存储每一个字符。Unicode目前一共有17个平面，共计216 * 17个码位。</p>
<p><strong><code>2^16 * 17 = 2^20 + 2^16</code></strong></p>
<p><strong><code>2^20 &lt; 2^20 + 2^16 &lt; 2^21</code></strong></p>
<p>只需要使用大于21位的二进制来存储就可以了，例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-32">UTF-32</a>编码，这个编码用32位（4个字节）的二进制来存储Unicode编码的字符，不算固定为<code>0</code>的首位数字，总计能表示 231个字符，够用了。</p>
<p>由于UTF-32可以表示的字符比Unicode所有字符还多，可以做到UTF-32的编码与字符的Unicode码位的数值完全一致。由于UTF-32种每个字符都是用用32位（4个字节）来表示，所以<strong>UTF-32的码元就是32</strong>。</p>
<p>还是以上面的“机”为例，它的码位是<code>U+673A</code>（即十六进制<code>0x673A</code>），那么它在UTF-32中的编码值为<code>0x0000673A</code>（因为总共有32位，4个字节，所以要在前面补上两个字节的0，凑够4字节）</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-32编码：</strong></td>
<td><code>0x0000 673A</code></td>
</tr>
<tr>
<td><strong>UTF-32编码的二进制形式：</strong></td>
<td><code>00000000 00000000 01100111 00111010</code></td>
</tr>
</tbody></table>
<p>看起来UTF-32挺好的，可以通过Unicode码位直接知道对应的UTF-32编码，查找编码是一个常数时间的操作。但是它有个巨大的缺陷，就是占用空间太大。</p>
<p>在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，一般只需要1-2个字节就可以表示，比如上面的“机”（<code>01100111 00111010</code>），只需要两个字节就可以表示，但是UTF-32中却占了4个字节。</p>
<p>对于纯英文的文本来说，这种情况更甚，比如字母<code>a</code>的码位为<code>0110 0001</code>，只需要一个字节，但是在UTF-32同样要用4个字节来表示，<code>00000000 00000000 00000000 01100001</code>。</p>
<p>这也就造成UTF-32所需空间接近UTF-16的两倍和UTF-8的四倍，空间浪费较多。所以UTF-32编码，目前基本没有人使用，甚至<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/#character-encodings">在HTML5标准中明确规定在HTML中禁止使用UTF-32编码</a>。</p>
<h3 id="2-UTF-16"><a href="#2-UTF-16" class="headerlink" title="2. UTF-16"></a>2. UTF-16</h3><h4 id="2-1-变长编码"><a href="#2-1-变长编码" class="headerlink" title="2.1 变长编码"></a>2.1 变长编码</h4><p>既然在大多数文本中，非基本平面的字符非常罕见，绝大多数常见字符都位于基本平面里，那么有没有一种更节省空间的实现方式？有，那就是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>。（当然这个是从现在这个时间点来看的，UTF-16设计出来的目的并不是为了解决UTF-32的问题，还涉及到一个UCS-2的编码实现方式，下面会讲到）</p>
<p>UTF-16是一个<strong>变长的编码转换格式</strong>，也就是说相比UTF-32这种固定长度（4字节）的来说，它的编码长度取决于字符在Unicode中的码位，可能是2个字节，有可能是4个字节。</p>
<p>根据上面的Unicode平面对应的码位，可以看到基本平面内的字符<code>U+0000 ~ U+FFFF</code>，长度最长只有2个字节。所以对于基本平面的字符，在UTF-16中用2个字节来表示。对于其他辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，则用4个字节来表示。由于UTF-16中字符最少要占用2个字节（16位），所以UTF-16的码元是16，即UTF-16中字符要么用1个码元来表示，要么用2个码元来表示。</p>
<p>以上面“计算机”中的“机”为例，“机”的码位是<code>U+673A</code>，位于基本平面内，用两个字节表示，这个时候它的UTF-16编码和它在Unicode中的码位是一样的，即<code>0x673A</code>，换成二进制就是<code>01100111 00111010</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>UTF-16 编码的二进制形式：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>这样在绝大多数情况下，用2个字节就可以存储或者表示字符，极少数情况下用到的辅助平面字符，才会用到4个字节的表示方式。</p>
<p>但是这样也会带来一个问题，计算机在读取字符的二进制时，比如读取了2个字节，要怎么知道这2个字节表示的是一个字符，还是说要再加上后面2个字节连起来组成一个字符呢？</p>
<h4 id="2-2-前导代理和后尾代理"><a href="#2-2-前导代理和后尾代理" class="headerlink" title="2.2 前导代理和后尾代理"></a>2.2 前导代理和后尾代理</h4><p>我们知道，需要用4个字节来表示的字符，都是位于16个辅助平面内的字符<code>U+10000 ~ U+10FFFF</code>，16辅助平面内的字符总用有220个：</p>
<p><strong><code>2^16 * 16 = 2^20</code></strong></p>
<p>这些辅助平面内的字符，相对于辅助平面内的第一个字符<code>U+10000</code>，偏移量分别是 0 ~ 2^20 - 1</p>
<p><strong><code>0x10000 - 0x10000 = 0</code></strong></p>
<p><strong><code>0x10FFFF - 0x10000 = 2^20 - 1</code></strong></p>
<p>只需要记录下每个辅助平面内字符<strong>相对于第一个辅助平面字符的偏移量</strong>，就可以知道每个字符在Unicode中的码位。</p>
<p>而220个数字只需要用20位长度的二进制就可以表示，20位长度的二进制拆分到4个字节里，每2个字节存储10位长度的二进制。</p>
<p>以<code>𐐷</code>这个字符为例，这个字符的码位是<code>U+10437</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code></td>
</tr>
</tbody></table>
<p>也就是说<code>𐐷</code>这个字符占4个字节，前2个字节是<code>00000000 00000001</code>，后2个字节是<code>00000000 00110111</code>。</p>
<p>但是到这里依然没有解决上面的问题，计算机在读取到前2个字节<code>00000000 00000001</code>时，不知道这表示的是<code>SOH</code>这个控制字符，还是说要和后面2个字节连起来，共同组成一个字符<code>𐐷</code>。因此，需要在<strong>基本平面</strong>中保留不对应任何Unicode字符的两个区域，用于标识UTF-16的4字节字符的前10位和后10位。这两个区域就是</p>
<table>
<thead>
<tr>
<th><code>0xD800 ~ 0xDBFF</code></th>
<th>容纳前10位的区域，区域大小为 210</th>
</tr>
</thead>
<tbody><tr>
<td><code>0xDC00 ~ 0xDFFF</code></td>
<td>容纳后10位的区域，区域大小为 210</td>
</tr>
</tbody></table>
<p>而只需要把上面的前10位<code>00000000 00000001</code>和后10位<code>00000000 00110111</code>，分别加上这两个区域的起始值，就是这个字符在UTF-16中真正的表示：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>𐐷</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+10437</code></td>
</tr>
<tr>
<td><strong>相对于</strong><code>0x10000</code><strong>的偏移量：</strong></td>
<td><code>0x10437 - 0x10000 = 0x00437</code></td>
</tr>
<tr>
<td><strong>偏移量的二进制表示：</strong></td>
<td><code>0000 0000 0100 0011 0111</code></td>
</tr>
<tr>
<td><strong>前10位：</strong></td>
<td><code>0000000001</code>, <code>0x0001</code></td>
</tr>
<tr>
<td><strong>后10位：</strong></td>
<td><code>0000110111</code>, <code>0x0037</code></td>
</tr>
<tr>
<td>**前10位 + **<code>0xD800</code><strong>：</strong></td>
<td><code>0xD800</code> + <code>0x0001</code> = <code>0xD801</code>, <code>11011000 00000001</code></td>
</tr>
<tr>
<td>**后10位 + **<code>0xDC00</code><strong>：</strong></td>
<td><code>0xDC00</code> + <code>0x0037</code> = <code>0xDC37</code>, <code>11011100 00110111</code></td>
</tr>
<tr>
<td><strong>UTF-16 中真正的表示：</strong></td>
<td><code>0xD801``0xDC37</code>，<code>11011000 00000001``11011100 00110111</code></td>
</tr>
</tbody></table>
<p>所以<code>𐐷</code>这个字符，在UTF-16中的真正表示为<code>0xD801</code> <code>0xDC37</code>，以二进制形式就是<code>11011000 00000001</code> <code>11011100 00110111</code>，前后各2个字节分别叫做这个字符的<strong>前导代理</strong>（lead surrogates）和<strong>后尾代理</strong>（trail surrogates），这个字符就是由这样一个<strong>代理对</strong>（Surrogate Pair）来表示。</p>
<h4 id="2-3-计算机读取"><a href="#2-3-计算机读取" class="headerlink" title="2.3 计算机读取"></a>2.3 计算机读取</h4><p>计算机在读取时，每读取2个字节，如果这两个字节范围处于<code>0xD800 ~ 0xDBFF</code>这个区域，那么就知道这2个字节，要和后面的2个字节连起来，共同组成一个字符。</p>
<p>以上面为例，在读取到<code>11011000 00000001</code>时，发现这个数字位于<code>0xD800 ~ 0xDBFF</code>，那么就知道<code>11011000 00000001</code>表示这个字符的前导代理而不是一个真正字符，需要再读取后2个字节里的后尾代理，具体步骤为：</p>
<ol>
<li>读取：<code>11011000 00000001</code> <code>11011100 00110111</code>，即<code>0xD801</code> <code>0xDC37</code></li>
<li>分别减去<code>0xD800</code>和<code>0xDC00</code>：<code>0x0001</code> <code>0x0037</code>，即<code>0000000001</code> <code>0000110111</code></li>
<li>组合起来就是<code>0000 0000 0100 0011 0111</code>，即<code>0x00437</code></li>
<li>也就是说字符相对于<code>0x10000</code>的偏移量是<code>0x00437</code>，或者换种说法，这个字符是辅助平面字符里的第<code>0x00437</code>个辅助平面字符</li>
<li>所以真正的码位是<code>0x10000 + 0x00437 = 0x10437</code>，即<code>U+10437</code>，所表示字符为<code>𐐷</code></li>
</ol>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>到这里UTF-16基本是说完了，看起来很复杂，但总结下来就三点：</p>
<ol>
<li>对于基本平面内的字符，用2个字节表示；对于其他辅助平面内的字符，用4个字节表示</li>
<li>对于辅助平面内的字符，拆成两半<ol>
<li>一半映射在<code>0xD800 ~ 0xDBFF</code>内</li>
<li>一半映射在<code>0xDC00 ~ 0xDFFF</code>内</li>
</ol>
</li>
<li>读取2个字节，如果发现这2个字节的码位处于<code>0xD800 ~ 0xDBFF</code>，那么就当做4字节字符处理，再读取后面的2个字节共同组成字符。否则就直接作为2字节字符</li>
</ol>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>既然UTF-16可以通过对字符做区分，不同字符使用不同长度的字节来表示，那应该有更加节省空间的变长编码转换格式才对。而<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</a>就是这样一个变长的编码转换格式。</p>
<h4 id="3-1-编码规则"><a href="#3-1-编码规则" class="headerlink" title="3.1 编码规则"></a>3.1 编码规则</h4><p>UTF-8从名字就可以知道，这是一种最小长度为8位二进制（即1个字节）的编码转换格式。使用 1 ~ 4 个字节来表示字符（1、2、3、4个字节都有可能），具体的规则如下：</p>
<table>
<thead>
<tr>
<th><strong>码位范围</strong></th>
<th><strong>字节数</strong></th>
<th><strong>Byte 1</strong></th>
<th><strong>Byte 2</strong></th>
<th><strong>Byte 3</strong></th>
<th><strong>Byte 4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000 ~ U+007F</code></td>
<td>1</td>
<td><code>0xxxxxxx</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0080 ~ U+07FF</code></td>
<td>2</td>
<td><code>110xxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0800 ~ U+FFFF</code></td>
<td>3</td>
<td><code>1110xxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
</tr>
<tr>
<td><code>U+10000 ~ U+10 FFFF</code></td>
<td>4</td>
<td><code>11110xxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
</tr>
</tbody></table>
<p>对于一个字符，首先确定其在Unicode中的码位，根据上面表格第一列，确定这个码位所属的范围所需要用到的字节。</p>
<ol>
<li>如果是单字节字符，那么这个字节首位为<code>0</code>，用剩下的7位来表示这个字符。可以看到，对于ASCII中的字符，在ASCII和UTF-8中的编码规则是一致的，也就是说UTF-8兼容ASCII编码</li>
<li>如果是多字节字符，假设是<code>n</code>字节字符，就在第一个字节开头用<code>n</code>个<code>1</code>来填充，第<code>n + 1</code>位用<code>0</code>填充，且后面的字节的前两个字符，都用<code>10</code>来填充。剩下的没有被填充的位，就是用来填充这个字符Unicode码位的二进制，从右向左填充，未填充满的用<code>0</code>补齐</li>
</ol>
<p>由于UTF-8中字符最少占据1个字节（8位），所以<strong>UTF-8的码元是8</strong>，即UTF-8中字符用 1 ~ 4 个码元来表示。<br>还是以上面的“计算机”的“机”为例：</p>
<ol>
<li>“机”的码位为<code>U+673A</code></li>
<li>根据上面的表格，处于<code>U+0800 ~ U+FFFF</code>这个范围内，所以要用3个字节来表示</li>
<li>也就是说格式为<code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>，<code>x</code>为这个字符码位二进制填充位</li>
<li><code>U+673A</code>的二进制为<code>110011100111010</code>，从右向左依次填充，得到：</li>
</ol>
<p><code>11100110</code> <code>10011100</code> <code>10111010</code><br>即字符“机”在UTF-8中的编码为<code>11100110 10011100 10111010</code>，用16进制表示为<code>0xE69CBA</code>。</p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码：</strong></td>
<td><code>0xE69CBA</code></td>
</tr>
<tr>
<td><strong>UTF-8 编码的二进制形式：</strong></td>
<td><code>11100110 10011100 10111010</code></td>
</tr>
</tbody></table>
<h4 id="3-2-真的最节省空间吗？"><a href="#3-2-真的最节省空间吗？" class="headerlink" title="3.2 真的最节省空间吗？"></a>3.2 真的最节省空间吗？</h4><p>UTF-8最小字节单位为 1 个字节，相比起UTF-16和UTF-32最小字节单位是 2 字节和 4 字节来说，确实是可以节省下不少空间。但是这个节省空间是相对的。</p>
<p>对于以拉丁字母作为主要语言的英语、西欧语言等来说，绝大多数情况下只需要 1 个字节或者 2 个字节就可以表示字符。对于这些语言来说，最节省空间的确实是UTF-8。但是对于很多亚洲国家来说，比如中日韩，却不是这样。</p>
<p>从上面的内容可以知道，对于中日韩这些文字来说，在UTF-16中，绝大多数文字都只需要 2 个字节就可以表示，但是在UTF-8中，却需要 3 个字节来表示，占用空间比UTF-16多出了 50%，这样看来，对于中日韩文字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">CJK</a>文字来说，最节省空间的反而是UTF-16编码了。</p>
<p>也就是说，哪种编码转换格式最节省空间是由字符内容决定的，UTF-8只有在英语等拉丁语言的情况下才是最节省空间的，但是对于亚洲地区来说，最合适的编码方式是UTF-16。</p>
<h3 id="4-Big-Endian-和-Little-Endian"><a href="#4-Big-Endian-和-Little-Endian" class="headerlink" title="4. Big Endian 和 Little Endian"></a>4. Big Endian 和 Little Endian</h3><p>其实除了上面说的内容，对于多字节的编码转换格式来说，还有一个 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%A4%A7%E7%AB%AF%E5%BA%8F">Big Endian（大端序，简称BE）</a>和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%B0%8F%E7%AB%AF%E5%BA%8F">Little Endian（小端序，简称LE）</a>的概念。因为这些多字节的编码中字符占用多个字节，在将字符二进制拆分成多个字节后，多个字节可能会有排列顺序的区分。</p>
<p>比如上面的“机”，UTF-16编码中会把码位二进制<code>01100111 00111010</code>放到两个字节里：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>机</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+673A</code></td>
</tr>
<tr>
<td><strong>码位十六进制：</strong></td>
<td><code>0x673A</code></td>
</tr>
<tr>
<td><strong>码位二进制：</strong></td>
<td><code>01100111 00111010</code></td>
</tr>
</tbody></table>
<p>那么在UTF-16 BE和UTF-16 LE中，编码分别为<code>01100111 00111010</code>和<code>00111010 01100111</code>，两个字节的顺序正好相反。</p>
<table>
<thead>
<tr>
<th><strong>UTF-16 BE 编码</strong></th>
<th><code>01100111 00111010</code></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><strong>UTF-16 LE 编码</strong></th>
<th><code>00111010 01100111</code></th>
</tr>
</thead>
</table>
<p>我们上面举例的一些字符，都是以BE的形式来表示的。这个其实没有一个优劣，更多是一种人们情绪化的选择，就好像鸡蛋应该从大的那头拨开还是小的那头拨开一样。感兴趣的可以看看这个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E7%AB%AF%EF%BC%88endian%EF%BC%89%E7%9A%84%E8%B5%B7%E6%BA%90">大小端问题的起源</a>。</p>
<h2 id="五、JavaScript中使用的编码"><a href="#五、JavaScript中使用的编码" class="headerlink" title="五、JavaScript中使用的编码"></a>五、JavaScript中使用的编码</h2><p>说了这么多，在JavaScript中使用的是哪种编码呢？</p>
<h3 id="1-编码格式"><a href="#1-编码格式" class="headerlink" title="1. 编码格式"></a>1. 编码格式</h3><p>其实JavaScript使用的是一个叫做UCS-2的编码，并不是上面的任何一种。UCS-2是一种<strong>定长</strong>的编码转换格式，用2个字节来表示字符，可以理解为是只能用来表示基本平面内字符的UTF-16，不能表示辅助平面内的字符。或者说<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTF-16#UTF-16%E8%88%87UCS-2%E7%9A%84%E9%97%9C%E4%BF%82">UTF-16是基于UCS-2的超集</a>。</p>
<p>同样的，Java和 Objective-C都是使用的是UCS-2。这些语言之所以选择这个编码转换格式，是因为在Unicode早期，大家都以为用2个字节就足够表示所有字符了，所以UCS-2使用了2字节定长编码，且字符编码和字符的Unicode码位的一样的，获取字符的开销是一个常数操作，对于需要处理字符串的编程语言来说是最合适的选择。</p>
<p>但是到后期随着Unicode的扩充，2字节定长编码的UCS-2无法满足需求，也就诞生了基于UCS-2的UTF-16编码，在基本平面内兼容UCS-2，同时通过可变的长度来支持辅助平面内字符。这些编程语言也基本过渡到了UTF-16上。</p>
<p>但是一些稍微新一些的编程语言，比如Python3，Go等，默认的编码转换格式都已经是UTF-8了。</p>
<h3 id="2-获取字符串长度"><a href="#2-获取字符串长度" class="headerlink" title="2. 获取字符串长度"></a>2. 获取字符串长度</h3><p>既然知道了JavaScript中的编码转换格式，那我们来试下获取字符长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.length;   <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.length;  <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.length;  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以发现，同样是一个字符，“a”和“机”的长度都是“1”，但是一个笑哭的emoji“😂”，长度却是2。这是为什么呢？<br><em><strong>因为获取字符串长度，本质上就是获取字符串在当前编码格式中占用的码元（Code Unit）数量。</strong></em><br>在UTF-16（UCS-2）中，码元为16（2个字节）：</p>
<ul>
<li>“a”和“机”都是<strong>基本平面</strong>内的字符，都可以用 2 个字节，即 1 个UTF-16码元来表示，所以长度是1</li>
<li>“😂”这个emoji的Unicode码位是<code>U+1F602</code>，已经超出了基本平面<code>U+0000 ~ U+FFFF</code>，是<strong>辅助平面</strong>内的字符，要用 4 个字节，即 2 个UTF-16码元来表示，所以长度是2</li>
</ul>
<p>Java和OC中执行结果也和上面一样。相应的，如果这些字符串放在默认编码方式为UTF-8的语言中，如Go，得到的长度就会是下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="string">&quot;a&quot;</span>)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;机&quot;</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;😂&quot;</span>)   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>这是因为在UTF-8中，码元为8（1个字节）：</p>
<ul>
<li>“a”，<code>U+0061</code>，是用 1 个字节表示，1个码元，所以长度是1</li>
<li>“机”，<code>U+673A</code>，用 3 个字节表示，即 3 个UTF-8码元，所以长度是3</li>
<li>“😂”，<code>U+1F602</code>，用 4 个字节表示，即 4 个UTF-8码元，所以长度是4</li>
</ul>
<p>所以，在一些前后端默认字符编码编码格式不一样的场景，比如前端（JS/Java/OC），后端Go，就可能会出现一些字符串长度判断不一致的情况（看到一篇<a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">文章</a>里就有遇到这种情况）。</p>
<h3 id="3-获取字符串中真正的字符个数"><a href="#3-获取字符串中真正的字符个数" class="headerlink" title="3. 获取字符串中真正的字符个数"></a>3. 获取字符串中真正的字符个数</h3><p>说了这么多，有没有办法在JS中获取到真正的字符个数呢，比如“😂”。有的，通过<code>Array.from(str)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;😂&#x27;</span>).length;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>再来看一个特殊情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>.length;                <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>).length;    <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;👩‍👩‍👧‍👧&#x27;</span>);           <span class="comment">// [&#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👩&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;, &#x27;‍&#x27;, &#x27;👧&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可以看到“👩‍👩‍👧‍👧”这个emoji，其实是由4个emoji组合到一起的，并且中间用了<code>U+200D</code>这个名字叫做“零宽度连字符”的字符来连接，这个字符的长度是1，所以这个emoji本质上是7个字符组合到一起的，<strong>总计7个字符</strong>，长度为：</p>
<p><strong><code>2 + 1 + 2 + 1 + 2 + 1 + 2 = 11</code></strong></p>
<p>我们也可以反向来试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;‍&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是空字符串</span></span><br><span class="line">[<span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👩&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>, <span class="string">&#x27;👧&#x27;</span>].join(<span class="string">&#x27;\u&#123;200D&#125;&#x27;</span>);        <span class="comment">// 👩‍👩‍👧‍👧 这里的 join 方法使用的是 U+200D</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其他一些和字符编码有关的方法和逻辑"><a href="#4-其他一些和字符编码有关的方法和逻辑" class="headerlink" title="4. 其他一些和字符编码有关的方法和逻辑"></a>4. 其他一些和字符编码有关的方法和逻辑</h3><h4 id="4-1-获取码位"><a href="#4-1-获取码位" class="headerlink" title="4.1 获取码位"></a>4.1 获取码位</h4><p>在JS中，想要获取一个字符的Unicode码位很简单，只需要通过<code>String.prototype.codePointAt()</code>即可获取码位的<strong>十进制值</strong>。<code>codePointAt</code>接受一个参数，可以用来获取指定码元处码位，不传则默认为<code>0</code>，即这个字符第一个码元处的码位的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>.codePointAt();    <span class="comment">// 97 (十进制)</span></span><br><span class="line"><span class="string">&#x27;机&#x27;</span>.codePointAt();   <span class="comment">// 26426</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt();   <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">0</span>);  <span class="comment">// 128514</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span>.codePointAt(<span class="number">1</span>);  <span class="comment">// 56834</span></span><br></pre></td></tr></table></figure>

<p>如果指定的这个码元位置的码位是UTF-16<strong>代理对的前导代理</strong>，那么就会返回这个字符完整的Unicode码位，否则就直接返回这个位置的码位，详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt">MDN</a>。</p>
<p>如上面<code>&#39;😂&#39;.codePointAt(0)</code>，因为“😂”这个字符在UTF-16中是用2个码元（4个字节）来表示的，根据规则组成这个字符的 2个码元是一个<strong>代理对</strong>，它的第一个码元是前导代理，所以直接返回了“😂”这个字符的完整Unicode码位<code>128514</code>，即<code>U+1F602</code>。</p>
<p>但是<code>&#39;😂&#39;.codePointAt(1)</code>，因为索引为1的码元，是一个后尾代理，所以直接返回了这个后尾代理的码位<code>56834</code>，即<code>U+DE02</code>。而“😂”的在UTF-16中的完整编码格式为<code>U+D83D</code> <code>U+DE02</code>：</p>
<table>
<thead>
<tr>
<th><strong>字符：</strong></th>
<th><code>😂</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>码位：</strong></td>
<td><code>U+1F602</code></td>
</tr>
<tr>
<td><strong>前导代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>后尾代理：</strong></td>
<td><code>U+DE02</code></td>
</tr>
<tr>
<td><strong>UTF-16 BE 中的表示：</strong></td>
<td><code>U+D83D</code> <code>U+DE02</code></td>
</tr>
</tbody></table>
<h4 id="4-2-用码位表示字符"><a href="#4-2-用码位表示字符" class="headerlink" title="4.2 用码位表示字符"></a>4.2 用码位表示字符</h4><p>JS中是允许用码位来表示字符的，表示方式是<code>\u&#123;xxxx&#125;</code>，即反斜杠 + u + 花括号，花括号内为16进制的码位。又由于JS使用的是UTF-16，所以在JS中可以用下面的方式来表示“😂”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span>;                 <span class="comment">// true Unicode码位表示</span></span><br><span class="line"><span class="string">&#x27;😂&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;          <span class="comment">// true UTF-16编码格式表示</span></span><br><span class="line"><span class="string">&#x27;\u&#123;1F602&#125;&#x27;</span> === <span class="string">&#x27;\u&#123;D83D&#125;\u&#123;DE02&#125;&#x27;</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-直接查看文件中字符的二进制"><a href="#4-3-直接查看文件中字符的二进制" class="headerlink" title="4.3 直接查看文件中字符的二进制"></a>4.3 直接查看文件中字符的二进制</h4><p>说了这么多，都是在讲解，那有什么办法直接查看某个字符或者字符串的二进制编码呢？最简单的我们可以通过一些文本编辑器来看，比如sublime。还是以“机”和“𐐷”为例。</p>
<p>在sublime中输入一个字符，然后以某种编码格式保存，我们这里分别用UTF-8，UTF-16 BE，UTF-16 LE来保存：</p>
<p><img src="https://static.youfindme.cn/blog/character_encoding/save_by_sublime.png" alt="save_by_sublime.png"></p>
<p>然后打开终端，通过<code>xbb -b</code>命令分别查看三个文件的二进制内容：</p>
<p><img src="https://static.youfindme.cn/blog/character_encoding/show_binary.png" alt="show_binary.png"></p>
<p>可以看到二进制内容，和上面讲到的是完全一致的。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>到这里基本上已经说完了，字符编码从二进制，到ASCII问世，到Latin-1、2、3…，再到GB2312、Shift_JIS的“战国时代”，直到最后Unicode万国码“一统天下”。而随Unicode诞生的，还有UTF-32、UTF-16、UTF-8、UCS-2等。</p>
<p>可以看到一个小的字符编码引起的Bug，后面可以挖出这么多，有时候日常开发中不那么起眼的一些点，后面也有很多有趣的内容。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>感谢下面这些参考链接的作者，看这些文章收获很多！</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">Wikipedia 字符编码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode与JavaScript详解 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_37967865/article/details/103311765">计算机编码发展历史和编码方式_计算机最早的编码方式_cacho_37967865的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://fehey.com/emoji-length">‘👩‍👩‍👧‍👧’.length === 11 ? Emoji 有多长</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimojianghu/p/16205678.html">前端开发中需要搞懂的字符编码知识 - jimojianghu - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.xxkid.com/post/e5b12a4a.html">JS 判断带 emoji 的字符串长度的究极方法 - 小小孩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/p/27990849">程序的逻辑 (6) 编码的本质与乱码的恢复</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346662618">《JavaScript 权威指南》解读——字符串是 16 位值的序列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34281537/article/details/92508414">Javascript中的string类型使用UTF-16编码_weixin_34281537的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/308677093">Java 为什么使用 UTF-16 而不是更节省内存的 UTF-8？ - 知乎</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/13/%E8%81%8A%E8%81%8A%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%EF%BC%88Dark%20Mode%EF%BC%89/" class="post-title-link" itemprop="url">聊聊深色模式（Dark Mode）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 10:29:00" itemprop="dateCreated datePublished" datetime="2023-03-13T10:29:00+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-02 20:36:19" itemprop="dateModified" datetime="2024-01-02T20:36:19+08:00">2024-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是深色模式"><a href="#什么是深色模式" class="headerlink" title="什么是深色模式"></a>什么是深色模式</h2><p>深色模式（Dark Mode），或者叫暗色模式，黑夜模式，是和日常使用的浅色（亮色）模式（Light Mode）相对应的一种UI主题。</p>
<p>深色模式最早来源于人机交互领域的研究和实践，从2018年左右开始，Apple推出了<strong>iOS 13</strong>，其中包含了系统级别的深色模式，可以将整个系统的界面切换为暗色调。</p>
<p>Google也在<strong>Android 10</strong>中推出了类似的深色模式功能，使深色模式得到了更广泛的应用和推广。</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/dark_mode_example.png" alt="iOS官网的深色模式示例"></p>
<p>它不是简单的把背景变为黑色，文字变为白色，而是一整套的配色主题，这种模式相比浅色模式更加柔和，可以减少亮度对用户眼睛造成的刺激和疲劳。</p>
<p>随着越来越多的应用开始支持深色模式，作为开发也理应多了解下深色模式。</p>
<h2 id="首先，怎么打开深色模式"><a href="#首先，怎么打开深色模式" class="headerlink" title="首先，怎么打开深色模式"></a>首先，怎么打开深色模式</h2><p>在说怎么实现之前，先来说说我们要怎么打开深色模式，一般来说只需要在系统调节亮度的地方就可以调节深色模式，具体我们可以看各个系统的官方网站即可：<br>如何打开深色模式</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT210332">在 iPhone 和 iPad 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.apple.com/zh-cn/HT208976">在 Mac 上使用深色模式 - 官方 Apple 支持 (中国)</a></li>
<li><a target="_blank" rel="noopener" href="https://support.google.com/android/answer/9730472?hl=zh-Hans">在 Android 设备上更改为深色模式或颜色模式 - Android帮助</a></li>
<li><a target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9B%B4%E6%94%B9%E9%A2%9C%E8%89%B2-d26ef4d6-819a-581c-1581-493cfcc005fe">在 Windows 中更改颜色 - Microsoft 支持</a></li>
</ul>
<p>但是在开发调试调试时，不断切换深色模式可能比较麻烦，这时浏览器就提供了一种模拟系统深色模式的方法，可以让当前的Web页面临时变为深色模式，以Chrome为例：<br>浏览器模拟深色/浅色模式</p>
<ol>
<li>打开Chrome DevTools</li>
<li><code>Command</code>+<code>Shift</code>+<code>P</code></li>
<li>输入dark或者light</li>
<li>打开深色或者浅色模式<img src="https://static.youfindme.cn/blog/dark_mode/open_dark_mode_in_devtool.png" alt="打开深色模式"><br><img src="https://static.youfindme.cn/blog/dark_mode/open_light_mode_in_devtool.png" alt="打开浅色模式"></li>
</ol>
<p>不过要注意的是，浏览器DevTools里开启深色模式，在关闭开发者工具后就会失效。</p>
<h2 id="自动适配-声明页面支持深色模式"><a href="#自动适配-声明页面支持深色模式" class="headerlink" title="自动适配 - 声明页面支持深色模式"></a>自动适配 - 声明页面支持深色模式</h2><p>其实，在支持深色模式的浏览器中，有一套默认的深色模式，只需要我们在应用中声明，即可自动适配深色模式，声明有两种方式：</p>
<h3 id="1-添加color-scheme的meta标签"><a href="#1-添加color-scheme的meta标签" class="headerlink" title="1. 添加color-scheme的meta标签"></a>1. 添加<code>color-scheme</code>的<code>meta</code>标签</h3><p>在HTML的<code>head</code>标签中增加<code>color-scheme</code>的<code>meta</code>标签，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">	and the page author prefers light.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;color-scheme&quot;</span> <span class="attr">content</span>=<span class="string">&quot;light dark&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上述声明，告诉浏览器这个页面支持深色模式和浅色模式，并且页面更倾向于浅色模式。在声明了这个之后，当系统切换到深色模式时，浏览器将会把我们的页面自动切换到默认的深色模式配色，如下所示：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<h3 id="2-在CSS里添加color-scheme属性"><a href="#2-在CSS里添加color-scheme属性" class="headerlink" title="2. 在CSS里添加color-scheme属性"></a>2. 在CSS里添加<code>color-scheme</code>属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The page supports both dark and light color schemes,</span></span><br><span class="line"><span class="comment">  and the page author prefers light.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面在<code>:root</code>元素上添加<code>color-scheme</code>属性，值为<code>light dark</code>，可以实现和<code>meta</code>标签一样的效果，同时这个属性不只可用于<code>:root</code>级别，也可用于单个元素级别，比<code>meta</code>标签更灵活。</p>
<p>但是提供<code>color-scheme</code>CSS属性需要首先下载CSS（如果通过<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>引用）并进行解析，使用<code>meta</code>可以更快地使用所需配色方案呈现页面背景。两者各有优劣吧。</p>
<h2 id="自定义适配"><a href="#自定义适配" class="headerlink" title="自定义适配"></a>自定义适配</h2><h3 id="1-自动适配的问题"><a href="#1-自动适配的问题" class="headerlink" title="1. 自动适配的问题"></a>1. 自动适配的问题</h3><p>在上面说了我们可以通过一些标签或者CSS属性声明，来自动适配深色模式，但是从自动适配的结果来看，适配的并不理想：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_light_right_auto_dark.png" alt="左边浅色，右边是浏览器自动适配的深色"></p>
<ul>
<li><p>首先是默认的黑色字体，到深色模式下变成了纯白色<code>#FFFFFF</code>，和黑色背景（虽然说不是纯黑）对比起来很扎眼，在一些设计相关的文章[<a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">1</a>][<a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">2</a>]里提到，深色模式下避免使用纯黑和纯白，否则更容易使人眼睛👁疲劳，同时容易在页面滚动时出现拖影：</p>
<p>  <img src="https://static.youfindme.cn/blog/dark_mode/smearing_when_scrolling.png" alt="滚动时出现拖影，图片来源「即刻」"></p>
</li>
<li><p>自动适配只能适配没有指定颜色和背景色的内容，比如上面的1、2、3级文字还有背景，没有显式设置<code>color</code>和<code>background-color</code>。</p>
<p>  对于设置了颜色和背景色（这种现象在开发中很常见吧）的内容，就无法自动适配，比如上面的7个色块的背景色，写死了颜色，但是色块上的文字没有设置颜色。最终在深色渲染下渲染出的效果就是，色块背景色没变，但是色块上的文字变成了白色，导致一些文字很难看清。</p>
</li>
</ul>
<p>所以，最好还是自定义适配逻辑，除了解决上面的问题，还可以加一下其他的东西，比如加一些深浅色模式变化时的过渡动画等。</p>
<h3 id="2-如何自定义适配"><a href="#2-如何自定义适配" class="headerlink" title="2. 如何自定义适配"></a>2. 如何自定义适配</h3><p>自定义适配有两种方式，CSS媒体查询和通过JS监听主题模式</p>
<h4 id="1-CSS媒体查询"><a href="#1-CSS媒体查询" class="headerlink" title="1). CSS媒体查询"></a>1). CSS媒体查询</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">prefers-color-scheme - CSS：层叠样式表 | MDN</a><br>我们可以通过在CSS中设置媒体查询<code>@media (prefers-color-scheme: dark)</code>，来设置深色模式下的自定义颜色。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#404040</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#bfbfbf</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">  <span class="selector-class">.textLevel1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.textLevel3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过媒体查询设置元素在深色模式下的1、2、3级文字的颜色，在浅色模式下设置不同的颜色，在深色模式下，增加不透明度：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/left_auto_right_manul.png" alt="左边的是自动适配的浅色深色，右边是自定义适配的浅色深色"></p>
<p>对于<code>prefers-color-scheme</code>的兼容性也不必担心，主流浏览器基本都支持了：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/prefers_color_scheme.png" alt="prefers-color-scheme"></p>
<h4 id="2-JS监听主题颜色"><a href="#2-JS监听主题颜色" class="headerlink" title="2). JS监听主题颜色"></a>2). JS监听主题颜色</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia">Window.matchMedia() - Web API 接口参考 | MDN</a></p>
<p>通过CSS媒体查询适配深色模式已经很方便了，完全不需要修改JS代码逻辑，那为什么还需要JS监听主题颜色呢？</p>
<p>因为通过CSS媒体查询虽然方便，但是只能跟随系统的主题颜色变化，假设用户想要类似于下面的自定义主题颜色，不跟随系统变化，或者业务上想做一些什么高级的操作，那么CSS媒体查询就无能为力了。</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/custom_mode.gif" alt="custom_theme.gif"></p>
<p>在JS中，可以通过<code>window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).match</code>来判断当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> darkModeMediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (darkModeMediaQuery.matches) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.matches) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果使用的是React，还可以写一个自定义hooks，来监听当前的颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> EColorScheme &#123;</span><br><span class="line">  LIGHT = <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">  DARK = <span class="string">&#x27;dark&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h4><p>我写完这个hooks之后，有一次偶然用Chat GPT让它写一段监听深色模式的代码，写成hooks，最后生成的代码和这个几乎一模一样，Chat GPT还是有点东西的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ThemeType = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTheme</span>(<span class="params"></span>): <span class="title">ThemeType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState&lt;ThemeType&gt;(</span><br><span class="line">    <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleChange = <span class="function">() =&gt;</span> setTheme(mediaQuery.matches ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    mediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> mediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, handleChange);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useTheme;</span><br></pre></td></tr></table></figure>

<p><code>window.matchMedia</code>的兼容性也挺好的：</p>
<p><img src="https://static.youfindme.cn/blog/dark_mode/window_match_media.png" alt="window.matchMedia"></p>
<p>通过JS监听颜色主题变化之后，那可玩性就很多了，我们可以通过下面这些方式来适配深色模式：</p>
<ul>
<li><p>动态添加类名覆盖样式</p>
<p>  通过判断深色模式来添加一个深色模式的类名，覆盖浅色模式样式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=&#123;classnames(</span><br><span class="line">    style.wrapper,</span><br><span class="line">    scheme === EColorScheme.DARK &amp;&amp; style.darkModeWrapper</span><br><span class="line">  )&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  &#123;/* some code here */&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>对于深色模式直接引用不同的CSS资源文件</p>
</li>
<li><p>用一些第三方的库，比如<code>postcss-darkmode</code>等</p>
</li>
</ul>
<p>回到上面话题，通过JS可以监听到系统的颜色主题，那怎么实现用户主动选择颜色主题，不随系统的改变呢？其实也很简单，可以在本地store中设置一个颜色主题的值，用户设置了就优先选用store里的，没有设置就跟随系统，以上面的hooks为例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useColorScheme = (): <span class="function"><span class="params">EColorScheme</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 store 中取出用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">const</span> manualScheme = useSelector(selectManualColorScheme);</span><br><span class="line">  <span class="keyword">const</span> [scheme, setScheme] = useState(</span><br><span class="line">    darkModeMediaQuery.matches ? EColorScheme.DARK : EColorScheme.LIGHT</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = <span class="function">(<span class="params">event: MediaQueryListEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      setScheme(event.matches ? EColorScheme.DARK : EColorScheme.LIGHT);</span><br><span class="line">    &#125;;</span><br><span class="line">    darkModeMediaQuery.addEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      darkModeMediaQuery.removeEventListener(<span class="string">&#x27;change&#x27;</span>, listener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先取用户手动设置的主题</span></span><br><span class="line">  <span class="keyword">return</span> manualScheme || scheme;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="React-Native中的适配"><a href="#React-Native中的适配" class="headerlink" title="React Native中的适配"></a>React Native中的适配</h2><p>上面说的都是在浏览器里对深色模式的适配，那在React Native里面要怎么适配深色模式呢？</p>
<h3 id="1-大于等于0-62的版本"><a href="#1-大于等于0-62的版本" class="headerlink" title="1. 大于等于0.62的版本"></a>1. 大于等于0.62的版本</h3><p><a target="_blank" rel="noopener" href="https://reactnative.dev/docs/appearance">Appearance · React Native</a></p>
<p>在React Native 0.62版本中，引入了<code>Appearance</code>模块，通过这个模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColorSchemeName = <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Appearance &#123;</span><br><span class="line">  <span class="keyword">type</span> AppearancePreferences = &#123;</span><br><span class="line">    <span class="attr">colorScheme</span>: ColorSchemeName;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> AppearanceListener = <span class="function">(<span class="params">preferences: AppearancePreferences</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note: Although color scheme is available immediately, it may change at any</span></span><br><span class="line"><span class="comment">   * time. Any rendering logic or styles that depend on this should try to call</span></span><br><span class="line"><span class="comment">   * this function on every render, rather than caching the value (for example,</span></span><br><span class="line"><span class="comment">   * using inline styles rather than setting a value in a `StyleSheet`).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Example: `const colorScheme = Appearance.getColorScheme();`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add an event handler that is fired when appearance preferences change.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove an event handler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChangeListener</span>(<span class="params">listener: AppearanceListener</span>): <span class="title">EventSubscription</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A new useColorScheme hook is provided as the preferred way of accessing</span></span><br><span class="line"><span class="comment"> * the user&#x27;s preferred color scheme (aka Dark Mode).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useColorScheme</span>(<span class="params"></span>): <span class="title">ColorSchemeName</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>Appearance</code>模块，可以获得当前的系统颜色主题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = Appearance.getColorScheme();</span><br><span class="line"><span class="keyword">if</span> (colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// dark mode</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// light mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Appearance.addChangeListener(<span class="function">(<span class="params">prefer: Appearance.AppearancePreferences</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prefer.colorScheme === <span class="string">&#x27;dark&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// dark mode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// light mode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时也提供了一个上面我们自己实现的hooks，<code>useColorScheme</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorScheme = useColorScheme();</span><br></pre></td></tr></table></figure>

<h4 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h4><ol>
<li><p><code>Appearance</code>这个接口在Chrome调试模式下，会不生效，永远返回<code>light</code></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></p>
</li>
<li><p><code>Appearance</code>想要生效，还需要Native做一些配置</p>
<p> <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></p>
<blockquote>
<p>Also make sure you do <strong>not</strong> have UIUserInterfaceStyle set in your Info.plist. I had it set to ‘light’ so Appearance.getColorScheme() was always returning ‘light’.</p>
</blockquote>
</li>
</ol>
<h3 id="2-小于0-62的版本"><a href="#2-小于0-62的版本" class="headerlink" title="2. 小于0.62的版本"></a>2. 小于0.62的版本</h3><p>对于0.62之前的版本，由于RN没有提供官方接口，需要通过第三方的库<code>react-native-dark-mode</code>来实现：<br><a target="_blank" rel="noopener" href="https://github.com/codemotionapps/react-native-dark-mode">GitHub - codemotionapps/react-native-dark-mode: Detect dark mode in React Native</a></p>
<p>它的实现原理感兴趣的可以看下：</p>
<blockquote>
<p><strong>react-native-dark-mode 实现原理</strong>(这段实现原理其实也是问Chat GPT得到的答案😂)</p>
<p><code>react-native-dark-mode</code>库的实现原理比较简单，它主要是利用了原生平台的接口来检测当前系统是否处于深色模式。在iOS平台上，它使用了<code>UIUserInterfaceStyle</code>接口来获取当前系统的界面风格，然后判断是否为暗黑模式。在Android平台上，它使用了<code>UiModeManager</code>接口来获取当前系统的 UI 模式，然后判断是否为夜间模式。</p>
<p>具体来说，<code>react-native-dark-mode</code>在React Native项目中提供了一个名为<code>useDarkMode</code>的 React Hooks，用于获取当前系统是否处于深色模式。当使用这个Hooks时，它会首先检测当前平台是否支持暗黑模式，如果支持，就直接调用原生平台的接口获取当前系统的界面风格或UI模式，并将结果返回给调用方。如果不支持，就返回一个默认值（比如浅色模式）。</p>
<p>需要注意的是，由于<code>react-native-dark-mode</code>是一个纯JS库，它无法直接调用原生平台的接口。所以它在Native端编写了一个名为<code>DarkMode</code>的模块，在JS层通过<code>NativeModules.DarkMode</code>来调用。</p>
<ul>
<li>在iOS上，<code>DarkMode</code>模块会通过<code>RCT_EXPORT_MODULE()</code>宏将自己暴露给RN的JS层。同时，它还会使用<code>RCT_EXPORT_METHOD()</code>宏将检测系统界面风格的方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
<li>在Android上，<code>DarkMode</code>模块同样会通过<code>@ReactModule</code>注解将自己暴露给JS层。然后，它会创建一个名为<code>DarkModeModule</code>的Java类，并在该类中实现检测系统UI模式的方法。最后，它会使用<code>@ReactMethod</code>注解将该方法暴露给JS层，使得在JS中可以直接调用该方法。</li>
</ul>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7044043307340529694#heading-8">web深色模式适配指南 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904024085364750">扫盲， H5适配暗黑主题（DarkMode）全部解法 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://36kr.com/p/1724109946881">紧跟潮流学设计：深色模式设计的8个小技巧-36氪</a></li>
<li><a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/4068702.html">即刻7.0：如何设计深色模式？（非官方） | 人人都是产品经理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xiaoxili.com/hi-face/docs/other/minapp-to-dark-mode.html">【草稿】深色模式在Web端的适配技巧，附带小程序侧的思考 · Hi头像</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cpming.top/p/detect-dark-mode-in-rn">在 React Native 中检测并适配暗黑模式 - 长跑茗</a></li>
<li><a target="_blank" rel="noopener" href="https://web.dev/color-scheme/">Improved dark mode default styling with the color-scheme CSS property and …</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react-native/issues/29144">Appearance.getColorScheme() always returns ‘light’</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61124229/react-native-0-62-2-appearance-return-wrong-color-scheme">React Native 0.62.2 Appearance return wrong color scheme</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/08/18/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Jest单元测试中常用的方法和技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-18 09:49:00" itemprop="dateCreated datePublished" datetime="2021-08-18T09:49:00+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-03 10:55:27" itemprop="dateModified" datetime="2024-01-03T10:55:27+08:00">2024-01-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文首次发布于<a target="_blank" rel="noopener" href="https://juejin.cn/post/6997581158670630948">掘金</a>，转载请注明来源。</p>
</blockquote>
<h2 id="一、mock模块"><a href="#一、mock模块" class="headerlink" title="一、mock模块"></a>一、mock模块</h2><p>在Jest中，对模块进行mock非常简单，只需要使用<code>jest.mock</code>即可，对于模块的mock主要有两种情况：</p>
<ol>
<li><p>只mock模块中的非<code>default</code>导出</p>
<p> 对于只有非<code>default</code>导出的情况（如<code>export const</code>、<code>export class</code>等），只需要使用<code>jest.mock</code>，返回一个对象即可，对象中包含有你想要mock的函数或者变量：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock &#x27;moduleName&#x27; 中的 foo 函数</span></span><br><span class="line">jest.mock(<span class="string">&#x27;../moduleName&#x27;</span>, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">foo</span>: jest.fn().mockReturnValue(<span class="string">&#x27;mockValue&#x27;</span>),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li>
<li><p>mock模块中的<code>default</code>导出</p>
<p> 对于<code>default</code>导出的mock，则不能返回一个简单的对象，而是需要在对象中包含一个<code>default</code>属性，同时添加<code>__esModule: true</code>。</p>
<blockquote>
<p>When using the factory parameter for an ES6 module with a default export, the __esModule: true property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it’s an instruction to import the property named default from the export object</p>
</blockquote>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleName, &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;../moduleName&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../moduleName&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">__esModule</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">default</span>: jest.fn(<span class="function">() =&gt;</span> <span class="number">42</span>),</span><br><span class="line">    <span class="attr">foo</span>: jest.fn(<span class="function">() =&gt;</span> <span class="number">43</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">moduleName(); <span class="comment">// Will return 42</span></span><br><span class="line">foo(); <span class="comment">// Will return 43</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、mock模块部分内容"><a href="#二、mock模块部分内容" class="headerlink" title="二、mock模块部分内容"></a>二、mock模块部分内容</h2><p>如果只想mock模块中的部分内容，对于其他部分保持原样，可以使用<code>jest.requireActual</code>来引入真实的模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getRandom &#125; <span class="keyword">from</span> <span class="string">&#x27;../myModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../myModule&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Require the original module to not be mocked...</span></span><br><span class="line">  <span class="keyword">const</span> originalModule = jest.requireActual(<span class="string">&#x27;../myModule&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">__esModule</span>: <span class="literal">true</span>, <span class="comment">// Use it when dealing with esModules</span></span><br><span class="line">    ...originalModule,</span><br><span class="line">    <span class="attr">getRandom</span>: jest.fn().mockReturnValue(<span class="number">10</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getRandom(); <span class="comment">// Always returns 10</span></span><br></pre></td></tr></table></figure>

<h2 id="三、mock模块内部函数"><a href="#三、mock模块内部函数" class="headerlink" title="三、mock模块内部函数"></a>三、mock模块内部函数</h2><p>设想一种情况，有一个<code>utils.ts</code>文件，内部导出了两个函数<code>funcA</code>和<code>funcB</code>，然后在<code>funcB</code>中引用了<code>funcA</code>:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  funcA();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候在对<code>funcB</code>进行单元测试时，如果想要对<code>funcA</code>进行mock，会发现mock失败：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; funcA, funcB &#125; <span class="keyword">from</span> <span class="string">&#x27;../src/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">&#x27;../src/utils&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originalModule = jest.requireActual(<span class="string">&#x27;../src/utils&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...originalModule,</span><br><span class="line">    <span class="attr">funcA</span>: jest.fn(),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;utils.ts 单元测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&#x27;测试 funcB&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    funcB();</span><br><span class="line">    expect(funcA).toBeCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行单测会得到一个报错</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/get_error_for_test.png" alt="jest单测报错"></p>
<p>很明显，我们对<code>funcA</code>的mock失败了，为什么会有这样的结果呢，因为我们从模块外部导入的<code>funcA</code>引用和模块内部直接使用的<code>funcA</code>引用并不是同一个，通过<code>jest.mock</code>修改<code>funcA</code>并不会影响内部的调用。对于这种情况，建议的解决方法有两种：</p>
<ul>
<li>拆分文件，将<code>funcA</code>拆分到不同的文件。这种做法可能会造成文件过多且分散的问题。</li>
<li>将相互调用的函数，作为一个工具类的方法来实现。即将互相调用的函数，放到同一个工具类中。</li>
</ul>
<h2 id="四、mock类（class）构造函数中对其他成员函数的调用"><a href="#四、mock类（class）构造函数中对其他成员函数的调用" class="headerlink" title="四、mock类（class）构造函数中对其他成员函数的调用"></a>四、mock类（<code>class</code>）构造函数中对其他成员函数的调用</h2><p>当我们在mock一个<code>class</code>的方法的时候，很简单地将类对象的对应方法赋值为<code>jest.fn()</code>即可，但是对于在构造函数中调用的成员方法，却不能这样做。因为类里面的方法只能在实例化完成之后再进行mock，不能阻止<code>constructor</code>中执行原函数。</p>
<p>这时，我们可以考虑一下，<code>class</code>的本质是什么，<code>class</code>是ES6中的语法糖，本质上还是ES5中的原型<code>prototype</code>，所以类的成员方法本质上也是挂载到类原型上的方法，所以我们只需要mock类构造函数的原型上的方法即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.init = jest.fn();</span><br></pre></td></tr></table></figure>

<h2 id="五、mock类中的私有函数（针对TypeScript而言）"><a href="#五、mock类中的私有函数（针对TypeScript而言）" class="headerlink" title="五、mock类中的私有函数（针对TypeScript而言）"></a>五、mock类中的私有函数（针对TypeScript而言）</h2><p>对于ts中类的私有函数（<code>private</code>），无法直接获取（虽然说可以<code>ts-ignore</code>忽略ts报错，不过不建议这样做），这时只需使用同样的方法，在类的原型上直接mock即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">funcA</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.funcA = jest.fn();</span><br></pre></td></tr></table></figure>

<h2 id="六、mock对象的只读属性（getter）"><a href="#六、mock对象的只读属性（getter）" class="headerlink" title="六、mock对象的只读属性（getter）"></a>六、mock对象的只读属性（<code>getter</code>）</h2><p>在单测中，对于可读可写属性我们可以比较方便地进行mock，直接赋值为对应的mocK值即可，如<code>Platform.OS</code>。但是对于只读属性（<code>getter</code>）的mock却不能直接这样写。通常对于只读属性（此处以<code>document.body.clientWidth</code>为例）有以下两种mock方式：</p>
<ol>
<li><p>通过<code>Object.defineProperty</code></p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">document</span>.body, <span class="string">&#x27;clientWidth&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">set</span>: jest.fn(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>jest.spyOn</code></p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockClientWidth = jest.spyOn(<span class="built_in">document</span>.body, <span class="string">&#x27;clientWidth&#x27;</span>, <span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">mockClientWidth.mockReturnValue(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、使用toBeCalledWith对参数中的匿名函数进行断言"><a href="#七、使用toBeCalledWith对参数中的匿名函数进行断言" class="headerlink" title="七、使用toBeCalledWith对参数中的匿名函数进行断言"></a>七、使用<code>toBeCalledWith</code>对参数中的匿名函数进行断言</h2><p>我们需要对于某个方法测试时，有时需要断言这个方法以具体参数被调用，<code>toBeCalledWith</code>可以实现这个功能，但是设想下面一种情况</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> func = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* condition 1 */</span>) &#123;</span><br><span class="line">    moduleA.method1(<span class="number">1</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    moduleA.method1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某种情况下，<code>moduleA.method1</code>将会被传入参数<code>1</code>和一个匿名函数，要怎么用<code>toBeCalledWith</code>断言<code>moduleA.method1</code>被以这些参数调用了呢？因为第二个参数是一个匿名函数，外部没办法mock。这个时候，我们可以使用<code>expect.any(Function)</code>来断言：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moduleA.method1 = jest.fn();</span><br><span class="line"><span class="comment">// 构造出 condition 1</span></span><br><span class="line">func();</span><br><span class="line">expect(moduleA.method1).toBeCalledWith(<span class="number">1</span>, expect.any(<span class="built_in">Function</span>));</span><br></pre></td></tr></table></figure>

<p>因为这里其实只关心<code>moduleA.method1</code>是否被传入第二个参数且参数是否为一个函数，而不关心函数的具体内容，所以可以用<code>expect.any(Function)</code>来断言。</p>
<h2 id="八、mock-localStorage"><a href="#八、mock-localStorage" class="headerlink" title="八、mock localStorage"></a>八、mock <code>localStorage</code></h2><p><code>localStorage</code>是浏览器环境下的一个全局变量，挂载在<code>window</code>下，在单测运行时（Node环境）是获取不到的，对于<code>localStorage</code>，我们可以实现一个简单的mock：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStorageMock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> store: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">setItem</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.store[key] = <span class="built_in">String</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getItem(key: <span class="built_in">string</span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.store[key] || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">removeItem</span>(<span class="params">key: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.store[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.store = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> key(index: <span class="built_in">number</span>): <span class="built_in">string</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.store)[index] || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span> <span class="title">length</span>(): <span class="title">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.store).length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">global</span>.localStorage = <span class="keyword">new</span> LocalStorageMock();</span><br></pre></td></tr></table></figure>

<p>建议把mock放到单独的mocks文件中，在需要测试的地方，单独引入即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./__mocks__/localStorage&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="九、mock-indexedDB"><a href="#九、mock-indexedDB" class="headerlink" title="九、mock indexedDB"></a>九、mock <code>indexedDB</code></h2><p>对于indexedDB，情况和<code>localStorage</code>类似，它是浏览器环境下的一个事务型数据库系统，同样在Node环境中无法获取，但是由于indexedDB接口、类型较多，实现起来较为复杂，不建议自己实现，比较常见的做法是使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/fake-indexeddb">fake-indexeddb</a>这个库，这个库使用纯js在内存中实现了indexedDB的各种接口，主要用于在Node环境中对依赖indexedDB的代码进行测试。</p>
<p>对于需要测试的文件，只需要在文件开头引入<code>fake-indexeddb/auto</code>即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;fake-indexeddb/auto&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要对所有的文件都引入<code>fake-indexeddb</code>，那么只需要在jest配置中添加如下配置：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">setupFiles</span>: [<span class="string">&#x27;fake-indexeddb/auto&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或在<code>package.json</code>中</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;setupFiles&quot;</span>: [<span class="string">&quot;fake-indexeddb/auto&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、测试异步函数"><a href="#十、测试异步函数" class="headerlink" title="十、测试异步函数"></a>十、测试异步函数</h2><p>在单测中，如果需要对异步函数进行测试，针对不同情况有如下操作：</p>
<ol>
<li><p><code>callback</code>回调函数异步</p>
<p> 对于回调函数异步（如<code>setTimeout</code>回调），如果像同步函数一样进行测试，是没办法获取正确的断言结果的：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcA = (callback: <span class="function">(<span class="params">data: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcA&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  funcA(<span class="function">(<span class="params">data</span>) =&gt;</span> expect(data).toEqual(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 像上面那样，<code>funcA</code>会在回调里传入1，单测里就算是直接断言结果为2，也是可以直接通过单测的：</p>
<p> <img src="https://static.youfindme.cn/blog/jest_techniques/callback_async_unit_test.png" alt="callback异步单测"></p>
<p> 这是因为jest在运行完<code>funcA</code>后就直接结束了，不会等待<code>setTimeout</code>的回调，自然也就没有执行<code>expect</code>断言。正确的做法是，传入一个<code>done</code>参数：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcA&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  funcA(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(<span class="number">2</span>);</span><br><span class="line">    done();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 在回调执行完之后显式地告诉jest异步函数执行完毕，jest会等到执行了<code>done()</code>之后再结束，这样就能得到预期的结果了。</p>
</li>
<li><p><code>Promise</code>异步</p>
<p> 除了回调函数外，另外一种很常见的异步场景就是<code>Promise</code>了，对于<code>Promise</code>异步，不用像上面那么复杂，只需要在<code>test</code>用例结束时，把<code>Promise</code>返回即可：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcB = (): <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcB&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> funcB().then(<span class="function">(<span class="params">data</span>) =&gt;</span> expect(data).toEqual(<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 如果使用了<code>async/await</code>语法，就更简洁了，<code>Promise</code>都不需要返回，像测试同步代码一样直接书写即可：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcB&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> funcB();</span><br><span class="line">  expect(data).toEqual(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 对于<code>Promise</code>抛出的异常，测试方法也和上面类似：</p>
 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出异常的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funcC = (): <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&#x27;something wrong&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;funcC promise&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> funcC().catch(<span class="function">(<span class="params">error</span>) =&gt;</span> expect(error).toEqual(<span class="string">&#x27;something wrong&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">test(<span class="string">&#x27;funcC await&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> funcC();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    expect(error).toEqual(<span class="string">&#x27;something wrong&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="十一、不执行jest-spyOn-mock的函数"><a href="#十一、不执行jest-spyOn-mock的函数" class="headerlink" title="十一、不执行jest.spyOn mock的函数"></a>十一、不执行<code>jest.spyOn</code> mock的函数</h2><p>我们知道，<code>jest.fn</code>和<code>jest.spyOn</code>都可以用来mock一个函数，区别是<code>jest.fn</code> mock的函数不会去执行，而<code>jest.spyOn</code> mock的函数是会去正常执行的。那么有没有什么办法让<code>jest.spyOn</code> mock的函数不执行呢？其实上面已经用到了，在“mock对象的只读属性（<code>getter</code>）”中，通过<code>jest.spyOn</code> mock了一个<code>getter</code>，然后使用<code>mockReturnValue</code>来mock一个返回值，这个时候原函数就不会执行。</p>
<p>除此之外，使用<code>mockImplementation</code>也有同样的效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockFn.mockImplementation(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>总结下来就是可以使用<code>mockReturnValue</code>和<code>mockImplementation</code>不执行<code>jest.spyOn</code>mock的函数。</p>
<p>另外多说一个建议就是，能使用<code>jest.fn</code>就尽量不要用<code>jest.spyOn</code>，因为<code>jest.spyOn</code>会执行原始代码，在统计单测覆盖率时会被统计进去，导致单测覆盖率看起来很高实际上却又很多代码没有相应单测。</p>
<h2 id="十二、使用test-each"><a href="#十二、使用test-each" class="headerlink" title="十二、使用test.each"></a>十二、使用<code>test.each</code></h2><p>有时我们会遇到这种情况，要写大量单测用例，但是每个用例结构一样或相似，只有细微不同，比如测试某个<code>format</code>函数对于不同的字符串的返回结果，或者调用一个类不同的成员方法但返回的结果类似（如都抛出错误或<code>return null</code>等），对于这些情况，有时我们可以在单测内写一个数组然后遍历执行一下，但其实jest已经提供了应对这种情况的方法，即<code>test.each</code>，举几个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> checkString = (str: <span class="built_in">string</span>): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;mockError 1&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;mockError 2&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// each.test.ts</span></span><br><span class="line">describe(<span class="string">&#x27;each.ts 单元测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test.each&lt;&#123; <span class="attr">param</span>: <span class="built_in">string</span>; expectRes: <span class="built_in">boolean</span> | <span class="built_in">string</span> &#125;&gt;([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="string">&#x27;mockError 1&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="string">&#x27;mockError 2&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">param</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">      <span class="attr">expectRes</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ])(<span class="string">&#x27;checkString&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; param, expectRes &#125; = data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = checkString(param);</span><br><span class="line">      expect(result).toEqual(expectRes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      expect(error.message).toEqual(expectRes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>又比如在某种情况下，某个对象<code>store</code>的所有方法都会抛出异常：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test.each&lt;&#123;</span><br><span class="line">  <span class="attr">func</span>: <span class="string">&#x27;get&#x27;</span> | <span class="string">&#x27;delete&#x27;</span> | <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;update&#x27;</span>;</span><br><span class="line">  param?: <span class="built_in">any</span>;</span><br><span class="line">&#125;&gt;([</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;get&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;delete&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;add&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>, <span class="string">&#x27;mockValue&#x27;</span>] &#125;,</span><br><span class="line">  &#123; <span class="attr">func</span>: <span class="string">&#x27;update&#x27;</span>, <span class="attr">param</span>: [<span class="string">&#x27;mockKey&#x27;</span>, <span class="string">&#x27;mockValue&#x27;</span>] &#125;,</span><br><span class="line">])(<span class="string">&#x27;调用 store 的方法抛出异常&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> store[data.func](...data.param).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    expect(err).toEqual(<span class="string">&#x27;mockError&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除了<code>test.each</code>外，还有<code>describe.each</code>，更多具体用法可以参考<a target="_blank" rel="noopener" href="https://jestjs.io/docs/api#testeachtablename-fn-timeout">test.each</a>和<a target="_blank" rel="noopener" href="https://jestjs.io/docs/api#describeeachtablename-fn-timeout">describe.each</a></p>
<h2 id="十三、使用-test-js、-test-ts、-test-tsx"><a href="#十三、使用-test-js、-test-ts、-test-tsx" class="headerlink" title="十三、使用.test.js、.test.ts、.test.tsx"></a>十三、使用<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code></h2><p>这点是一个建议，建议单测文件以<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>命名，如对于<code>utils.ts</code>，建议对应的单测以<code>utils.test.ts</code>命名，这样每个单测文件单单从文件名来说就具有清晰的语义，即这是一个单测文件，而不是一个具有具体功能的源码文件。</p>
<p>同时，在搜索文件或者全局搜索字符串时，列表里的文件更清晰可见容易辨认。更进一步来说，现在很多IDE的文件图片icon插件，针对不同的文件名结尾，都有不同的渲染，更加方便辨认：<br><img src="https://static.youfindme.cn/blog/jest_techniques/search_file.png" alt="search_file"><br><img src="https://static.youfindme.cn/blog/jest_techniques/global_search.png" alt="global_search"></p>
<h2 id="十四、配合使用Jest-Runner插件"><a href="#十四、配合使用Jest-Runner插件" class="headerlink" title="十四、配合使用Jest Runner插件"></a>十四、配合使用<code>Jest Runner</code>插件</h2><p>另外推荐一个VSCode插件，<code>Jest Runner</code>，这个插件会在<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>中，渲染几个按钮选项：</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/run_debug.png" alt="run_debug"></p>
<p>点击<code>Run</code>或<code>Debug</code>，可以只运行或调试某一个<code>test</code>或者<code>describe</code>，不需要重新全局<code>npm run test</code>也不用单独<code>jest</code>执行这个文件，极大提高写单测的效率：</p>
<p><img src="https://static.youfindme.cn/blog/jest_techniques/run_debug_result.png" alt="run_debug_result"></p>
<p>这个插件只针对<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>这几个文件类型有效，所以这也是上面建议单测文件使用使用<code>.test.js</code>、<code>.test.ts</code>、<code>.test.tsx</code>命名的原因之一。</p>
<p>同时，插件提供的<code>Debug</code>，也省去了繁琐的<code>launch.json</code>配置，可以方便地进行断点调试。</p>
<h2 id="十五、其他技巧"><a href="#十五、其他技巧" class="headerlink" title="十五、其他技巧"></a>十五、其他技巧</h2><h3 id="1-jest配合enzyme对React-forwardRef组件进行测试"><a href="#1-jest配合enzyme对React-forwardRef组件进行测试" class="headerlink" title="1. jest配合enzyme对React.forwardRef组件进行测试"></a>1. jest配合enzyme对React.forwardRef组件进行测试</h3><p>对于React.forwardRef组件，假设有如下用例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;render&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Wrapper</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>);</span><br><span class="line">  expect(wrapper.find(<span class="comment">/** ComponentName */</span>).exists()).toBeTruthy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于普通的组件，“ComponentName”只需要填入对应组件的名字即可，如”Text”</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.find(<span class="string">&#x27;Text&#x27;</span>).exists()).toBeTruthy();</span><br></pre></td></tr></table></figure></li>
<li><p>但是对于使用了React.forwardRef来进行ref转发的组件，“ComponentName”则需要加上“ForwardRef”，如“ForwardRef(MyComponent)”</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.find(<span class="string">&#x27;ForwardRef(MyComponent)&#x27;</span>).exists()).toBeTruthy();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-收集单元测试覆盖率"><a href="#2-收集单元测试覆盖率" class="headerlink" title="2. 收集单元测试覆盖率"></a>2. 收集单元测试覆盖率</h3><p>有以下几种方式收集单元测试覆盖率：</p>
<ol>
<li><p>命令行执行全部单测并收集覆盖率</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx jest --coverage</span><br></pre></td></tr></table></figure></li>
<li><p>命令行执行单个单测文件并收集覆盖率</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx jest src/utils/__tests__/utils.test.ts --coverage</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>jest.config.js</code>中配置<code>collectCoverage</code>，同时设置<code>collectCoverageFrom</code>来收集指定文件的覆盖率</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">collectCoverage</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">collectCoverageFrom</span>: [</span><br><span class="line">    <span class="string">&#x27;src/**/*.&#123;js,jsx,ts,tsx&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;!src/**/*.d.ts&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样在命令行执行<code>npx jest</code>时，就会自动收集覆盖率了。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/07/07/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/07/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8C%96%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">前端代码规范化配置最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 10:00:13" itemprop="dateCreated datePublished" datetime="2021-07-07T10:00:13+08:00">2021-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-18 15:02:47" itemprop="dateModified" datetime="2024-01-18T15:02:47+08:00">2024-01-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文首次发布于个人博客<a href="https://youfindme.top/">youfindme.top</a>，转载请注明来源。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在前端项目开发过程中，我们经常会听到<strong>代码规范化</strong>这个词，即通过多种工具来对代码、Git记录等进行约束，使之达到某种规范。而这些规范工具多种多样，让人眼花缭乱，本文尝试通过一个<strong>工具集</strong>，来给出一种前端代码规范化的最佳实践。</p>
</blockquote>
<p>本文将基于<code>TypeScript</code>来讲解，工具集中主要包括以下工具：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://eslint.bootcss.com/"><code>eslint</code></a>：对代码进行风格和规范进行检查，对不符合规范的代码给出提示，同时可以进行一定程度的自动修复</li>
<li><a target="_blank" rel="noopener" href="https://prettier.io/"><code>prettier</code></a>：自动格式化代码工具，根据<code>prettier</code>规范对代码进行修复，拥有比<code>eslint</code>更加强大的代码规范性修复能力</li>
<li><a target="_blank" rel="noopener" href="https://typicode.github.io/husky/#/"><code>husky</code></a>：Git hooks工具，通过配置一系列钩子，可以在<code>git</code>操作的不同阶段执行相应的命令</li>
<li><a target="_blank" rel="noopener" href="https://github.com/okonet/lint-staged"><code>lint-staged</code></a>：在提交代码前进行lint检查时，可以让lint只检查<code>git</code>暂存区（<code>staged</code>）的文件，而不会检查所有文件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/commitizen/cz-cli"><code>commitzen</code></a>：可以实现规范的提交说明的<code>git-cz</code>工具，提供选择的提交信息类别，快速生成提交说明，如果需要在项目中使用<code>commitizen</code>生成符合某个规范的提交说明，则需要使用对应的适配器</li>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint"><code>commit-lint</code></a>：校验提交说明是否符合规范。<code>commitzen</code>只是一个实现规范提交说明的工具，但可能存在不使用这个工具直接用<code>git</code>提交的情况，那么就需要对每次提交说明进行检查是否符合规范</li>
</ul>
<p>除了上面提到的，其他相关工具会在用到的时候再详细说明。</p>
<h2 id="一、eslint-amp-prettier"><a href="#一、eslint-amp-prettier" class="headerlink" title="一、eslint &amp; prettier"></a>一、eslint &amp; prettier</h2><h3 id="1-首先安装eslint和prettier及相关工具"><a href="#1-首先安装eslint和prettier及相关工具" class="headerlink" title="1. 首先安装eslint和prettier及相关工具"></a>1. 首先安装<code>eslint</code>和<code>prettier</code>及相关工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint prettier</span><br><span class="line">npm install --save-dev eslint-plugin-prettier eslint-config-prettier</span><br><span class="line">npm install --save-dev @typescript-eslint/parser  @typescript-eslint/eslint-plugin</span><br><span class="line">npm install --save-dev eslint-plugin-import</span><br><span class="line">npm install --save-dev eslint-import-resolver-typescript</span><br></pre></td></tr></table></figure>

<p>其中除了<code>eslint</code>和<code>prettier</code>外的其他几个工具作用分别是：</p>
<ul>
<li><code>eslint-plugin-prettier</code>：将 prettier 的能力集成到 eslint 中, 按照 prettier 的规则检查代码规范性，并进行修复</li>
<li><code>eslint-config-prettier</code>：让所有可能会与 prettier 规则存在冲突的 eslint rule 失效，并使用 prettier 的规则进行代码检查</li>
<li><code>@typescript-eslint/parser</code>： 解析器，使 eslint 可以解析 ts 语法</li>
<li><code>@typescript-eslint/eslint-plugin</code>：指定了 ts 代码规范的 plugin</li>
<li><code>eslint-plugin-import</code>：对 ES6+ 的导入/导出语法进行 lint, 并防止文件路径和导入名称拼写错误的问题</li>
<li><code>eslint-import-resolver-typescript</code>：这个插件为<code>eslint-plugin-import</code>添加了 ts 支持，详见<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-import-resolver-typescript">此处</a></li>
</ul>
<h3 id="2-配置-eslintrc-js和-prettierrc-js"><a href="#2-配置-eslintrc-js和-prettierrc-js" class="headerlink" title="2. 配置.eslintrc.js和.prettierrc.js"></a>2. 配置<code>.eslintrc.js</code>和<code>.prettierrc.js</code></h3><p>首先配置<code>.eslintrc.js</code>（或者<code>.eslintrc.json</code>，不建议使用<code>.eslingtrc</code>），常用配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es6</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析器</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>], <span class="comment">// 使用 eslint 和 typescript-eslint 建议的规则</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>, <span class="string">&#x27;import&#x27;</span>], <span class="comment">// 代码规范插件</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 不符合 prettier 规则的代码，要进行错误提示</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">settings</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;import/parsers&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;import/resolver&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">typescript</span>: &#123;</span><br><span class="line">        <span class="attr">project</span>: <span class="string">&#x27;tsconfig.json&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来配置<code>.prettierrc.js</code>（或者<code>.prettierrc.json</code>，<code>.prettierrc</code>），常用规则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>,</span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">80</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果需要还可以加上相应的<code>.eslintignore</code>和<code>.prettierignore</code>来忽略想要的目录/文件。</p>
<h3 id="3-向package-json的scripts中添加命令"><a href="#3-向package-json的scripts中添加命令" class="headerlink" title="3. 向package.json的scripts中添加命令"></a>3. 向<code>package.json</code>的<code>scripts</code>中添加命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx ./ --fix&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以尝试一下编辑任意<code>js</code>或<code>ts</code>文件并保存，通过<code>npm run lint</code>命令来对项目进行 lint 检查，查看是否符合规则的预期。通过<code>npm run lint:fix</code>命令可以对不符合风格规范的代码进行自动修复。</p>
<p>如果需要对另外一些语法进行 lint 检查，只需添加对应的工具即可，比如想要对<code>react</code>和<code>react hooks</code>进行检查，则安装<code>eslint-plugin-react</code>和<code>eslint-plugin-react-hooks</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-plugin-react eslint-plugin-react-hooks</span><br></pre></td></tr></table></figure>

<p>之后按照各自的配置方式进行配置即可，详见 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react">eslint-plugin-react</a> 和 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>。</p>
<h3 id="4-添加-editorconfig文件"><a href="#4-添加-editorconfig文件" class="headerlink" title="4. 添加.editorconfig文件"></a>4. 添加<code>.editorconfig</code>文件</h3><p><code>.editorconfig</code>是一个用于跨编辑器和 IDE 统一代码风格的配置文件，也就是说通过这个文件，可以在不同的 IDE 中统一一些代码风格，比如统一缩进、换行符、字符编码等。</p>
<p>现在我们项目中添加一个<code>.editorconfig</code>文件，内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># More info here: http://editorconfig.org</span></span><br><span class="line"><span class="attr">root</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[*]</span></span><br><span class="line"><span class="comment"># Unix-style newlines with a newline ending every file</span></span><br><span class="line"><span class="attr">end_of_line</span> = lf</span><br><span class="line"><span class="attr">insert_final_newline</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Space indentation</span></span><br><span class="line"><span class="attr">indent_style</span> = space</span><br><span class="line"><span class="attr">indent_size</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default charset</span></span><br><span class="line"><span class="attr">charset</span> = utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trim trailing whitespace</span></span><br><span class="line"><span class="attr">trim_trailing_whitespace</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="5-安装-VS-Code-插件"><a href="#5-安装-VS-Code-插件" class="headerlink" title="5. 安装 VS Code 插件"></a>5. 安装 VS Code 插件</h3><p>如果你使用的编辑器或者 IDE 是VS Code，那么<strong>强烈建议</strong>安装下面几个VS Code插件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESlint</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig">EditorConfig for VS Code</a></li>
</ul>
<p>首先是ESlint和Prettier的插件，通过这两个插件可以实现<strong>实时查看</strong>当前的eslint和prettier报错而不需要执行命名行检查。</p>
<p>然后是EditorConfig的插件，通过这个插件，可以让VS Code读取项目中的<code>.editorconfig</code>文件，来覆盖VS Code的默认配置或者用户自定义的配置，从而实现一个项目内的统一风格。</p>
<h4 id="顺便聊一下这几个的区别"><a href="#顺便聊一下这几个的区别" class="headerlink" title="顺便聊一下这几个的区别"></a>顺便聊一下这几个的区别</h4><h5 id="eslint-和-prettier"><a href="#eslint-和-prettier" class="headerlink" title="eslint 和 prettier"></a>eslint 和 prettier</h5><ul>
<li>eslint侧重<strong>影响代码质量</strong>的问题（比如<code>==</code>和<code>===</code>）</li>
<li>prettier更侧重<strong>代码风格</strong>的问题（比如代码折行），以及对代码自动修复</li>
</ul>
<p>eslint很多地方只能warning警告或者报错，但是不能自动修复，比如下面的例子：</p>
<ol>
<li><p>对于<code>==</code>和<code>===</code>的eslint问题<br><img src="https://static.youfindme.cn/blog/code_normalization/eslint_issue.jpeg" alt="eslint_issue"></p>
<p><img src="https://static.youfindme.cn/blog/code_normalization/eslint_issue_fix.jpeg" alt="eslint_issue_fix"><br>这个是eslint报的一个问题，点击“快速修复”，只能弹出几个选项，比如disable这个规则，或者展示文档，没有自动修复（下面的copilot不算，这个是GitHub Copilot插件AI修复，不属于自动修复）</p>
</li>
<li><p>对于prettier的代码风格问题<br><img src="https://static.youfindme.cn/blog/code_normalization/prettier_issue.png" alt="prettier_issue"></p>
<p> <img src="https://static.youfindme.cn/blog/code_normalization/prettier_issue_fix.png" alt="prettier_issue_fix"></p>
</li>
</ol>
<p>对于这个代码风格问题，点击“快速修复”，提供了几个自动修复的选项（Fix this …/Fix all …）</p>
<h5 id="prettier-和-editorconfig"><a href="#prettier-和-editorconfig" class="headerlink" title="prettier 和 editorconfig"></a>prettier 和 editorconfig</h5><p>如果你仔细观察的话，会发现prettier和editorconfig的功能有一些重叠，比如都可以设置缩进、换行符等，那么这两个工具有什么区别呢？</p>
<p>拿缩进来说，如果在一个项目中的<code>.prettierrc.js</code>中设置了<code>tabWidth: 2</code>，但是我们的VS Code的默认缩进是4个空格。那么prettier在检查代码风格时，会按照2个空格来检测，自动修复的时候，也会把缩进改成2个空格。但是我们在编辑文件时，<strong>按一下Tab键，VS Code会使用4个空格来缩进</strong>。</p>
<p><img src="https://static.youfindme.cn/blog/code_normalization/tab_size.png" alt="tab_size"></p>
<p>这个时候就需要editorconfig来发挥作用了，在项目中添加一个<code>.editorconfig</code>文件，设置<code>indent_size = 2</code>，这样就可以覆盖VS Code的默认配置，使得VS Code在编辑文件时，<strong>按Tab键，也会使用2个空格来缩进</strong>。</p>
<h3 id="6-配置eslint和prettier的自动修复"><a href="#6-配置eslint和prettier的自动修复" class="headerlink" title="6. 配置eslint和prettier的自动修复"></a>6. 配置<code>eslint</code>和<code>prettier</code>的自动修复</h3><p>在上面的步骤中，我们已经完成了<code>eslint</code>和<code>prettier</code>的配置，同时通过插件也实现了实时检查，但是对于不符合规范的代码，我们还需要手动去修复，这个时候可以配置一下保存时自动修复的功能。</p>
<p>在项目中添加一个<code>.vscode/settings.json</code>文件，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span>: <span class="string">&quot;explicit&quot;</span></span><br><span class="line">    <span class="comment">// 在 VS Code 1.85 版本之前，这里的值要改为 &quot;source.fixAll.eslint&quot;: true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;[typescript]&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 添加你项目自己的语言配置，比如 javascriptreact、typescriptreact 等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，在<code>Ctrl + S</code>保存文件时，将会自动修复不符合规范的代码。</p>
<h2 id="二、husky"><a href="#二、husky" class="headerlink" title="二、husky"></a>二、husky</h2><p>通过上面的步骤，我们已经成功安装并配置了 eslint 相关的检查，但是我们不能仅仅依靠开发人员的自觉来保证提交到仓库的代码符合<code>eslint</code>规范，这时候就需要<code>husky</code>这样一个工具来操作<code>git</code>提供的一些钩子<code>hooks</code>，在提交代码时对代码进行 lint 检查。</p>
<h3 id="1-首先是安装husky"><a href="#1-首先是安装husky" class="headerlink" title="1. 首先是安装husky"></a>1. 首先是安装<code>husky</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev husky</span><br></pre></td></tr></table></figure>

<h3 id="2-向package-json的scripts中添加命令"><a href="#2-向package-json的scripts中添加命令" class="headerlink" title="2. 向package.json的scripts中添加命令"></a>2. 向<code>package.json</code>的<code>scripts</code>中添加命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;husky install&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepare</code>命令会在执行<code>npm install</code>（不带参数的情况下）之后自动执行。也就是说当我们执行<code>npm install</code>安装完项目依赖后会执行<code>husky install</code>命令，该命令会创建<code>.husky/</code>并指定该目录为git hooks所在的目录。这里我们先手动执行一次<code>npm run prepare</code>。</p>
<h3 id="3-配置husky"><a href="#3-配置husky" class="headerlink" title="3. 配置husky"></a>3. 配置<code>husky</code></h3><p>添加<code>pre-commit</code> hooks：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit // 或 npx husky set .husky/pre-commit</span><br></pre></td></tr></table></figure>

<p>这将在<code>./husky/</code>目录下生成一个<code>pre-commit</code>脚本文件，在文件里添加<code>npm run lint</code>这个命令，添加完成后文件内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run lint</span><br></pre></td></tr></table></figure>

<p>通过上面三个步骤，我们在执行<code>git commit</code>或者通过<code>git-cz</code>工具提交时，将会先执行<code>pre-commit</code>脚本的内容，即执行<code>npm run lint</code>检查，对不符合代码规范的提交进行阻止，防止污染代码仓库。</p>
<h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><p>上面配置<code>husky</code>的方式是针对 v5.0+ 的配置方式，针对 v5.0 之前的配置方式，则是在安装<code>husky</code>之后在<code>package.json</code>中添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么改的原因是在<code>husky</code> 5.0版本中，做了破坏性的变更，导致两种配置方式不兼容，详见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366786798">此处</a>。本文推荐使用最新的配置方式。</p>
<h2 id="三、lint-staged"><a href="#三、lint-staged" class="headerlink" title="三、lint-staged"></a>三、lint-staged</h2><p>完成<code>husky</code>配置之后，我们做到了通过每次git提交时都对项目做 lint 检查，防止不符合规范的代码提交到仓库，但是这带来一个问题：每次提交都将对整个项目做 lint 检查，对于一个越来越大的项目来说，这无疑是一个很耗时的操作，除此之外，对于新接入这些配置的项目，项目中可能已经存在了大量不符合规范的代码，不能要求在提交时把所有历史遗留的问题修复之后才能提交。这个时候就需要用到<code>lint-staged</code>这个工具了。</p>
<h3 id="1-安装lint-staged"><a href="#1-安装lint-staged" class="headerlink" title="1. 安装lint-staged"></a>1. 安装<code>lint-staged</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev lint-staged</span><br></pre></td></tr></table></figure>

<h3 id="2-在package-json中配置lint-staged"><a href="#2-在package-json中配置lint-staged" class="headerlink" title="2. 在package.json中配置lint-staged"></a>2. 在<code>package.json</code>中配置<code>lint-staged</code></h3><p>在<code>package.json</code>中添加如下配置，配置表明在运行<code>lint-staged</code>的时候将只匹配<code>src</code>和<code>test</code>目录下的<code>ts</code>和<code>tsx</code>文件，我们可以根据自己项目的需要修改配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;src/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;test/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-修改-husky-pre-commit脚本的内容"><a href="#3-修改-husky-pre-commit脚本的内容" class="headerlink" title="3. 修改.husky/pre-commit脚本的内容"></a>3. 修改<code>.husky/pre-commit</code>脚本的内容</h3><p>将<code>.husky/pre-commit</code>脚本的内容改为<code>npm run lint-staged</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run lint-staged</span><br></pre></td></tr></table></figure>

<p>通过上面的步骤，就完成了<code>lint-staged</code>的配置，这个时候再进行 git 提交时，将只检查暂存区（<code>staged</code>）的文件，不会检查项目所有文件，加快了每次提交 lint 检查的速度，同时也不会被历史遗留问题影响。如下图：<br><img src="https://static.youfindme.cn/blog/code_normalization/lint_staged.png" alt="lint_staged"></p>
<h2 id="四、commitzen"><a href="#四、commitzen" class="headerlink" title="四、commitzen"></a>四、commitzen</h2><p>有了上面的几个配置后，其实已经算是一个比较完善的代码规范配置了，不过还有一些其他的可以去做的事，比如 git 提交记录规范。</p>
<p>在多人协作开发过程中，如果不注意提交记录的规范，那么每个人可能都有自己的提交风格，如“修复了xxx的bug”、“增加了一个按钮,修改了一处文案”、“config配置文件增加了xxx字段”，更有甚者会在对项目文件做了大量变更后只写一个“增加了若干功能”或“修复了若干问题”这种提交信息。</p>
<p>那什么才一个好的提交信息呢，我们以<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular提交信息规范</a>来举例说明。</p>
<p>在 Angular 提交信息规范中，一个好的提交信息的结构应该如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>整个提交说明包括三部分：<code>header</code>页眉、<code>body</code>正文、<code>footer</code>页脚，在每个部分之间有一个空白行分隔，其中<code>header</code>部分是每次提交中必须包含的内容。</p>
<ul>
<li><code>header</code>:<br>对于<code>header</code>来说，又包括三部分：<ul>
<li><code>type</code><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#type">类型</a></li>
<li><code>scope</code>本次提交的<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#scope">影响范围</a>（可选）</li>
<li><code>subject</code><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#subject">主题</a>，即对提交的一个简短描述</li>
</ul>
</li>
<li><code>body</code>:<br>本地提交的详细描述，说明代码提交的详细说明</li>
<li><code>footer</code>:<br>主要包括本次提交的 BREAKING CHANGE（不兼容变更）和要关闭的 issue</li>
</ul>
<p>更加详细的内容请参考<a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular提交信息规范</a>。</p>
<p><code>commitzen</code>就是这样一个工具，它可以提供可以选择的提交信息类别，快速生成符合规范的提交说明。</p>
<h3 id="1-先安装commitizen和cz-conventional-changelog"><a href="#1-先安装commitizen和cz-conventional-changelog" class="headerlink" title="1. 先安装commitizen和cz-conventional-changelog"></a>1. 先安装<code>commitizen</code>和<code>cz-conventional-changelog</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>

<p>我们在前言中提到，如果需要在项目中使用<code>commitizen</code>生成符合某个规范的提交说明，则需要使用对应的适配器，而<code>cz-conventional-changelog</code>就是符合AngularJS规范提交说明的<code>commitzen</code>适配器。</p>
<h3 id="2-在package-json中配置commitizen"><a href="#2-在package-json中配置commitizen" class="headerlink" title="2. 在package.json中配置commitizen"></a>2. 在<code>package.json</code>中配置<code>commitizen</code></h3><p>在<code>package.json</code>中添加如下配置，配置指明了cz工具<code>commitizen</code>的适配器路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们就可以使用<code>npm run commit</code>来代替<code>git commit</code>进行提交了：<img src="https://static.youfindme.cn/blog/code_normalization/commitizen.png" alt="commitizen"></p>
<h3 id="3-配置自定义提交信息规范"><a href="#3-配置自定义提交信息规范" class="headerlink" title="3. 配置自定义提交信息规范"></a>3. 配置自定义提交信息规范</h3><p>如果想定制项目的提交信息规范，可以使用<code>cz-customizable</code>适配器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev cz-customizable</span><br></pre></td></tr></table></figure>

<p>然后把<code>package.json</code>中配置的适配器路径修改为<code>cz-customizable</code>的路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-customizable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在根目录下新建一个<code>.cz-config.js</code>来配置自定义的规范，这里提供一个官方的示例<a target="_blank" rel="noopener" href="https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js">cz-config-EXAMPLE.js</a>，修改里面字段、内容为自己想要的规范即可</p>
<h3 id="4-生成日志记录"><a href="#4-生成日志记录" class="headerlink" title="4. 生成日志记录"></a>4. 生成日志记录</h3><p>对于使用了<code>commitzen</code>的项目，还可以配套使用<code>conventional-changelog-cli</code>来生成开发日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev conventional-changelog-cli</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样执行<code>npm run version</code>之后就可以看到生成了<code>CHANGELOG.md</code>日志文件了。</p>
<h2 id="五、commit-lint"><a href="#五、commit-lint" class="headerlink" title="五、commit-lint"></a>五、commit-lint</h2><p>在配置了<code>commitizen</code>之后，我们可以愉快地使用<code>npm run commit</code>规范化提交代码，但是配置<code>commitizen</code>并不等于不能使用<code>git commit</code>或者其他工具提交，还是存在提交不规范记录说明的可能，那么就需要使用<code>commit-lint</code>来对每次提交信息进行限制。</p>
<h3 id="1-安装commitlint和-commitlint-config-conventional"><a href="#1-安装commitlint和-commitlint-config-conventional" class="headerlink" title="1. 安装commitlint和@commitlint/config-conventional"></a>1. 安装<code>commitlint</code>和<code>@commitlint/config-conventional</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitlint @commitlint/config-conventional</span><br></pre></td></tr></table></figure>

<p>其中<code>@commitlint/config-conventional</code>是一个符合Angular规范的校验规则集，就像<code>esint</code>也需要<code>extends</code>一些规则集一样，<code>commitlint</code>也需要<code>extends</code>一些规则集。</p>
<h3 id="2-在package-json中配置commitlint"><a href="#2-在package-json中配置commitlint" class="headerlink" title="2. 在package.json中配置commitlint"></a>2. 在<code>package.json</code>中配置<code>commitlint</code></h3><p>在<code>package.json</code>中添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;@commitlint/config-conventional&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向<code>package.json</code>的<code>scripts</code>中添加命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint --edit $1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们可能在别的地方见到过<code>commitlint</code>的下面这种写法</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，这也是一种在<code>husky</code> v5.0 之前的写法，在新版<code>husky</code>中不在使用。</p>
<h3 id="3-向husky中添加commit-msg-hooks"><a href="#3-向husky中添加commit-msg-hooks" class="headerlink" title="3. 向husky中添加commit-msg hooks"></a>3. 向<code>husky</code>中添加<code>commit-msg</code> hooks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg // 或 npx husky set .husky/commit-msg</span><br></pre></td></tr></table></figure>

<p>这将在<code>./husky/</code>目录下生成一个<code>commit-msg</code>脚本文件，在文件里添加<code>npm run commitlint</code>这个命令，添加完成后文件内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npm run commitlint</span><br></pre></td></tr></table></figure>

<p>这时，如果通过<code>git commit</code>或其他工具在提交时没有按照规范写提交信息，那么本次提交就会被阻止，如下图：<br><img src="https://static.youfindme.cn/blog/code_normalization/commit_lint.png" alt="commit_lint"></p>
<h3 id="4-对于自定义提交信息规范的-lint-校验"><a href="#4-对于自定义提交信息规范的-lint-校验" class="headerlink" title="4. 对于自定义提交信息规范的 lint 校验"></a>4. 对于自定义提交信息规范的 lint 校验</h3><p>上面说的<code>@commitlint/config-conventional</code>是针对Angular规范的校验规则集，对于使用了<code>cz-customizable</code>的自定义提交信息规范，就需要使用<code>commitlint-config-cz</code>这个工具来对自定义规范进行校验了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev commitlint-config-cz</span><br></pre></td></tr></table></figure>

<p>然后把<code>package.json</code>中<code>commitlint</code>的配置改为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;cz&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过上面的这些步骤，我们算是完成了前端代码规范化的配置，到目前，我们新增的配置有：</p>
<ul>
<li><code>.vscode/settings.json</code></li>
<li><code>.editorconfig</code></li>
<li><code>.eslintrc.js</code></li>
<li><code>.eslintignore</code></li>
<li><code>.prettierrc.js</code></li>
<li><code>.prettierignore</code></li>
<li><code>.husky</code><ul>
<li><code>pre-commit</code></li>
<li><code>commit-msg</code></li>
<li><code>_</code> husky自动生成的一个文件夹</li>
</ul>
</li>
<li><code>package.json</code> 下面只列出来新增的配置，对于<code>package.json</code>已有的字段没有列出</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;husky install&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;eslint . --ext .js,.jsx,.ts,.tsx ./ --fix&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;lint-staged&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;commitlint --edit $1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;src/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;test/**/*.&#123;ts,tsx&#125;&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;commitlint&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;@commitlint/config-conventional&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@commitlint/config-conventional&quot;</span>: <span class="string">&quot;^12.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/eslint-plugin&quot;</span>: <span class="string">&quot;^4.28.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/parser&quot;</span>: <span class="string">&quot;^4.28.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: <span class="string">&quot;^4.2.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;commitlint&quot;</span>: <span class="string">&quot;^12.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;conventional-changelog-cli&quot;</span>: <span class="string">&quot;^2.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cz-conventional-changelog&quot;</span>: <span class="string">&quot;^3.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^7.30.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-config-prettier&quot;</span>: <span class="string">&quot;^8.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-import-resolver-typescript&quot;</span>: <span class="string">&quot;^2.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-import&quot;</span>: <span class="string">&quot;^2.23.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-plugin-prettier&quot;</span>: <span class="string">&quot;^3.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;husky&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span>: <span class="string">&quot;^11.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: <span class="string">&quot;^2.3.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，还安装了三个 VS Code 插件。</p>
<p>配置过程虽然繁琐，但是对于一个项目，特别是多人协作的大型项目来说，是必不可少的一部分。其实担心配置麻烦，导致每一个新项目都需要重新走一遍配置流程，可以考虑使用<a target="_blank" rel="noopener" href="https://yowebapp.github.io/">Yeoman</a>这个脚手架工具，把一个已经完成代码规范化配置的项目作为模板，通过<a target="_blank" rel="noopener" href="https://github.com/yeoman/yo"><code>yo</code></a>直接一键生成即可，此处是我创建的一个 demo 工程，包含了上述全部配置：<a target="_blank" rel="noopener" href="https://github.com/JingzheWu/lint-demo">https://github.com/JingzheWu/lint-demo</a>，以供参考。</p>
<h2 id="参考文章和链接"><a href="#参考文章和链接" class="headerlink" title="参考文章和链接"></a>参考文章和链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904129463058445">快速配置eslint全家桶</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8312704c6be7">前端代码规范最佳实践：eslint+prettier+editorconfig+lint-staged</a></li>
<li><a target="_blank" rel="noopener" href="https://typicode.github.io/husky/#/">Husky</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/issues/2451">Husky v5 hook installation</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356924268">升级husky5实践</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366786798">husky使用总结</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903831893966856">Cz工具集使用介绍 - 规范Git提交说明</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/132348944">使用 commitizen 规范 Git 提交说明</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular commit message guidelines</a></li>
<li><a target="_blank" rel="noopener" href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">Angular提交信息规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/conventional-changelog-cli">conventional-changelog-cli</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://youfindme.top/2021/06/27/%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84AOP%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冰河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰河">
      <meta itemprop="description" content="冰河的个人网站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 冰河">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84AOP%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">浅谈JavaScript中的AOP和装饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 21:21:27" itemprop="dateCreated datePublished" datetime="2021-06-27T21:21:27+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-05 11:22:19" itemprop="dateModified" datetime="2024-01-05T11:22:19+08:00">2024-01-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>AOP在其他编程语言中应用较多，在js中却应用较少，由于最近参与的项目中涉及到性能打点上报等，开始探索和了解无侵入地监控或修改代码的方式，趁此机会深入学习了一下AOP与装饰器</p>
</blockquote>
<h3 id="一、什么是AOP"><a href="#一、什么是AOP" class="headerlink" title="一、什么是AOP"></a>一、什么是AOP</h3><p>AOP（Aspect-Oriented Programming），即<strong>面向切面编程</strong>，是一种编程范式，与之对应的有OOP（Object-Oriented Programming）面向对象编程。在JavaScript开发中，面向对象编程不管是ES5中直接操作原型还是ES6+中的class语法糖，大家用的比较多也应该都挺熟悉，但是相对而言，AOP用的就没那么多了。</p>
<p>对于OOP，我们在开发过程中往往是对类和对象通过继承进行<strong>纵向拓展</strong>，但是在AOP中则更侧重于把对象、方法作为切面，对原对象、方法进行<strong>无侵入</strong>的<strong>横向拓展</strong>，下面我们以一些简单的例子和代码来讲一下AOP。</p>
<p>假设我们有一个按钮，绑定了一个点击事件处理函数<code>handleClick</code>，现在需要对按钮增加点击上报，很简单，只需要在<code>handleClick</code>中调用一下上报函数就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">  report(<span class="string">&#x27;一条信息&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以后又需要增加对这个函数运行时间的上报，那么就需要在函数开头和结尾各自计算一下时间。</p>
<p>但是想一下，这样做带来的坏处是显而易见的，一是<strong>不利于拓展</strong>，每次增加新的点都需要改一次<code>handleClick</code>函数，改的越多越不利于后期维护；二是<strong>有悖于单一职责原则</strong>，<code>handleClick</code>里处理了大量非按钮的逻辑，同样增加了维护难度。这时候AOP就是一个很好的解决办法了。</p>
<h3 id="二、ES6-之前的实现"><a href="#二、ES6-之前的实现" class="headerlink" title="二、ES6+之前的实现"></a>二、ES6+之前的实现</h3><p>在ES5以及ES6+的装饰器出现之前，我们往往是这样做的（这里用了ES6的部分语法），通过修改<code>Function</code>构造函数的原型，给原型增加两个方法<code>before</code>和<code>after</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn, beforeFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn, afterFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这两个方法，实现在任意一个函数执行前后，执行我们自己自定义的行为，以达<strong>到装饰或拦截</strong>原函数、对象行为的目的。现在，实现上面点击上报的方式变成了这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handleClick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handleClick = handleClick.after(report, <span class="string">&#x27;一条信息&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>和修改原型类似的，我们还可以用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数HOF</a>来实现一个上报函数执行时间的函数（<code>before</code>和<code>after</code>本质上也是高阶函数，只不过是定义在<code>Function</code>原型上的高阶函数）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reportExeTime = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> beforeTime;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">      .before(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        beforeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      &#125;)</span><br><span class="line">      .after(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        report(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - beforeTime&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handleClick = reportExeTime(handleClick);</span><br></pre></td></tr></table></figure>

<p>假设之后还要增加其他和业务逻辑无关的埋点、统计、监控等逻辑，只需要通过类似的方式来装饰原函数即可，而无需修改原函数。通过这种方式，我们实现了对原函数无侵入的横向拓展，是一种比继承更具弹性的代替方案。</p>
<p>其实到这里，很多小伙伴已经意识到了，在前端开发中已经有很多地方已经用到过AOP这种思想了，例如React的高阶组件HOC、Redux的中间件等，都是这种思想的体现。</p>
<h3 id="三、ES6-通过装饰器实现"><a href="#三、ES6-通过装饰器实现" class="headerlink" title="三、ES6+通过装饰器实现"></a>三、ES6+通过装饰器实现</h3><p>上面说的是ES6+中装饰器出现前AOP的实现方式，然而装饰器（Decorators）的出现给我们提供了另一种更为优雅的实现方式（本质上和高阶函数类似），虽然到目前为止这个特性也还只是在<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-decorators">提案的第三阶段</a>，还未真正引入到ES标准中，但是通过Babel（&gt; 7.1.0）或者使用<a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/decorators.html">TypeScript</a>，就可以提前使用这个特性。</p>
<p>关于装饰器的定义和使用方法已经有很多资料讲解了，这里不做过多介绍，我们来看下用装饰器怎么实现上面的逻辑。很容易想到，这里需要的是<strong>方法装饰</strong>器，首先定义一个上报的方法装饰器<code>withReport</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withReport = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;上报了信息&#x27;</span>); <span class="comment">// 数据上报</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @withReport</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们还可以仿照上面的<code>before</code>和<code>after</code>，分别实现一个方法前置和后置<strong>装饰器工厂</strong>来执行任意前置后置方法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = <span class="function">(<span class="params">beforeFn, beforeFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">return</span> originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">afterFn, afterFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们可以方便地传入一个<code>report</code>函数来实现上报：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`上报了信息：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @after(report, <span class="string">&#x27;一条信息&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于后续增加的其他非业务相关逻辑，也可以通过多个装饰器组合来实现，如上报函数执行时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reportExeTime = <span class="function">(<span class="params">target, keyName, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> beforeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    report(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - beforeTime&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @after(report, <span class="string">&#x27;一条信息&#x27;</span>) <span class="comment">// 这个装饰器后执行</span></span><br><span class="line">  @reportExeTime <span class="comment">// 这个装饰器先执行</span></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过装饰器，我们更优雅地实现了AOP，对方法进行横向拓展，而且不会像之前那样直接修改<code>Function</code>原型（确实是一种不太好的方式，污染原型链），装饰器之所以可以做到这一点是因为它并不是在运行时改变类、属性、方法的行为，而是在代码编译的时候就修改了，所以本质上来讲，装饰器就是一个<strong>在编译时运行的语法糖函数</strong>。</p>
<h3 id="四、-AOP与装饰者模式和职责链模式"><a href="#四、-AOP与装饰者模式和职责链模式" class="headerlink" title="四、 AOP与装饰者模式和职责链模式"></a>四、 AOP与装饰者模式和职责链模式</h3><p>上面提到了，我们可以通过AOP来拓展函数或对象的行为，可以达到<strong>装饰或拦截</strong>原函数、对象行为的目的，对应的有两个设计模式，分别是<strong>装饰者模式</strong>和<strong>职责链模式</strong>（详见《JavaScript设计模式与开发实践》），AOP在这两种模式中的应用有一个明显的区别，就是能否阻断/覆盖原函数、对象的行为。有一点要声明的是，AOP只是实现这两种设计模式的其中一种方式，并不是唯一的实现方式，这里只是探讨在两种模式中AOP的应用。</p>
<p>对于装饰者模式，上面的几个示例都是很好的例子，不管是修改原型实现还是装饰器实现，都是通过<code>before</code>和<code>after</code>这两个来横向（区别于纵向的继承）的拓展原函数的能力，这里的<code>before</code>和<code>after</code>都是<strong>静默执行</strong>的，即<code>before</code>和<code>after</code>里执行的函数都不会阻断后续函数的执行或者覆盖原函数的返回值。应用场景也比较多，如上报、计时、日志等等，这也是AOP应用的比较多的场景。</p>
<p>然而对于职责链模式，对于<code>before</code>和<code>after</code>的能力要求则变成了：<code>before</code>和<code>after</code>里执行的函数可以阻断后续函数的执行，或<code>before</code>和<code>after</code>里执行的函数的返回值可以覆盖原函数的返回值。对应的代码实现变成了类似于下面这种：</p>
<ul>
<li>修改原型实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn, beforeFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> beforeRet = beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">    <span class="keyword">if</span> (!beforeRet) &#123;</span><br><span class="line">      <span class="comment">// 如果不合法则阻断后续操作，这里为了表示方便这样简写</span></span><br><span class="line">      <span class="keyword">return</span> beforeRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn, afterFnArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="comment">// 返回值符合条件时才返回，这里为了表示方便这样简写</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments); <span class="comment">// 在原函数返回值不符合条件时，执行after后续函数，覆盖原函数返回值</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = <span class="function">(<span class="params">beforeFn, beforeFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> beforeRet = beforeFn.call(<span class="built_in">this</span>, beforeFnArgs, ...arguments);</span><br><span class="line">      <span class="keyword">if</span> (!beforeRet) &#123;</span><br><span class="line">        <span class="comment">// 如果不合法则阻断后续操作，这里为了表示方便这样写</span></span><br><span class="line">        <span class="keyword">return</span> beforeRet;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">afterFn, afterFnArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, keyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originFn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ret = originFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="comment">// 返回值符合条件时才返回，这里为了表示方便这样简写</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> afterFn.call(<span class="built_in">this</span>, afterFnArgs, ...arguments); <span class="comment">// 在原函数返回值不符合条件时，执行after后续函数，覆盖原函数返回值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种也有很多应用场景，最常见的就是表单等的校验，如传入的值不合法，则阻断后续函数执行，或者在原函数返回值不符合要求时，则用after里函数的返回值来覆盖。</p>
<h3 id="五、-结语"><a href="#五、-结语" class="headerlink" title="五、 结语"></a>五、 结语</h3><p>其实除了上面提到的，我们还可以拓展下思路，上面对于函数的修饰，都是需要项目中的每个开发者手动在方法、类等前面显式调用，那么对于一些基础、通用的修饰方法，能否在打包构建时，通过打包构建插件分析语法树自动地给代码里的特定方法、类增加修饰，这个值得我们进一步思考探索。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冰河</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
